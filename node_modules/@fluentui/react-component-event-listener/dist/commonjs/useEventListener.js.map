{"version":3,"sources":["useEventListener.ts"],"names":["getWindowEvent","target","window","event","ownerDocument","defaultView","undefined","isActionSupported","element","method","useEventListener","options","capture","listener","type","targetRef","latestListener","React","useRef","current","eventHandler","useCallback","timeoutId","process","env","NODE_ENV","useEffect","Error","currentEvent","conditionalHandler","addEventListener","setTimeout","clearTimeout","removeEventListener"],"mappings":"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","sourcesContent":["import * as React from 'react';\n\nimport { EventHandler, EventListenerOptions, EventTypes, Target } from './types';\n\nconst getWindowEvent = (target: Target): Event | undefined => {\n  if (target) {\n    if (typeof (target as Window).window === 'object' && (target as Window).window === target) {\n      return target.event;\n    }\n\n    return (target as Node).ownerDocument?.defaultView?.event ?? undefined;\n  }\n\n  return undefined;\n};\n\nconst isActionSupported = (\n  element: Target | null | undefined,\n  method: 'addEventListener' | 'removeEventListener',\n): element is Target => (element ? !!element[method] : false);\n\nexport const useEventListener = <T extends EventTypes>(options: EventListenerOptions<T>): void => {\n  const { capture, listener, type, target, targetRef } = options;\n\n  const latestListener = React.useRef<EventHandler<T>>(listener);\n  latestListener.current = listener;\n\n  const eventHandler = React.useCallback((event: DocumentEventMap[T]) => {\n    return latestListener.current(event);\n  }, []);\n\n  const timeoutId = React.useRef<number | undefined>(undefined);\n\n  if (process.env.NODE_ENV !== 'production') {\n    // This is fine to violate there conditional rule as environment variables will never change during component\n    // lifecycle\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useEffect(() => {\n      if (typeof target !== 'undefined' && typeof targetRef !== 'undefined') {\n        throw new Error('`target` and `targetRef` props are mutually exclusive, please use one of them.');\n      }\n\n      if (typeof target === 'undefined' && typeof targetRef === 'undefined') {\n        throw new Error(\"`target` and `targetRef` props are `undefined`, it' required to use one of them.\");\n      }\n    }, [target, targetRef]);\n  }\n\n  React.useEffect(() => {\n    const element: Target | null | undefined = typeof targetRef === 'undefined' ? target : targetRef.current;\n\n    // Store the current event to avoid triggering handlers immediately\n    // Note this depends on a deprecated but extremely well supported quirk of the web platform\n    // https://github.com/facebook/react/issues/20074\n    let currentEvent = getWindowEvent(window);\n\n    const conditionalHandler = (event: DocumentEventMap[T]) => {\n      // Skip if this event is the same as the one running when we added the handlers\n      if (event === currentEvent) {\n        currentEvent = undefined;\n        return;\n      }\n\n      eventHandler(event);\n    };\n\n    if (isActionSupported(element, 'addEventListener')) {\n      element.addEventListener(type, conditionalHandler, capture);\n    } else if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        '@fluentui/react-component-event-listener: Passed `element` is not valid or does not support `addEventListener()` method.',\n      );\n    }\n\n    // @ts-ignore We have a collision between types from DOM and @types/node\n    timeoutId.current = setTimeout(() => {\n      currentEvent = undefined;\n    }, 1);\n\n    return () => {\n      clearTimeout(timeoutId.current);\n      currentEvent = undefined;\n\n      if (isActionSupported(element, 'removeEventListener')) {\n        element.removeEventListener(type, conditionalHandler, capture);\n      } else if (process.env.NODE_ENV !== 'production') {\n        throw new Error(\n          '@fluentui/react-component-event-listener: Passed `element` is not valid or does not support `removeEventListener()` method.',\n        );\n      }\n    };\n  }, [capture, eventHandler, target, targetRef, type]);\n};\n"],"file":"useEventListener.js"}