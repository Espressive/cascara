"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FocusZone = void 0;
var tslib_1 = require("tslib");
var accessibility_1 = require("@fluentui/accessibility");
var React = require("react");
var classnames_1 = require("classnames");
var _ = require("lodash");
var ReactDOM = require("react-dom");
var PropTypes = require("prop-types");
var utilities_1 = require("@uifabric/utilities");
var getElementType_1 = require("../utils/getElementType");
var getUnhandledProps_1 = require("../utils/getUnhandledProps");
var focusUtilities_1 = require("./focusUtilities");
var TABINDEX = 'tabindex';
var NO_VERTICAL_WRAP = 'data-no-vertical-wrap';
var NO_HORIZONTAL_WRAP = 'data-no-horizontal-wrap';
var LARGE_DISTANCE_FROM_CENTER = 999999999;
var LARGE_NEGATIVE_DISTANCE_FROM_CENTER = -999999999;
var _allInstances = {};
var outerZones = {
    _windowToOuterZoneMap: new Map(),
    register: function (window, FZ) {
        var _a, _b;
        if (this._windowToOuterZoneMap.get(window)) {
            (_a = this._windowToOuterZoneMap.get(window)) === null || _a === void 0 ? void 0 : _a.add(FZ);
        }
        else {
            this._windowToOuterZoneMap.set(window, new Set([FZ]));
        }
        return (_b = this._windowToOuterZoneMap.get(window)) === null || _b === void 0 ? void 0 : _b.size;
    },
    unregister: function (window, FZ) {
        var _a, _b;
        (_a = this._windowToOuterZoneMap.get(window)) === null || _a === void 0 ? void 0 : _a.delete(FZ);
        if (((_b = this._windowToOuterZoneMap.get(window)) === null || _b === void 0 ? void 0 : _b.size) === 0) {
            this._windowToOuterZoneMap.delete(window);
        }
    },
    getOutZone: function (window) {
        return this._windowToOuterZoneMap.get(window);
    },
};
var ALLOWED_INPUT_TYPES = ['text', 'number', 'password', 'email', 'tel', 'url', 'search'];
var ALLOW_VIRTUAL_ELEMENTS = false;
/**
 * Handle global tab presses so that we can patch tabindexes on the fly.
 */
function _onKeyDownCapture(ev) {
    var _a;
    if (accessibility_1.getCode(ev) === accessibility_1.keyboardKey.Tab) {
        (_a = outerZones.getOutZone(utilities_1.getWindow(ev.target))) === null || _a === void 0 ? void 0 : _a.forEach(function (zone) { return zone.updateTabIndexes(); });
    }
}
var FocusZone = /** @class */ (function (_super) {
    tslib_1.__extends(FocusZone, _super);
    function FocusZone(props) {
        var _this = _super.call(this, props) || this;
        _this._root = { current: null };
        /**
         * Flag to define when we've intentionally parked focus on the root element to temporarily
         * hold focus until items appear within the zone.
         */
        _this._isParked = false;
        _this.setRef = function (elem) {
            // findDOMNode needed to get correct DOM ref with react-hot-loader, see https://github.com/gaearon/react-hot-loader/issues/964
            _this._root.current = ReactDOM.findDOMNode(elem);
        };
        _this._onBlur = function () {
            _this.setParkedFocus(false);
        };
        _this._onFocus = function (ev) {
            var _a;
            var _b = _this.props, onActiveElementChanged = _b.onActiveElementChanged, stopFocusPropagation = _b.stopFocusPropagation, shouldFocusInnerElementWhenReceivedFocus = _b.shouldFocusInnerElementWhenReceivedFocus, defaultTabbableElement = _b.defaultTabbableElement, shouldIgnoreNotFocusable = _b.shouldIgnoreNotFocusable;
            if (shouldIgnoreNotFocusable && ((_a = ev.target) === null || _a === void 0 ? void 0 : _a.dataset.isFocusable) === 'false') {
                return;
            }
            var newActiveElement;
            var isImmediateDescendant = _this.isImmediateDescendantOfZone(ev.target);
            if (isImmediateDescendant) {
                newActiveElement = ev.target;
            }
            else {
                var parentElement = ev.target;
                while (parentElement && parentElement !== _this._root.current) {
                    if (focusUtilities_1.isElementTabbable(parentElement) && _this.isImmediateDescendantOfZone(parentElement)) {
                        newActiveElement = parentElement;
                        break;
                    }
                    parentElement = utilities_1.getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);
                }
            }
            // If an inner focusable element should be focused when FocusZone container receives focus
            if (shouldFocusInnerElementWhenReceivedFocus && ev.target === _this._root.current) {
                var maybeElementToFocus = defaultTabbableElement &&
                    typeof defaultTabbableElement === 'function' &&
                    defaultTabbableElement(_this._root.current);
                // try to focus defaultTabbable element
                if (maybeElementToFocus && focusUtilities_1.isElementTabbable(maybeElementToFocus)) {
                    newActiveElement = maybeElementToFocus;
                    maybeElementToFocus.focus();
                }
                else {
                    // force focus on first focusable element
                    _this.focus(true);
                    if (_this._activeElement) {
                        // set to null as new active element was handled in method above
                        newActiveElement = null;
                    }
                }
            }
            if (newActiveElement && newActiveElement !== _this._activeElement) {
                _this._activeElement = newActiveElement;
                if (isImmediateDescendant) {
                    _this.setFocusAlignment(_this._activeElement);
                    _this.updateTabIndexes();
                }
            }
            if (onActiveElementChanged) {
                onActiveElementChanged(_this._activeElement, ev);
            }
            if (stopFocusPropagation) {
                ev.stopPropagation();
            }
            _.invoke(_this.props, 'onFocus', ev);
        };
        _this._onMouseDown = function (ev) {
            var disabled = _this.props.disabled;
            if (disabled) {
                return;
            }
            var target = ev.target;
            var path = [];
            while (target && target !== _this._root.current) {
                path.push(target);
                target = utilities_1.getParent(target, ALLOW_VIRTUAL_ELEMENTS);
            }
            while (path.length) {
                target = path.pop();
                if (target && focusUtilities_1.isElementTabbable(target)) {
                    _this.setActiveElement(target, true);
                }
                if (focusUtilities_1.isElementFocusZone(target)) {
                    // Stop here since the focus zone will take care of its own children.
                    break;
                }
            }
        };
        /**
         * Handle the keystrokes.
         */
        _this._onKeyDown = function (ev) {
            var _a = _this.props, direction = _a.direction, disabled = _a.disabled, shouldEnterInnerZone = _a.shouldEnterInnerZone, pagingSupportDisabled = _a.pagingSupportDisabled;
            if (disabled) {
                return undefined;
            }
            var doc = utilities_1.getDocument(_this._root.current);
            if (_this.props.onKeyDown) {
                _this.props.onKeyDown(ev);
            }
            // @ts-ignore
            if (doc.activeElement === _this._root.current && _this._isInnerZone) {
                // If this element has focus, it is being controlled by a parent.
                // Ignore the keystroke.
                return undefined;
            }
            // If the default has been prevented, do not process keyboard events.
            if (ev.isDefaultPrevented()) {
                return undefined;
            }
            if (shouldEnterInnerZone &&
                shouldEnterInnerZone(ev) &&
                _this.isImmediateDescendantOfZone(ev.target)) {
                // Try to focus
                var innerZone = _this.getFirstInnerZone();
                if (innerZone) {
                    if (!innerZone.focus(true)) {
                        return undefined;
                    }
                }
                else if (focusUtilities_1.isElementFocusSubZone(ev.target)) {
                    if (!_this.focusElement(focusUtilities_1.getNextElement(ev.target, ev.target.firstChild, true))) {
                        return undefined;
                    }
                }
                else {
                    return undefined;
                }
            }
            else if (ev.altKey) {
                return undefined;
            }
            else {
                switch (accessibility_1.getCode(ev)) {
                    case accessibility_1.SpacebarKey:
                        // @ts-ignore
                        if (_this.tryInvokeClickForFocusable(ev.target)) {
                            break;
                        }
                        return undefined;
                    case accessibility_1.keyboardKey.ArrowLeft:
                        if (direction !== accessibility_1.FocusZoneDirection.vertical) {
                            _this.preventDefaultWhenHandled(ev);
                            if (_this.moveFocusLeft()) {
                                break;
                            }
                        }
                        return undefined;
                    case accessibility_1.keyboardKey.ArrowRight:
                        if (direction !== accessibility_1.FocusZoneDirection.vertical) {
                            _this.preventDefaultWhenHandled(ev);
                            if (_this.moveFocusRight()) {
                                break;
                            }
                        }
                        return undefined;
                    case accessibility_1.keyboardKey.ArrowUp:
                        if (direction !== accessibility_1.FocusZoneDirection.horizontal) {
                            _this.preventDefaultWhenHandled(ev);
                            if (_this.moveFocusUp()) {
                                break;
                            }
                        }
                        return undefined;
                    case accessibility_1.keyboardKey.ArrowDown:
                        if (direction !== accessibility_1.FocusZoneDirection.horizontal) {
                            _this.preventDefaultWhenHandled(ev);
                            if (_this.moveFocusDown()) {
                                break;
                            }
                        }
                        return undefined;
                    case accessibility_1.keyboardKey.PageDown:
                        if (!pagingSupportDisabled && _this.moveFocusPaging(true)) {
                            break;
                        }
                        return undefined;
                    case accessibility_1.keyboardKey.PageUp:
                        if (!pagingSupportDisabled && _this.moveFocusPaging(false)) {
                            break;
                        }
                        return undefined;
                    case accessibility_1.keyboardKey.Tab:
                        if (_this.props.handleTabKey === accessibility_1.FocusZoneTabbableElements.all ||
                            (_this.props.handleTabKey === accessibility_1.FocusZoneTabbableElements.inputOnly &&
                                _this.isElementInput(ev.target))) {
                            var focusChanged = false;
                            _this._processingTabKey = true;
                            if (direction === accessibility_1.FocusZoneDirection.vertical ||
                                !_this.shouldWrapFocus(_this._activeElement, NO_HORIZONTAL_WRAP)) {
                                focusChanged = ev.shiftKey ? _this.moveFocusUp() : _this.moveFocusDown();
                            }
                            else {
                                var tabWithDirection = _this.props.isRtl ? !ev.shiftKey : ev.shiftKey;
                                focusChanged = tabWithDirection ? _this.moveFocusLeft() : _this.moveFocusRight();
                            }
                            _this._processingTabKey = false;
                            if (focusChanged) {
                                break;
                            }
                        }
                        else if (_this.props.shouldResetActiveElementWhenTabFromZone) {
                            _this._activeElement = null;
                        }
                        return undefined;
                    case accessibility_1.keyboardKey.Home:
                        if (_this.isContentEditableElement(ev.target) ||
                            (_this.isElementInput(ev.target) &&
                                !_this.shouldInputLoseFocus(ev.target, false))) {
                            return false;
                        }
                        var firstChild = _this._root.current && _this._root.current.firstChild;
                        if (_this._root.current &&
                            firstChild &&
                            _this.focusElement(focusUtilities_1.getNextElement(_this._root.current, firstChild, true))) {
                            break;
                        }
                        return undefined;
                    case accessibility_1.keyboardKey.End:
                        if (_this.isContentEditableElement(ev.target) ||
                            (_this.isElementInput(ev.target) &&
                                !_this.shouldInputLoseFocus(ev.target, false))) {
                            return false;
                        }
                        var lastChild = _this._root.current && _this._root.current.lastChild;
                        if (_this._root.current &&
                            _this.focusElement(focusUtilities_1.getPreviousElement(_this._root.current, lastChild, true, true, true))) {
                            break;
                        }
                        return undefined;
                    case accessibility_1.keyboardKey.Enter:
                        // @ts-ignore
                        if (_this.tryInvokeClickForFocusable(ev.target)) {
                            break;
                        }
                        return undefined;
                    default:
                        return undefined;
                }
            }
            ev.preventDefault();
            ev.stopPropagation();
            return undefined;
        };
        _this.getHorizontalDistanceFromCenter = function (isForward, activeRect, targetRect) {
            var leftAlignment = _this._focusAlignment.left;
            // ClientRect values can be floats that differ by very small fractions of a decimal.
            // If the difference between top and bottom are within a pixel then we should treat
            // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,
            // but without Math.Floor they will be handled incorrectly.
            var targetRectTop = Math.floor(targetRect.top);
            var activeRectBottom = Math.floor(activeRect.bottom);
            var targetRectBottom = Math.floor(targetRect.bottom);
            var activeRectTop = Math.floor(activeRect.top);
            var isValidCandidateOnpagingDown = isForward && targetRectTop > activeRectBottom;
            var isValidCandidateOnpagingUp = !isForward && targetRectBottom < activeRectTop;
            if (isValidCandidateOnpagingDown || isValidCandidateOnpagingUp) {
                if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {
                    return 0;
                }
                return Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);
            }
            if (!_this.shouldWrapFocus(_this._activeElement, NO_VERTICAL_WRAP)) {
                return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
            }
            return LARGE_DISTANCE_FROM_CENTER;
        };
        _this._id = _.uniqueId('FocusZone');
        _this._focusAlignment = {
            left: 0,
            top: 0,
        };
        _this._processingTabKey = false;
        return _this;
    }
    FocusZone.prototype.componentDidMount = function () {
        var _a;
        _allInstances[this._id] = this;
        this.setRef(this); // called here to support functional components, we only need HTMLElement ref anyway
        if (!this._root.current) {
            return;
        }
        // @ts-ignore
        this.windowElement = utilities_1.getWindow(this._root.current);
        var parentElement = utilities_1.getParent(this._root.current, ALLOW_VIRTUAL_ELEMENTS);
        var doc = utilities_1.getDocument(this._root.current);
        // @ts-ignore
        while (parentElement && parentElement !== doc.body && parentElement.nodeType === 1) {
            if (focusUtilities_1.isElementFocusZone(parentElement)) {
                this._isInnerZone = true;
                break;
            }
            parentElement = utilities_1.getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);
        }
        if (!this._isInnerZone && this.windowElement) {
            outerZones.register(this.windowElement, this);
            if (((_a = outerZones.getOutZone(this.windowElement)) === null || _a === void 0 ? void 0 : _a.size) === 1) {
                this.windowElement.addEventListener('keydown', _onKeyDownCapture, true);
            }
        }
        this._root.current.addEventListener('blur', this._onBlur, true);
        // Assign initial tab indexes so that we can set initial focus as appropriate.
        this.updateTabIndexes();
        if (this.props.defaultTabbableElement && typeof this.props.defaultTabbableElement === 'string') {
            this._activeElement = this.getDocument().querySelector(this.props.defaultTabbableElement);
        }
        if (this.props.shouldFocusOnMount) {
            this.focus();
        }
    };
    FocusZone.prototype.componentDidUpdate = function () {
        if (!this._root.current) {
            return;
        }
        var doc = utilities_1.getDocument(this._root.current);
        if (doc &&
            this._lastIndexPath &&
            (doc.activeElement === doc.body ||
                doc.activeElement === null ||
                (!this.props.preventFocusRestoration && doc.activeElement === this._root.current))) {
            // The element has been removed after the render, attempt to restore focus.
            var elementToFocus = focusUtilities_1.getFocusableByIndexPath(this._root.current, this._lastIndexPath);
            if (elementToFocus) {
                this.setActiveElement(elementToFocus, true);
                elementToFocus.focus();
                this.setParkedFocus(false);
            }
            else {
                // We had a focus path to restore, but now that path is unresolvable. Park focus
                // on the container until we can try again.
                this.setParkedFocus(true);
            }
        }
    };
    FocusZone.prototype.componentWillUnmount = function () {
        delete _allInstances[this._id];
        outerZones.unregister(this.windowElement, this);
        if (!this._isInnerZone) {
            if (this.windowElement && !outerZones.getOutZone(this.windowElement)) {
                this.windowElement.removeEventListener('keydown', _onKeyDownCapture, true);
            }
        }
        if (this._root.current) {
            this._root.current.removeEventListener('blur', this._onBlur, true);
        }
        this._activeElement = null;
        this._defaultFocusElement = null;
    };
    FocusZone.prototype.render = function () {
        var className = this.props.className;
        var ElementType = getElementType_1.getElementType(this.props);
        var unhandledProps = getUnhandledProps_1.getUnhandledProps(_.keys(FocusZone.propTypes), this.props);
        // Note, right before rendering/reconciling proceeds, we need to record if focus
        // was in the zone before the update. This helper will track this and, if focus
        // was actually in the zone, what the index path to the element is at this time.
        // Then, later in componentDidUpdate, we can evaluate if we need to restore it in
        // the case the element was removed.
        this.evaluateFocusBeforeRender();
        return (React.createElement(ElementType, tslib_1.__assign({}, unhandledProps, { className: classnames_1.default(FocusZone.className, className), "data-focuszone-id": this._id, onKeyDown: this._onKeyDown, onFocus: this._onFocus, onMouseDownCapture: this._onMouseDown }), this.props.children));
    };
    /**
     * Sets focus to the first tabbable item in the zone.
     * @param forceIntoFirstElement - If true, focus will be forced into the first element, even if focus is already in the focus zone.
     * @returns True if focus could be set to an active element, false if no operation was taken.
     */
    FocusZone.prototype.focus = function (forceIntoFirstElement) {
        if (forceIntoFirstElement === void 0) { forceIntoFirstElement = false; }
        if (this._root.current) {
            if (!forceIntoFirstElement &&
                this._root.current.getAttribute(accessibility_1.IS_FOCUSABLE_ATTRIBUTE) === 'true' &&
                this._isInnerZone) {
                var ownerZoneElement = this.getOwnerZone(this._root.current);
                if (ownerZoneElement !== this._root.current) {
                    var ownerZone = _allInstances[ownerZoneElement.getAttribute(focusUtilities_1.FOCUSZONE_ID_ATTRIBUTE)];
                    return !!ownerZone && ownerZone.focusElement(this._root.current);
                }
                return false;
            }
            if (!forceIntoFirstElement &&
                this._activeElement &&
                utilities_1.elementContains(this._root.current, this._activeElement, ALLOW_VIRTUAL_ELEMENTS) &&
                focusUtilities_1.isElementTabbable(this._activeElement)) {
                this._activeElement.focus();
                return true;
            }
            var firstChild = this._root.current.firstChild;
            return this.focusElement(focusUtilities_1.getNextElement(this._root.current, firstChild, true));
        }
        return false;
    };
    /**
     * Sets focus to the last tabbable item in the zone.
     * @returns True if focus could be set to an active element, false if no operation was taken.
     */
    FocusZone.prototype.focusLast = function () {
        if (this._root.current) {
            var lastChild = this._root.current && this._root.current.lastChild;
            return this.focusElement(focusUtilities_1.getPreviousElement(this._root.current, lastChild, true, true, true));
        }
        return false;
    };
    /**
     * Sets focus to a specific child element within the zone. This can be used in conjunction with
     * shouldReceiveFocus to create delayed focus scenarios (like animate the scroll position to the correct
     * location and then focus.)
     * @param element - The child element within the zone to focus.
     * @param forceAlignment - If true, focus alignment will be set according to the element provided.
     * @returns True if focus could be set to an active element, false if no operation was taken.
     */
    FocusZone.prototype.focusElement = function (element, forceAlignment) {
        var shouldReceiveFocus = this.props.shouldReceiveFocus;
        if (shouldReceiveFocus && !shouldReceiveFocus(element)) {
            return false;
        }
        if (element) {
            this.setActiveElement(element, forceAlignment);
            if (this._activeElement) {
                this._activeElement.focus();
            }
            return true;
        }
        return false;
    };
    // Record if focus was in the zone, what the index path to the element is at this time.
    FocusZone.prototype.evaluateFocusBeforeRender = function () {
        if (!this._root.current) {
            return;
        }
        var doc = utilities_1.getDocument(this._root.current);
        if (!doc) {
            return;
        }
        var focusedElement = doc.activeElement;
        // Only update the index path if we are not parked on the root.
        if (focusedElement !== this._root.current) {
            var shouldRestoreFocus = utilities_1.elementContains(this._root.current, focusedElement, ALLOW_VIRTUAL_ELEMENTS);
            this._lastIndexPath = shouldRestoreFocus
                ? focusUtilities_1.getElementIndexPath(this._root.current, doc.activeElement)
                : undefined;
        }
    };
    /**
     * When focus is in the zone at render time but then all focusable elements are removed,
     * we "park" focus temporarily on the root. Once we update with focusable children, we restore
     * focus to the closest path from previous. If the user tabs away from the parked container,
     * we restore focusability to the pre-parked state.
     */
    FocusZone.prototype.setParkedFocus = function (isParked) {
        if (this._root.current && this._isParked !== isParked) {
            this._isParked = isParked;
            if (isParked) {
                if (!this.props.allowFocusRoot) {
                    this._parkedTabIndex = this._root.current.getAttribute('tabindex');
                    this._root.current.setAttribute('tabindex', '-1');
                }
                this._root.current.focus();
            }
            else if (!this.props.allowFocusRoot) {
                if (this._parkedTabIndex) {
                    this._root.current.setAttribute('tabindex', this._parkedTabIndex);
                    this._parkedTabIndex = undefined;
                }
                else {
                    this._root.current.removeAttribute('tabindex');
                }
            }
        }
    };
    FocusZone.prototype.setActiveElement = function (element, forceAlignment) {
        var previousActiveElement = this._activeElement;
        this._activeElement = element;
        if (previousActiveElement) {
            if (focusUtilities_1.isElementFocusZone(previousActiveElement)) {
                this.updateTabIndexes(previousActiveElement);
            }
            previousActiveElement.tabIndex = -1;
        }
        if (this._activeElement) {
            if (!this._focusAlignment || forceAlignment) {
                this.setFocusAlignment(element, true, true);
            }
            this._activeElement.tabIndex = 0;
        }
    };
    FocusZone.prototype.preventDefaultWhenHandled = function (ev) {
        this.props.preventDefaultWhenHandled && ev.preventDefault();
    };
    /**
     * Walk up the dom try to find a focusable element.
     */
    FocusZone.prototype.tryInvokeClickForFocusable = function (targetElement) {
        var target = targetElement;
        if (target === this._root.current || !this.props.shouldRaiseClicks) {
            return false;
        }
        do {
            if (target.tagName === 'BUTTON' ||
                target.tagName === 'A' ||
                target.tagName === 'INPUT' ||
                target.tagName === 'TEXTAREA') {
                return false;
            }
            if (this.isImmediateDescendantOfZone(target) &&
                target.getAttribute(accessibility_1.IS_FOCUSABLE_ATTRIBUTE) === 'true' &&
                target.getAttribute(accessibility_1.IS_ENTER_DISABLED_ATTRIBUTE) !== 'true') {
                utilities_1.raiseClick(target);
                return true;
            }
            target = utilities_1.getParent(target, ALLOW_VIRTUAL_ELEMENTS);
        } while (target !== this._root.current);
        return false;
    };
    /**
     * Traverse to find first child zone.
     */
    FocusZone.prototype.getFirstInnerZone = function (forRootElement) {
        var rootElement = forRootElement || this._activeElement || this._root.current;
        if (!rootElement) {
            return null;
        }
        if (focusUtilities_1.isElementFocusZone(rootElement)) {
            return _allInstances[rootElement.getAttribute(focusUtilities_1.FOCUSZONE_ID_ATTRIBUTE)];
        }
        var child = rootElement.firstElementChild;
        while (child) {
            if (focusUtilities_1.isElementFocusZone(child)) {
                return _allInstances[child.getAttribute(focusUtilities_1.FOCUSZONE_ID_ATTRIBUTE)];
            }
            var match = this.getFirstInnerZone(child);
            if (match) {
                return match;
            }
            child = child.nextElementSibling;
        }
        return null;
    };
    FocusZone.prototype.moveFocus = function (isForward, getDistanceFromCenter, 
    // @ts-ignore
    ev, useDefaultWrap) {
        if (useDefaultWrap === void 0) { useDefaultWrap = true; }
        var element = this._activeElement;
        var candidateDistance = -1;
        var candidateElement = undefined;
        var changedFocus = false;
        var isBidirectional = this.props.direction === accessibility_1.FocusZoneDirection.bidirectional;
        if (!element || !this._root.current) {
            return false;
        }
        if (this.isElementInput(element)) {
            if (!this.shouldInputLoseFocus(element, isForward)) {
                return false;
            }
        }
        var activeRect = isBidirectional ? element.getBoundingClientRect() : null;
        do {
            element = (isForward
                ? focusUtilities_1.getNextElement(this._root.current, element)
                : focusUtilities_1.getPreviousElement(this._root.current, element));
            if (isBidirectional) {
                if (element) {
                    var targetRect = element.getBoundingClientRect();
                    var elementDistance = getDistanceFromCenter(activeRect, targetRect);
                    if (elementDistance === -1 && candidateDistance === -1) {
                        candidateElement = element;
                        break;
                    }
                    if (elementDistance > -1 && (candidateDistance === -1 || elementDistance < candidateDistance)) {
                        candidateDistance = elementDistance;
                        candidateElement = element;
                    }
                    if (candidateDistance >= 0 && elementDistance < 0) {
                        break;
                    }
                }
            }
            else {
                candidateElement = element;
                break;
            }
        } while (element);
        // Focus the closest candidate
        if (candidateElement && candidateElement !== this._activeElement) {
            changedFocus = true;
            this.focusElement(candidateElement);
        }
        else if (this.props.isCircularNavigation && useDefaultWrap) {
            if (isForward) {
                return this.focusElement(focusUtilities_1.getNextElement(this._root.current, this._root.current.firstElementChild, true));
            }
            return this.focusElement(focusUtilities_1.getPreviousElement(this._root.current, this._root.current.lastElementChild, true, true, true));
        }
        return changedFocus;
    };
    FocusZone.prototype.moveFocusDown = function () {
        var _this = this;
        var targetTop = -1;
        var leftAlignment = this._focusAlignment.left;
        if (this.moveFocus(true, function (activeRect, targetRect) {
            var distance = -1;
            // ClientRect values can be floats that differ by very small fractions of a decimal.
            // If the difference between top and bottom are within a pixel then we should treat
            // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,
            // but without Math.Floor they will be handled incorrectly.
            var targetRectTop = Math.floor(targetRect.top);
            var activeRectBottom = Math.floor(activeRect.bottom);
            if (targetRectTop < activeRectBottom) {
                if (!_this.shouldWrapFocus(_this._activeElement, NO_VERTICAL_WRAP)) {
                    return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
                }
                return LARGE_DISTANCE_FROM_CENTER;
            }
            if ((targetTop === -1 && targetRectTop >= activeRectBottom) || targetRectTop === targetTop) {
                targetTop = targetRectTop;
                if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {
                    distance = 0;
                }
                else {
                    distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);
                }
            }
            return distance;
        })) {
            this.setFocusAlignment(this._activeElement, true, true);
            return true;
        }
        return false;
    };
    FocusZone.prototype.moveFocusUp = function () {
        var _this = this;
        var targetTop = -1;
        var leftAlignment = this._focusAlignment.left;
        if (this.moveFocus(false, function (activeRect, targetRect) {
            var distance = -1;
            // ClientRect values can be floats that differ by very small fractions of a decimal.
            // If the difference between top and bottom are within a pixel then we should treat
            // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,
            // but without Math.Floor they will be handled incorrectly.
            var targetRectBottom = Math.floor(targetRect.bottom);
            var targetRectTop = Math.floor(targetRect.top);
            var activeRectTop = Math.floor(activeRect.top);
            if (targetRectBottom > activeRectTop) {
                if (!_this.shouldWrapFocus(_this._activeElement, NO_VERTICAL_WRAP)) {
                    return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
                }
                return LARGE_DISTANCE_FROM_CENTER;
            }
            if ((targetTop === -1 && targetRectBottom <= activeRectTop) || targetRectTop === targetTop) {
                targetTop = targetRectTop;
                if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {
                    distance = 0;
                }
                else {
                    distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);
                }
            }
            return distance;
        })) {
            this.setFocusAlignment(this._activeElement, true, true);
            return true;
        }
        return false;
    };
    FocusZone.prototype.moveFocusLeft = function () {
        var _this = this;
        var shouldWrap = this.shouldWrapFocus(this._activeElement, NO_HORIZONTAL_WRAP);
        if (this.moveFocus(
        // @ts-ignore
        this.props.isRtl, function (activeRect, targetRect) {
            var distance = -1;
            var topBottomComparison;
            if (_this.props.isRtl) {
                // When in RTL, this comparison should be the same as the one in moveFocusRight for LTR.
                // Going left at a leftmost rectangle will go down a line instead of up a line like in LTR.
                // This is important, because we want to be comparing the top of the target rect
                // with the bottom of the active rect.
                topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));
            }
            else {
                topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));
            }
            if (topBottomComparison &&
                targetRect.right <= activeRect.right &&
                _this.props.direction !== accessibility_1.FocusZoneDirection.vertical) {
                distance = activeRect.right - targetRect.right;
            }
            else if (!shouldWrap) {
                distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
            }
            return distance;
        }, undefined /* ev */, shouldWrap)) {
            this.setFocusAlignment(this._activeElement, true, false);
            return true;
        }
        return false;
    };
    FocusZone.prototype.moveFocusRight = function () {
        var _this = this;
        var shouldWrap = this.shouldWrapFocus(this._activeElement, NO_HORIZONTAL_WRAP);
        if (this.moveFocus(!this.props.isRtl, function (activeRect, targetRect) {
            var distance = -1;
            var topBottomComparison;
            if (_this.props.isRtl) {
                // When in RTL, this comparison should be the same as the one in moveFocusLeft for LTR.
                // Going right at a rightmost rectangle will go up a line instead of down a line like in LTR.
                // This is important, because we want to be comparing the bottom of the target rect
                // with the top of the active rect.
                topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));
            }
            else {
                topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));
            }
            if (topBottomComparison &&
                targetRect.left >= activeRect.left &&
                _this.props.direction !== accessibility_1.FocusZoneDirection.vertical) {
                distance = targetRect.left - activeRect.left;
            }
            else if (!shouldWrap) {
                distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
            }
            return distance;
        }, undefined /* ev */, shouldWrap)) {
            this.setFocusAlignment(this._activeElement, true, false);
            return true;
        }
        return false;
    };
    FocusZone.prototype.moveFocusPaging = function (isForward, useDefaultWrap) {
        if (useDefaultWrap === void 0) { useDefaultWrap = true; }
        var element = this._activeElement;
        if (!element || !this._root.current) {
            return false;
        }
        if (this.isElementInput(element)) {
            if (!this.shouldInputLoseFocus(element, isForward)) {
                return false;
            }
        }
        var scrollableParent = utilities_1.findScrollableParent(element);
        if (!scrollableParent) {
            return false;
        }
        var candidateDistance = -1;
        var candidateElement = undefined;
        var targetTop = -1;
        var targetBottom = -1;
        var pagesize = scrollableParent.clientHeight;
        var activeRect = element.getBoundingClientRect();
        do {
            element = isForward
                ? focusUtilities_1.getNextElement(this._root.current, element)
                : focusUtilities_1.getPreviousElement(this._root.current, element);
            if (element) {
                var targetRect = element.getBoundingClientRect();
                var targetRectTop = Math.floor(targetRect.top);
                var activeRectBottom = Math.floor(activeRect.bottom);
                var targetRectBottom = Math.floor(targetRect.bottom);
                var activeRectTop = Math.floor(activeRect.top);
                var elementDistance = this.getHorizontalDistanceFromCenter(isForward, activeRect, targetRect);
                var isElementPassedPageSizeOnPagingDown = isForward && targetRectTop > activeRectBottom + pagesize;
                var isElementPassedPageSizeOnPagingUp = !isForward && targetRectBottom < activeRectTop - pagesize;
                if (isElementPassedPageSizeOnPagingDown || isElementPassedPageSizeOnPagingUp) {
                    break;
                }
                if (elementDistance > -1) {
                    // for paging down
                    if (isForward && targetRectTop > targetTop) {
                        targetTop = targetRectTop;
                        candidateDistance = elementDistance;
                        candidateElement = element;
                    }
                    else if (!isForward && targetRectBottom < targetBottom) {
                        // for paging up
                        targetBottom = targetRectBottom;
                        candidateDistance = elementDistance;
                        candidateElement = element;
                    }
                    else if (candidateDistance === -1 || elementDistance <= candidateDistance) {
                        candidateDistance = elementDistance;
                        candidateElement = element;
                    }
                }
            }
        } while (element);
        var changedFocus = false;
        // Focus the closest candidate
        if (candidateElement && candidateElement !== this._activeElement) {
            changedFocus = true;
            this.focusElement(candidateElement);
            this.setFocusAlignment(candidateElement, false, true);
        }
        else if (this.props.isCircularNavigation && useDefaultWrap) {
            if (isForward) {
                return this.focusElement(focusUtilities_1.getNextElement(this._root.current, this._root.current.firstElementChild, true));
            }
            return this.focusElement(focusUtilities_1.getPreviousElement(this._root.current, this._root.current.lastElementChild, true, true, true));
        }
        return changedFocus;
    };
    FocusZone.prototype.setFocusAlignment = function (element, isHorizontal, isVertical) {
        if (this.props.direction === accessibility_1.FocusZoneDirection.bidirectional &&
            (!this._focusAlignment || isHorizontal || isVertical)) {
            var rect = element.getBoundingClientRect();
            var left = rect.left + rect.width / 2;
            var top_1 = rect.top + rect.height / 2;
            if (!this._focusAlignment) {
                this._focusAlignment = { left: left, top: top_1 };
            }
            if (isHorizontal) {
                this._focusAlignment.left = left;
            }
            if (isVertical) {
                this._focusAlignment.top = top_1;
            }
        }
    };
    FocusZone.prototype.isImmediateDescendantOfZone = function (element) {
        return this.getOwnerZone(element) === this._root.current;
    };
    FocusZone.prototype.getOwnerZone = function (element) {
        var doc = utilities_1.getDocument(this._root.current);
        var parentElement = utilities_1.getParent(element, ALLOW_VIRTUAL_ELEMENTS);
        // @ts-ignore
        while (parentElement && parentElement !== this._root.current && parentElement !== doc.body) {
            if (focusUtilities_1.isElementFocusZone(parentElement)) {
                return parentElement;
            }
            parentElement = utilities_1.getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);
        }
        return this._root.current;
    };
    FocusZone.prototype.updateTabIndexes = function (onElement) {
        var element = onElement;
        if (!this._activeElement &&
            this.props.defaultTabbableElement &&
            typeof this.props.defaultTabbableElement === 'function') {
            this._activeElement = this.props.defaultTabbableElement(this._root.current);
        }
        if (!element && this._root.current) {
            this._defaultFocusElement = null;
            element = this._root.current;
            if (this._activeElement && !utilities_1.elementContains(element, this._activeElement, ALLOW_VIRTUAL_ELEMENTS)) {
                this._activeElement = null;
            }
        }
        // If active element changes state to disabled, set it to null.
        // Otherwise, we lose keyboard accessibility to other elements in focus zone.
        if (this._activeElement && !focusUtilities_1.isElementTabbable(this._activeElement)) {
            this._activeElement = null;
        }
        var childNodes = element && element.children;
        for (var childIndex = 0; childNodes && childIndex < childNodes.length; childIndex++) {
            var child = childNodes[childIndex];
            if (!focusUtilities_1.isElementFocusZone(child)) {
                // If the item is explicitly set to not be focusable then TABINDEX needs to be set to -1.
                if (child.getAttribute && child.getAttribute(accessibility_1.IS_FOCUSABLE_ATTRIBUTE) === 'false') {
                    child.setAttribute(TABINDEX, '-1');
                }
                if (focusUtilities_1.isElementTabbable(child)) {
                    if (this.props.disabled) {
                        child.setAttribute(TABINDEX, '-1');
                    }
                    else if (!this._isInnerZone &&
                        ((!this._activeElement && !this._defaultFocusElement) || this._activeElement === child)) {
                        this._defaultFocusElement = child;
                        if (child.getAttribute(TABINDEX) !== '0') {
                            child.setAttribute(TABINDEX, '0');
                        }
                    }
                    else if (child.getAttribute(TABINDEX) !== '-1') {
                        child.setAttribute(TABINDEX, '-1');
                    }
                }
                else if (child.tagName === 'svg' && child.getAttribute('focusable') !== 'false') {
                    // Disgusting IE hack. Sad face.
                    child.setAttribute('focusable', 'false');
                }
            }
            else if (child.getAttribute(accessibility_1.IS_FOCUSABLE_ATTRIBUTE) === 'true') {
                if (!this._isInnerZone &&
                    ((!this._activeElement && !this._defaultFocusElement) || this._activeElement === child)) {
                    this._defaultFocusElement = child;
                    if (child.getAttribute(TABINDEX) !== '0') {
                        child.setAttribute(TABINDEX, '0');
                    }
                }
                else if (child.getAttribute(TABINDEX) !== '-1') {
                    child.setAttribute(TABINDEX, '-1');
                }
            }
            this.updateTabIndexes(child);
        }
    };
    FocusZone.prototype.isContentEditableElement = function (element) {
        return element && element.getAttribute('contenteditable') === 'true';
    };
    FocusZone.prototype.isElementInput = function (element) {
        if (element &&
            element.tagName &&
            (element.tagName.toLowerCase() === 'input' || element.tagName.toLowerCase() === 'textarea')) {
            return true;
        }
        return false;
    };
    FocusZone.prototype.shouldInputLoseFocus = function (element, isForward) {
        // If a tab was used, we want to focus on the next element.
        if (!this._processingTabKey &&
            element &&
            element.type &&
            ALLOWED_INPUT_TYPES.indexOf(element.type.toLowerCase()) > -1) {
            var selectionStart = element.selectionStart;
            var selectionEnd = element.selectionEnd;
            var isRangeSelected = selectionStart !== selectionEnd;
            var inputValue = element.value;
            var isReadonly = element.readOnly;
            // We shouldn't lose focus in the following cases:
            // 1. There is range selected.
            // 2. When selection start is larger than 0 and it is backward and not readOnly.
            // 3. when selection start is not the end of length and it is forward and not readOnly.
            // 4. We press any of the arrow keys when our handleTabKey isn't none or undefined (only losing focus if we hit tab)
            // and if shouldInputLoseFocusOnArrowKey is defined, if scenario prefers to not loose the focus which is determined by calling the
            // callback shouldInputLoseFocusOnArrowKey
            if (isRangeSelected ||
                (selectionStart > 0 && !isForward && !isReadonly) ||
                (selectionStart !== inputValue.length && isForward && !isReadonly) ||
                (!!this.props.handleTabKey &&
                    !(this.props.shouldInputLoseFocusOnArrowKey && this.props.shouldInputLoseFocusOnArrowKey(element)))) {
                return false;
            }
        }
        return true;
    };
    FocusZone.prototype.shouldWrapFocus = function (element, noWrapDataAttribute) {
        return !!this.props.checkForNoWrap ? utilities_1.shouldWrapFocus(element, noWrapDataAttribute) : true;
    };
    FocusZone.prototype.getDocument = function () {
        return utilities_1.getDocument(this._root.current);
    };
    FocusZone.propTypes = {
        className: PropTypes.string,
        direction: PropTypes.number,
        defaultTabbableElement: PropTypes.func,
        shouldFocusOnMount: PropTypes.bool,
        shouldResetActiveElementWhenTabFromZone: PropTypes.bool,
        shouldRaiseClicks: PropTypes.bool,
        shouldFocusInnerElementWhenReceivedFocus: PropTypes.bool,
        disabled: PropTypes.bool,
        as: PropTypes.elementType,
        isCircularNavigation: PropTypes.bool,
        shouldEnterInnerZone: PropTypes.func,
        onActiveElementChanged: PropTypes.func,
        shouldReceiveFocus: PropTypes.func,
        handleTabKey: PropTypes.number,
        shouldInputLoseFocusOnArrowKey: PropTypes.func,
        stopFocusPropagation: PropTypes.bool,
        onFocus: PropTypes.func,
        preventDefaultWhenHandled: PropTypes.bool,
        isRtl: PropTypes.bool,
        preventFocusRestoration: PropTypes.bool,
        pagingSupportDisabled: PropTypes.bool,
        shouldIgnoreNotFocusable: PropTypes.bool,
    };
    FocusZone.defaultProps = {
        isCircularNavigation: false,
        direction: accessibility_1.FocusZoneDirection.bidirectional,
        as: 'div',
        preventDefaultWhenHandled: true,
        shouldRaiseClicks: false,
    };
    FocusZone.displayName = 'FocusZone';
    FocusZone.className = 'ms-FocusZone';
    FocusZone.outerZones = outerZones;
    return FocusZone;
}(React.Component));
exports.FocusZone = FocusZone;
