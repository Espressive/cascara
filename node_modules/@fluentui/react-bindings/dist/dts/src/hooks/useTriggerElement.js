"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useTriggerElement = void 0;
var tslib_1 = require("tslib");
var react_component_ref_1 = require("@fluentui/react-component-ref");
var React = require("react");
var ReactIs = require("react-is");
var childrenExist_1 = require("../utils/childrenExist");
// https://github.com/facebook/react/blob/c4e0768d7487a9359b74986e3b07841d2520f593/packages/react-dom/src/events/getListener.js#L15-L22
function isDisabledInteractive(node) {
    return ((node.nodeName === 'BUTTON' ||
        node.nodeName === 'INPUT' ||
        node.nodeName === 'SELECT' ||
        node.nodeName === 'TEXTAREA') &&
        node.disabled);
}
function isInteractiveFilter(node) {
    return isDisabledInteractive(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
}
/**
 * Performs consistent checks for components that are using `trigger` pattern (`Tooltip`, `Popup`). Ensures that
 * `children` or `trigger` props will always pass a valid React element to what additional props and handlers can
 * be applied.
 */
function useTriggerElement(props) {
    var trigger = childrenExist_1.childrenExist(props.children) ? props.children : props.trigger;
    var element = trigger ? React.Children.only(trigger) : null;
    // An exception should not be thrown in tests as components might be rendered without styles
    if (process.env.NODE_ENV !== 'production' && process.env.NODE_ENV !== 'test') {
        if (ReactIs.isFragment(element)) {
            throw new Error('useTriggerElement(): A "React.Fragment" cannot be used as a "trigger" as it will be impossible to spread props on it');
        }
        // Hooks are used only for dev mode validations and will be removed in production builds
        /* eslint-disable react-hooks/rules-of-hooks */
        var ref_1 = React.useRef();
        React.useEffect(function () {
            var _a, _b, _c;
            if (ref_1.current) {
                if (isDisabledInteractive(ref_1.current)) {
                    // eslint-disable-next-line no-console
                    console.warn([
                        'useTriggerElement(): Disabled elements should used as a "trigger" accurately as it may lead to ',
                        'unexpected behavior as pointer events are ignored on disabled elements. Please wrap your "trigger" with',
                        'an additional element like a "div" if you need to show tooltips or popups on disabled elements, an',
                        'example is available in docs:',
                        'https://fluentsite.z22.web.core.windows.net/components/tooltip/definition#usage-disabled-trigger',
                    ].join(' '));
                }
                var treeWalker = (_a = ref_1.current.ownerDocument) === null || _a === void 0 ? void 0 : _a.createTreeWalker(ref_1.current, NodeFilter.SHOW_ELEMENT, {
                    acceptNode: isInteractiveFilter,
                });
                while (treeWalker === null || treeWalker === void 0 ? void 0 : treeWalker.nextNode()) {
                    var node = treeWalker.currentNode;
                    var nodeStyles = (_c = (_b = node.ownerDocument) === null || _b === void 0 ? void 0 : _b.defaultView) === null || _c === void 0 ? void 0 : _c.getComputedStyle(node);
                    if ((nodeStyles === null || nodeStyles === void 0 ? void 0 : nodeStyles.pointerEvents) !== 'none') {
                        throw new Error([
                            'useTriggerElement(): A disabled element should have explicit "pointer-events: "none" in its styles',
                            'due a bug in Chrome that breaks "onMouseLeave" event in React:',
                            'https://github.com/facebook/react/issues/19692',
                        ].join(' '));
                    }
                }
            }
        }, []);
        return element ? (
        /* Required as components may call handlers via `trigger.props`, Ref will pass unhandled props down */
        React.createElement(react_component_ref_1.Ref, tslib_1.__assign({}, element.props, { innerRef: ref_1 }), element)) : null;
    }
    return element;
}
exports.useTriggerElement = useTriggerElement;
