"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useAccessibility = void 0;
var tslib_1 = require("tslib");
var React = require("react");
var getAccessibility_1 = require("../accessibility/getAccessibility");
var FocusZone_1 = require("../FocusZone/FocusZone");
var useIsomorphicLayoutEffect_1 = require("./useIsomorphicLayoutEffect");
var useAccessibility = function (behavior, options) {
    if (options === void 0) { options = {}; }
    var actionHandlers = options.actionHandlers, _a = options.debugName, debugName = _a === void 0 ? 'Undefined' : _a, _b = options.mapPropsToBehavior, mapPropsToBehavior = _b === void 0 ? function () { return ({}); } : _b, _c = options.rtl, rtl = _c === void 0 ? false : _c;
    var definition = getAccessibility_1.getAccessibility(debugName, behavior, mapPropsToBehavior(), rtl, actionHandlers);
    var latestDefinition = React.useRef();
    var slotHandlers = React.useRef({});
    var slotProps = React.useRef({});
    useIsomorphicLayoutEffect_1.useIsomorphicLayoutEffect(function () {
        latestDefinition.current = definition;
    });
    var getA11yProps = function (slotName, userProps) {
        var hasKeyDownHandlers = Boolean(definition.keyHandlers[slotName] || userProps.onKeyDown);
        var childBehavior = definition.childBehaviors ? definition.childBehaviors[slotName] : undefined;
        slotProps.current[slotName] = userProps;
        // We want to avoid adding event handlers until it's really needed
        if (hasKeyDownHandlers) {
            if (!slotHandlers.current[slotName]) {
                slotHandlers.current[slotName] = function (e) {
                    var _a, _b;
                    var args = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        args[_i - 1] = arguments[_i];
                    }
                    var accessibilityHandler = (_b = (_a = latestDefinition.current) === null || _a === void 0 ? void 0 : _a.keyHandlers[slotName]) === null || _b === void 0 ? void 0 : _b.onKeyDown;
                    var userHandler = slotProps.current[slotName].onKeyDown;
                    if (accessibilityHandler)
                        accessibilityHandler(e);
                    if (userHandler)
                        userHandler.apply(void 0, tslib_1.__spreadArrays([e], args));
                };
            }
        }
        else {
            delete slotHandlers.current[slotName];
        }
        var finalProps = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, (childBehavior && { accessibility: childBehavior })), definition.attributes[slotName]), userProps), { onKeyDown: slotHandlers.current[slotName] });
        return finalProps;
    };
    // Provides an experimental handling for FocusZone definition in behaviors
    getA11yProps.unstable_wrapWithFocusZone = function (element) {
        if (definition.focusZone) {
            var child = element;
            if (process.env.NODE_ENV !== 'production') {
                child = React.Children.only(element);
            }
            return React.createElement(FocusZone_1.FocusZone, tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, definition.focusZone.props), child.props), { as: child.type, isRtl: rtl }));
        }
        return element;
    };
    getA11yProps.unstable_behaviorDefinition = function () { return definition; };
    return getA11yProps;
};
exports.useAccessibility = useAccessibility;
