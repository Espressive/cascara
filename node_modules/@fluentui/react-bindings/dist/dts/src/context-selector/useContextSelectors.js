"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useContextSelectors = void 0;
var tslib_1 = require("tslib");
var React = require("react");
var utils_1 = require("./utils");
/**
 * This hook returns context selected value by selectors.
 * It will only accept context created by `createContext`.
 * It will trigger re-render if only the selected value is referencially changed.
 */
var useContextSelectors = function (context, selectors) {
    var contextValue = React.useContext(context);
    var value = contextValue.value.current, version = contextValue.version.current, listeners = contextValue.listeners;
    var selected = {};
    Object.keys(selectors).forEach(function (key) {
        selected[key] = selectors[key](value);
    });
    var _a = React.useReducer(function (prevState, payload) {
        if (!payload) {
            // early bail out when is dispatched during render
            return [value, selected];
        }
        if (payload[0] <= version) {
            var stateHasNotChanged = Object.keys(selectors).every(function (key) {
                return Object.is(prevState[1][key], selected[key]);
            });
            if (stateHasNotChanged) {
                return prevState; // bail out
            }
            return [value, selected];
        }
        try {
            var statePayloadHasChanged = Object.keys(prevState[0]).some(function (key) {
                return !Object.is(prevState[0] /* previous contextValue */[key], payload[1] /* current contextValue */[key]);
            });
            if (!statePayloadHasChanged) {
                return prevState;
            }
            var nextSelected_1 = {};
            Object.keys(selectors).forEach(function (key) {
                nextSelected_1[key] = selectors[key](payload[1]);
            });
            var selectedHasNotChanged = Object.keys(selectors).every(function (key) {
                return Object.is(prevState[1][key] /* previous { [key]: selector(value) } */, nextSelected_1[key]);
            });
            if (selectedHasNotChanged) {
                return prevState;
            }
            return [payload[1], nextSelected_1];
        }
        catch (e) {
            // ignored (stale props or some other reason)
        }
        return tslib_1.__spreadArrays(prevState); // schedule update
    }, [value, selected]), state = _a[0], dispatch = _a[1];
    // schedule re-render when selected context is updated
    var hasSelectedValuesUpdates = Object.keys(selectors).find(function (key) { return !Object.is(state[1] /* previous { [key]: selector(value) } */[key], selected[key]); });
    if (hasSelectedValuesUpdates !== undefined) {
        dispatch(undefined);
    }
    utils_1.useIsomorphicLayoutEffect(function () {
        listeners.push(dispatch);
        return function () {
            var index = listeners.indexOf(dispatch);
            listeners.splice(index, 1);
        };
    }, [listeners]);
    return state[1];
};
exports.useContextSelectors = useContextSelectors;
