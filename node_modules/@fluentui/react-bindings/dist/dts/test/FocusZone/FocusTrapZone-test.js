"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var accessibility_1 = require("@fluentui/accessibility");
var react_bindings_1 = require("@fluentui/react-bindings");
var React = require("react");
var ReactTestUtils = require("react-dom/test-utils");
// rAF does not exist in node - let's mock it
window.requestAnimationFrame = function (callback) {
    var r = window.setTimeout(callback, 0);
    jest.runAllTimers();
    return r;
};
jest.useFakeTimers();
var FocusTrapZoneTestComponent = /** @class */ (function (_super) {
    tslib_1.__extends(FocusTrapZoneTestComponent, _super);
    function FocusTrapZoneTestComponent(props) {
        var _this = _super.call(this, props) || this;
        _this._toggleFirst = function () { return _this.setState({ isShowingFirst: !_this.state.isShowingFirst }); };
        _this._toggleSecond = function () { return _this.setState({ isShowingSecond: !_this.state.isShowingSecond }); };
        _this.state = { isShowingFirst: true, isShowingSecond: false };
        return _this;
    }
    FocusTrapZoneTestComponent.prototype.render = function () {
        return (React.createElement("div", null,
            React.createElement(react_bindings_1.FocusTrapZone, { forceFocusInsideTrapOnOutsideFocus: true, isClickableOutsideFocusTrap: false },
                React.createElement("button", { className: 'a', onClick: this._toggleFirst }, "a"),
                React.createElement("button", { className: 'b', onClick: this._toggleSecond }, "b")),
            this.state.isShowingFirst && (React.createElement(react_bindings_1.FocusTrapZone, { forceFocusInsideTrapOnOutsideFocus: false, isClickableOutsideFocusTrap: false },
                React.createElement(react_bindings_1.FocusZone, { "data-is-visible": true }, "First"))),
            this.state.isShowingSecond && (React.createElement(react_bindings_1.FocusTrapZone, { forceFocusInsideTrapOnOutsideFocus: false, isClickableOutsideFocusTrap: true },
                React.createElement(react_bindings_1.FocusZone, { "data-is-visible": true }, "First")))));
    };
    return FocusTrapZoneTestComponent;
}(React.Component));
describe('FocusTrapZone', function () {
    // document.activeElement can be used to detect activeElement after component mount, but it does not
    // update based on focus events due to limitations of ReactDOM. Use lastFocusedElement to detect focus
    // change events.
    var lastFocusedElement;
    var ftzClassname = 'ftzTestClassname';
    var _onFocus = function (ev) { return (lastFocusedElement = ev.target); };
    var setupElement = function (element, _a) {
        var clientRect = _a.clientRect, _b = _a.isVisible, isVisible = _b === void 0 ? true : _b;
        // @ts-ignore
        element.getBoundingClientRect = function () { return ({
            top: clientRect.top,
            left: clientRect.left,
            bottom: clientRect.bottom,
            right: clientRect.right,
            width: clientRect.right - clientRect.left,
            height: clientRect.bottom - clientRect.top,
        }); };
        element.setAttribute('data-is-visible', String(isVisible));
        element.focus = function () { return ReactTestUtils.Simulate.focus(element); };
    };
    /**
     * Helper to get FocusTrapZone bumpers. Requires classname attribute of
     * 'ftzClassname' on FTZ.
     */
    function getFtzBumpers(element) {
        var ftz = element.querySelector("." + ftzClassname);
        var ftzNodes = ftz.children;
        var firstBumper = ftzNodes[0];
        var lastBumper = ftzNodes[ftzNodes.length - 1];
        return { firstBumper: firstBumper, lastBumper: lastBumper };
    }
    beforeEach(function () {
        lastFocusedElement = undefined;
    });
    describe('Tab and shift-tab wrap at extreme ends of the FTZ', function () {
        it('can tab across FocusZones with different button structures', function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
            var topLevelDiv, buttonA, buttonB, buttonC, buttonD, buttonE, buttonF, _a, firstBumper, lastBumper;
            return tslib_1.__generator(this, function (_b) {
                expect.assertions(3);
                topLevelDiv = ReactTestUtils.renderIntoDocument(React.createElement("div", { onFocusCapture: _onFocus },
                    React.createElement(react_bindings_1.FocusTrapZone, { forceFocusInsideTrapOnOutsideFocus: false, className: ftzClassname },
                        React.createElement(react_bindings_1.FocusZone, { direction: accessibility_1.FocusZoneDirection.horizontal, "data-is-visible": true },
                            React.createElement("div", { "data-is-visible": true },
                                React.createElement("button", { className: "a" }, "a")),
                            React.createElement("div", { "data-is-visible": true },
                                React.createElement("button", { className: "b" }, "b")),
                            React.createElement("div", { "data-is-visible": true },
                                React.createElement("button", { className: "c" }, "c"))),
                        React.createElement(react_bindings_1.FocusZone, { direction: accessibility_1.FocusZoneDirection.horizontal, "data-is-visible": true },
                            React.createElement("div", { "data-is-visible": true },
                                React.createElement("div", { "data-is-visible": true },
                                    React.createElement("button", { className: "d" }, "d"),
                                    React.createElement("button", { className: "e" }, "e"),
                                    React.createElement("button", { className: "f" }, "f")))))));
                buttonA = topLevelDiv.querySelector('.a');
                buttonB = topLevelDiv.querySelector('.b');
                buttonC = topLevelDiv.querySelector('.c');
                buttonD = topLevelDiv.querySelector('.d');
                buttonE = topLevelDiv.querySelector('.e');
                buttonF = topLevelDiv.querySelector('.f');
                // Assign bounding locations to buttons.
                setupElement(buttonA, { clientRect: { top: 0, bottom: 30, left: 0, right: 30 } });
                setupElement(buttonB, { clientRect: { top: 0, bottom: 30, left: 30, right: 60 } });
                setupElement(buttonC, { clientRect: { top: 0, bottom: 30, left: 60, right: 90 } });
                setupElement(buttonD, { clientRect: { top: 30, bottom: 60, left: 0, right: 30 } });
                setupElement(buttonE, { clientRect: { top: 30, bottom: 60, left: 30, right: 60 } });
                setupElement(buttonF, { clientRect: { top: 30, bottom: 60, left: 60, right: 90 } });
                _a = getFtzBumpers(topLevelDiv), firstBumper = _a.firstBumper, lastBumper = _a.lastBumper;
                ReactTestUtils.Simulate.focus(buttonA);
                expect(lastFocusedElement).toBe(buttonA);
                // Simulate shift+tab event which would focus first bumper
                ReactTestUtils.Simulate.focus(firstBumper);
                expect(lastFocusedElement).toBe(buttonD);
                // Simulate tab event which would focus last bumper
                ReactTestUtils.Simulate.focus(lastBumper);
                expect(lastFocusedElement).toBe(buttonA);
                return [2 /*return*/];
            });
        }); });
        it('can tab across a FocusZone with different button structures', function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
            var topLevelDiv, buttonX, buttonA, buttonB, buttonC, buttonD, _a, firstBumper, lastBumper;
            return tslib_1.__generator(this, function (_b) {
                expect.assertions(3);
                topLevelDiv = ReactTestUtils.renderIntoDocument(React.createElement("div", { onFocusCapture: _onFocus },
                    React.createElement(react_bindings_1.FocusTrapZone, { forceFocusInsideTrapOnOutsideFocus: false, className: ftzClassname },
                        React.createElement("div", { "data-is-visible": true },
                            React.createElement("button", { className: "x" }, "x")),
                        React.createElement(react_bindings_1.FocusZone, { direction: accessibility_1.FocusZoneDirection.horizontal, "data-is-visible": true },
                            React.createElement("div", { "data-is-visible": true },
                                React.createElement("button", { className: "a" }, "a")),
                            React.createElement("div", { "data-is-visible": true },
                                React.createElement("div", { "data-is-visible": true },
                                    React.createElement("button", { className: "b" }, "b"),
                                    React.createElement("button", { className: "c" }, "c"),
                                    React.createElement("button", { className: "d" }, "d")))))));
                buttonX = topLevelDiv.querySelector('.x');
                buttonA = topLevelDiv.querySelector('.a');
                buttonB = topLevelDiv.querySelector('.b');
                buttonC = topLevelDiv.querySelector('.c');
                buttonD = topLevelDiv.querySelector('.d');
                _a = getFtzBumpers(topLevelDiv), firstBumper = _a.firstBumper, lastBumper = _a.lastBumper;
                // Assign bounding locations to buttons.
                setupElement(buttonX, { clientRect: { top: 0, bottom: 30, left: 0, right: 30 } });
                setupElement(buttonA, { clientRect: { top: 0, bottom: 30, left: 0, right: 30 } });
                setupElement(buttonB, { clientRect: { top: 0, bottom: 30, left: 30, right: 60 } });
                setupElement(buttonC, { clientRect: { top: 0, bottom: 30, left: 60, right: 90 } });
                setupElement(buttonD, { clientRect: { top: 30, bottom: 60, left: 0, right: 30 } });
                ReactTestUtils.Simulate.focus(buttonX);
                expect(lastFocusedElement).toBe(buttonX);
                // Simulate shift+tab event which would focus first bumper
                ReactTestUtils.Simulate.focus(firstBumper);
                expect(lastFocusedElement).toBe(buttonA);
                // Simulate tab event which would focus last bumper
                ReactTestUtils.Simulate.focus(lastBumper);
                expect(lastFocusedElement).toBe(buttonX);
                return [2 /*return*/];
            });
        }); });
        it('can trap focus when FTZ bookmark elements are FocusZones, and those elements have inner elements focused that are not the first inner element', function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
            var topLevelDiv, buttonZ1, buttonA, buttonB, buttonC, buttonD, buttonE, buttonF, buttonG, buttonZ2, _a, firstBumper, lastBumper;
            return tslib_1.__generator(this, function (_b) {
                expect.assertions(4);
                topLevelDiv = ReactTestUtils.renderIntoDocument(React.createElement("div", { onFocusCapture: _onFocus },
                    React.createElement("button", { className: 'z1' }, "z1"),
                    React.createElement(react_bindings_1.FocusTrapZone, { forceFocusInsideTrapOnOutsideFocus: false, className: ftzClassname },
                        React.createElement(react_bindings_1.FocusZone, { direction: accessibility_1.FocusZoneDirection.horizontal, "data-is-visible": true },
                            React.createElement("button", { className: 'a' }, "a"),
                            React.createElement("button", { className: 'b' }, "b"),
                            React.createElement("button", { className: 'c' }, "c")),
                        React.createElement("button", { className: 'd' }, "d"),
                        React.createElement(react_bindings_1.FocusZone, { direction: accessibility_1.FocusZoneDirection.horizontal, "data-is-visible": true },
                            React.createElement("button", { className: 'e' }, "e"),
                            React.createElement("button", { className: 'f' }, "f"),
                            React.createElement("button", { className: 'g' }, "g"))),
                    React.createElement("button", { className: 'z2' }, "z2")));
                buttonZ1 = topLevelDiv.querySelector('.z1');
                buttonA = topLevelDiv.querySelector('.a');
                buttonB = topLevelDiv.querySelector('.b');
                buttonC = topLevelDiv.querySelector('.c');
                buttonD = topLevelDiv.querySelector('.d');
                buttonE = topLevelDiv.querySelector('.e');
                buttonF = topLevelDiv.querySelector('.f');
                buttonG = topLevelDiv.querySelector('.g');
                buttonZ2 = topLevelDiv.querySelector('.z2');
                _a = getFtzBumpers(topLevelDiv), firstBumper = _a.firstBumper, lastBumper = _a.lastBumper;
                // Assign bounding locations to buttons.
                setupElement(buttonZ1, { clientRect: { top: 0, bottom: 10, left: 0, right: 10 } });
                setupElement(buttonA, { clientRect: { top: 10, bottom: 30, left: 0, right: 10 } });
                setupElement(buttonB, { clientRect: { top: 10, bottom: 30, left: 10, right: 20 } });
                setupElement(buttonC, { clientRect: { top: 10, bottom: 30, left: 20, right: 30 } });
                setupElement(buttonD, { clientRect: { top: 30, bottom: 40, left: 0, right: 10 } });
                setupElement(buttonE, { clientRect: { top: 40, bottom: 60, left: 0, right: 10 } });
                setupElement(buttonF, { clientRect: { top: 40, bottom: 60, left: 10, right: 20 } });
                setupElement(buttonG, { clientRect: { top: 40, bottom: 60, left: 20, right: 30 } });
                setupElement(buttonZ2, { clientRect: { top: 60, bottom: 70, left: 0, right: 10 } });
                // Focus the middle button in the first FZ.
                ReactTestUtils.Simulate.focus(buttonA);
                ReactTestUtils.Simulate.keyDown(buttonA, { which: accessibility_1.keyboardKey.ArrowRight });
                expect(lastFocusedElement).toBe(buttonB);
                // Focus the middle button in the second FZ.
                ReactTestUtils.Simulate.focus(buttonE);
                ReactTestUtils.Simulate.keyDown(buttonE, { which: accessibility_1.keyboardKey.ArrowRight });
                expect(lastFocusedElement).toBe(buttonF);
                // Simulate tab event which would focus last bumper
                ReactTestUtils.Simulate.focus(lastBumper);
                expect(lastFocusedElement).toBe(buttonB);
                // Simulate shift+tab event which would focus first bumper
                ReactTestUtils.Simulate.focus(firstBumper);
                expect(lastFocusedElement).toBe(buttonF);
                return [2 /*return*/];
            });
        }); });
    });
    describe('Tab and shift-tab do nothing (keep focus where it is) when the FTZ contains 0 tabbable items', function () {
        function setupTest(props) {
            var topLevelDiv = ReactTestUtils.renderIntoDocument(React.createElement("div", { onFocusCapture: _onFocus },
                React.createElement("button", { className: 'z1' }, "z1"),
                React.createElement(react_bindings_1.FocusTrapZone, tslib_1.__assign({ className: ftzClassname, forceFocusInsideTrapOnOutsideFocus: true }, props),
                    React.createElement("button", { className: 'a', tabIndex: -1 }, "a"),
                    React.createElement("button", { className: 'b', tabIndex: -1 }, "b"),
                    React.createElement("button", { className: 'c', tabIndex: -1 }, "c")),
                React.createElement("button", { className: 'z2' }, "z2")));
            var buttonZ1 = topLevelDiv.querySelector('.z1');
            var buttonA = topLevelDiv.querySelector('.a');
            var buttonB = topLevelDiv.querySelector('.b');
            var buttonC = topLevelDiv.querySelector('.c');
            var buttonZ2 = topLevelDiv.querySelector('.z2');
            var _a = getFtzBumpers(topLevelDiv), firstBumper = _a.firstBumper, lastBumper = _a.lastBumper;
            // Have to set bumpers as "visible" for focus utilities to find them.
            // This is needed for 0 tabbable element tests to make sure that next tabbable element
            // from one bumper is the other bumper.
            firstBumper.setAttribute('data-is-visible', String(true));
            lastBumper.setAttribute('data-is-visible', String(true));
            // Assign bounding locations to buttons.
            setupElement(buttonZ1, { clientRect: { top: 0, bottom: 10, left: 0, right: 10 } });
            setupElement(buttonA, { clientRect: { top: 10, bottom: 20, left: 0, right: 10 } });
            setupElement(buttonB, { clientRect: { top: 20, bottom: 30, left: 0, right: 10 } });
            setupElement(buttonC, { clientRect: { top: 30, bottom: 40, left: 0, right: 10 } });
            setupElement(buttonZ2, { clientRect: { top: 40, bottom: 50, left: 0, right: 10 } });
            return { buttonZ1: buttonZ1, buttonA: buttonA, buttonB: buttonB, buttonC: buttonC, buttonZ2: buttonZ2, firstBumper: firstBumper, lastBumper: lastBumper };
        }
        it('focuses first focusable element when focusing first bumper', function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
            var _a, buttonB, buttonA, firstBumper;
            return tslib_1.__generator(this, function (_b) {
                expect.assertions(2);
                _a = setupTest({}), buttonB = _a.buttonB, buttonA = _a.buttonA, firstBumper = _a.firstBumper;
                ReactTestUtils.Simulate.focus(buttonB);
                expect(lastFocusedElement).toBe(buttonB);
                // Simulate shift+tab event which would focus first bumper
                ReactTestUtils.Simulate.focus(firstBumper);
                expect(lastFocusedElement).toBe(buttonA);
                return [2 /*return*/];
            });
        }); });
        it('focuses first focusable element when focusing last bumper', function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
            var _a, buttonA, buttonB, lastBumper;
            return tslib_1.__generator(this, function (_b) {
                expect.assertions(2);
                _a = setupTest({}), buttonA = _a.buttonA, buttonB = _a.buttonB, lastBumper = _a.lastBumper;
                ReactTestUtils.Simulate.focus(buttonB);
                expect(lastFocusedElement).toBe(buttonB);
                // Simulate tab event which would focus last bumper
                ReactTestUtils.Simulate.focus(lastBumper);
                expect(lastFocusedElement).toBe(buttonA);
                return [2 /*return*/];
            });
        }); });
    });
    describe('Focus behavior based on default and explicit prop values', function () {
        function setupTest(props) {
            // data-is-visible is embedded in buttons here for testing focus behavior on initial render.
            // Components have to be marked visible before setupElement has a chance to apply the data-is-visible attribute.
            var topLevelDiv = ReactTestUtils.renderIntoDocument(React.createElement("div", null,
                React.createElement("div", { onFocusCapture: _onFocus },
                    React.createElement("button", { className: 'z1' }, "z1"),
                    React.createElement(react_bindings_1.FocusTrapZone, tslib_1.__assign({ "data-is-visible": true }, props, { className: ftzClassname }),
                        React.createElement("button", { className: 'a', "data-is-visible": true }, "a"),
                        React.createElement("button", { className: 'b', "data-is-visible": true }, "b"),
                        React.createElement("button", { className: 'c', "data-is-visible": true }, "c")),
                    React.createElement("button", { className: 'z2' }, "z2"))));
            var buttonZ1 = topLevelDiv.querySelector('.z1');
            var buttonA = topLevelDiv.querySelector('.a');
            var buttonB = topLevelDiv.querySelector('.b');
            var buttonC = topLevelDiv.querySelector('.c');
            var buttonZ2 = topLevelDiv.querySelector('.z2');
            var _a = getFtzBumpers(topLevelDiv), firstBumper = _a.firstBumper, lastBumper = _a.lastBumper;
            // Assign bounding locations to buttons.
            setupElement(buttonZ1, { clientRect: { top: 0, bottom: 10, left: 0, right: 10 } });
            setupElement(buttonA, { clientRect: { top: 10, bottom: 20, left: 0, right: 10 } });
            setupElement(buttonB, { clientRect: { top: 20, bottom: 30, left: 0, right: 10 } });
            setupElement(buttonC, { clientRect: { top: 30, bottom: 40, left: 0, right: 10 } });
            setupElement(buttonZ2, { clientRect: { top: 40, bottom: 50, left: 0, right: 10 } });
            return { buttonZ1: buttonZ1, buttonA: buttonA, buttonB: buttonB, buttonC: buttonC, buttonZ2: buttonZ2, firstBumper: firstBumper, lastBumper: lastBumper };
        }
        it('Focuses first element when FTZ does not have focus and first bumper receives focus', function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
            var _a, buttonA, buttonZ1, firstBumper;
            return tslib_1.__generator(this, function (_b) {
                expect.assertions(2);
                _a = setupTest({ isClickableOutsideFocusTrap: true }), buttonA = _a.buttonA, buttonZ1 = _a.buttonZ1, firstBumper = _a.firstBumper;
                ReactTestUtils.Simulate.focus(buttonZ1);
                expect(lastFocusedElement).toBe(buttonZ1);
                ReactTestUtils.Simulate.focus(firstBumper);
                expect(lastFocusedElement).toBe(buttonA);
                return [2 /*return*/];
            });
        }); });
        it('Focuses last element when FTZ does not have focus and last bumper receives focus', function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
            var _a, buttonC, buttonZ2, lastBumper;
            return tslib_1.__generator(this, function (_b) {
                expect.assertions(2);
                _a = setupTest({ isClickableOutsideFocusTrap: true }), buttonC = _a.buttonC, buttonZ2 = _a.buttonZ2, lastBumper = _a.lastBumper;
                ReactTestUtils.Simulate.focus(buttonZ2);
                expect(lastFocusedElement).toBe(buttonZ2);
                ReactTestUtils.Simulate.focus(lastBumper);
                expect(lastFocusedElement).toBe(buttonC);
                return [2 /*return*/];
            });
        }); });
        it('Focuses first on mount', function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
            var buttonA;
            return tslib_1.__generator(this, function (_a) {
                expect.assertions(1);
                buttonA = setupTest({}).buttonA;
                expect(document.activeElement).toBe(buttonA);
                return [2 /*return*/];
            });
        }); });
        it('Does not focus first on mount with disableFirstFocus', function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
            var activeElement;
            return tslib_1.__generator(this, function (_a) {
                expect.assertions(1);
                activeElement = document.activeElement;
                setupTest({ disableFirstFocus: true });
                // document.activeElement can be used to detect activeElement after component mount, but it does not
                // update based on focus events due to limitations of ReactDOM.
                // Make sure activeElement didn't change.
                expect(document.activeElement).toBe(activeElement);
                return [2 /*return*/];
            });
        }); });
        it('Does not focus first on mount while disabled', function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
            var activeElement;
            return tslib_1.__generator(this, function (_a) {
                expect.assertions(1);
                activeElement = document.activeElement;
                setupTest({ disabled: true });
                // document.activeElement can be used to detect activeElement after component mount, but it does not
                // update based on focus events due to limitations of ReactDOM.
                // Make sure activeElement didn't change.
                expect(document.activeElement).toBe(activeElement);
                return [2 /*return*/];
            });
        }); });
        it('Focuses on firstFocusableSelector on mount', function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
            var buttonC;
            return tslib_1.__generator(this, function (_a) {
                expect.assertions(1);
                buttonC = setupTest({ firstFocusableSelector: '.c' }).buttonC;
                expect(document.activeElement).toBe(buttonC);
                return [2 /*return*/];
            });
        }); });
        it('Does not focus on firstFocusableSelector on mount while disabled', function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
            var activeElement;
            return tslib_1.__generator(this, function (_a) {
                expect.assertions(1);
                activeElement = document.activeElement;
                setupTest({ firstFocusableSelector: '.c', disabled: true });
                expect(document.activeElement).toBe(activeElement);
                return [2 /*return*/];
            });
        }); });
        it('Falls back to first focusable element with invalid firstFocusableSelector', function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
            var buttonA;
            return tslib_1.__generator(this, function (_a) {
                buttonA = setupTest({ firstFocusableSelector: '.invalidSelector' }).buttonA;
                expect(document.activeElement).toBe(buttonA);
                return [2 /*return*/];
            });
        }); });
    });
    describe('Focusing the FTZ', function () {
        function setupTest(focusPreviouslyFocusedInnerElement) {
            var focusTrapZoneRef = null;
            var topLevelDiv = ReactTestUtils.renderIntoDocument(React.createElement("div", { onFocusCapture: _onFocus },
                React.createElement(react_bindings_1.FocusTrapZone, { forceFocusInsideTrapOnOutsideFocus: false, focusPreviouslyFocusedInnerElement: focusPreviouslyFocusedInnerElement, "data-is-focusable": true, ref: function (ftz) {
                        focusTrapZoneRef = ftz;
                    } },
                    React.createElement("button", { className: 'f' }, "f"),
                    React.createElement(react_bindings_1.FocusZone, null,
                        React.createElement("button", { className: 'a' }, "a"),
                        React.createElement("button", { className: 'b' }, "b"))),
                React.createElement("button", { className: 'z' }, "z")));
            var buttonF = topLevelDiv.querySelector('.f');
            var buttonA = topLevelDiv.querySelector('.a');
            var buttonB = topLevelDiv.querySelector('.b');
            var buttonZ = topLevelDiv.querySelector('.z');
            // Assign bounding locations to buttons.
            setupElement(buttonF, { clientRect: { top: 0, bottom: 10, left: 0, right: 10 } });
            setupElement(buttonA, { clientRect: { top: 10, bottom: 20, left: 0, right: 10 } });
            setupElement(buttonB, { clientRect: { top: 20, bottom: 30, left: 0, right: 10 } });
            setupElement(buttonZ, { clientRect: { top: 30, bottom: 40, left: 0, right: 10 } });
            return { focusTrapZone: focusTrapZoneRef, buttonF: buttonF, buttonA: buttonA, buttonB: buttonB, buttonZ: buttonZ };
        }
        it('goes to previously focused element when focusing the FTZ', function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
            var _a, focusTrapZone, buttonF, buttonB, buttonZ;
            return tslib_1.__generator(this, function (_b) {
                expect.assertions(4);
                _a = setupTest(true /* focusPreviouslyFocusedInnerElement */), focusTrapZone = _a.focusTrapZone, buttonF = _a.buttonF, buttonB = _a.buttonB, buttonZ = _a.buttonZ;
                // By calling `componentDidMount`, FTZ will behave as just initialized and focus needed element
                // @ts-ignore
                focusTrapZone.componentDidMount();
                expect(lastFocusedElement).toBe(buttonF);
                // Focus inside the trap zone, not the first element.
                ReactTestUtils.Simulate.focus(buttonB);
                expect(lastFocusedElement).toBe(buttonB);
                // Focus outside the trap zone
                ReactTestUtils.Simulate.focus(buttonZ);
                expect(lastFocusedElement).toBe(buttonZ);
                // By calling `componentDidMount`, FTZ will behave as just initialized and focus needed element
                // FTZ should return to originally focused inner element.
                // @ts-ignore
                focusTrapZone.componentDidMount();
                expect(lastFocusedElement).toBe(buttonB);
                return [2 /*return*/];
            });
        }); });
        it('goes to first focusable element when focusing the FTZ', function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
            var _a, focusTrapZone, buttonF, buttonB, buttonZ;
            return tslib_1.__generator(this, function (_b) {
                expect.assertions(4);
                _a = setupTest(false /* focusPreviouslyFocusedInnerElement */), focusTrapZone = _a.focusTrapZone, buttonF = _a.buttonF, buttonB = _a.buttonB, buttonZ = _a.buttonZ;
                // By calling `componentDidMount`, FTZ will behave as just initialized and focus needed element
                // Focus within should go to 1st focusable inner element.
                // @ts-ignore
                focusTrapZone.componentDidMount();
                expect(lastFocusedElement).toBe(buttonF);
                // Focus inside the trap zone, not the first element.
                ReactTestUtils.Simulate.focus(buttonB);
                expect(lastFocusedElement).toBe(buttonB);
                // Focus outside the trap zone
                ReactTestUtils.Simulate.focus(buttonZ);
                expect(lastFocusedElement).toBe(buttonZ);
                // By calling `componentDidMount`, FTZ will behave as just initialized and focus needed element
                // Focus should go to the first focusable element
                // @ts-ignore
                focusTrapZone.componentDidMount();
                expect(lastFocusedElement).toBe(buttonF);
                return [2 /*return*/];
            });
        }); });
    });
    describe('Nested FocusTrapZones Stack Behavior', function () {
        var getFocusStack = function () { return react_bindings_1.FocusTrapZone._focusStack; };
        beforeAll(function () { return (getFocusStack().length = 0); });
        it('FocusTrapZone maintains a proper stack of FocusTrapZones as more are mounted/unmounted.', function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
            var focusTrapZoneFocusStack, topLevelDiv, buttonA, buttonB, baseFocusTrapZone, firstFocusTrapZone, secondFocusTrapZone;
            return tslib_1.__generator(this, function (_a) {
                focusTrapZoneFocusStack = getFocusStack();
                topLevelDiv = ReactTestUtils.renderIntoDocument(React.createElement("div", null,
                    React.createElement(FocusTrapZoneTestComponent, null)));
                buttonA = topLevelDiv.querySelector('.a');
                buttonB = topLevelDiv.querySelector('.b');
                expect(focusTrapZoneFocusStack.length).toBe(2);
                baseFocusTrapZone = focusTrapZoneFocusStack[0];
                expect(baseFocusTrapZone.props.forceFocusInsideTrapOnOutsideFocus).toBe(true);
                expect(baseFocusTrapZone.props.isClickableOutsideFocusTrap).toBe(false);
                firstFocusTrapZone = focusTrapZoneFocusStack[1];
                expect(firstFocusTrapZone.props.forceFocusInsideTrapOnOutsideFocus).toBe(false);
                expect(firstFocusTrapZone.props.isClickableOutsideFocusTrap).toBe(false);
                // There should be now 3 focus trap zones (base/first/second)
                ReactTestUtils.Simulate.click(buttonB);
                expect(focusTrapZoneFocusStack.length).toBe(3);
                expect(focusTrapZoneFocusStack[0]).toBe(baseFocusTrapZone);
                expect(focusTrapZoneFocusStack[1]).toBe(firstFocusTrapZone);
                secondFocusTrapZone = focusTrapZoneFocusStack[2];
                expect(secondFocusTrapZone.props.forceFocusInsideTrapOnOutsideFocus).toBe(false);
                expect(secondFocusTrapZone.props.isClickableOutsideFocusTrap).toBe(true);
                // we remove the middle one
                // unmounting a focus trap zone should remove it from the focus stack.
                // but we also check that it removes the right focustrapzone (the middle one)
                ReactTestUtils.Simulate.click(buttonA);
                focusTrapZoneFocusStack = getFocusStack();
                expect(focusTrapZoneFocusStack.length).toBe(2);
                expect(focusTrapZoneFocusStack[0]).toBe(baseFocusTrapZone);
                expect(focusTrapZoneFocusStack[1]).toBe(secondFocusTrapZone);
                // finally remove the last focus trap zone.
                ReactTestUtils.Simulate.click(buttonB);
                focusTrapZoneFocusStack = getFocusStack();
                expect(focusTrapZoneFocusStack.length).toBe(1);
                expect(focusTrapZoneFocusStack[0]).toBe(baseFocusTrapZone);
                return [2 /*return*/];
            });
        }); });
    });
});
