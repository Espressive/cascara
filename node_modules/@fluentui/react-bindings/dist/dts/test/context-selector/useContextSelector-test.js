"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var react_bindings_1 = require("@fluentui/react-bindings");
var ReactDOM = require("react-dom");
var test_utils_1 = require("react-dom/test-utils");
var React = require("react");
var TestContext = react_bindings_1.createContext({ index: -1 });
var TestComponent = function (props) {
    var active = react_bindings_1.useContextSelector(TestContext, function (v) { return v.index === props.index; });
    React.useEffect(function () {
        props.onUpdate && props.onUpdate();
    });
    return React.createElement("div", { className: "test-component", "data-active": active });
};
var TestProvider = function (props) {
    var _a = React.useState(0), index = _a[0], setIndex = _a[1];
    return (React.createElement("div", { className: "test-provider", onClick: function () { return setIndex(function (prevIndex) { return prevIndex + 1; }); } },
        React.createElement(TestContext.Provider, { value: { index: index } }, props.children)));
};
describe('useContextSelector', function () {
    var container;
    beforeEach(function () {
        container = document.createElement('div');
        document.body.appendChild(container);
    });
    afterEach(function () {
        document.body.removeChild(container);
        container = null;
    });
    it('updates only on selector match', function () {
        var _a, _b, _c, _d;
        var onUpdate = jest.fn();
        ReactDOM.render(React.createElement(TestProvider, null,
            React.createElement(TestComponent, { index: 1, onUpdate: onUpdate })), container);
        test_utils_1.act(function () {
            // no-op to wait for effects
        });
        expect((_a = document.querySelector('.test-component')) === null || _a === void 0 ? void 0 : _a.dataset.active).toBe('false');
        expect(onUpdate).toBeCalledTimes(1);
        // Match => update, (v.index: 1, p.index: 1)
        test_utils_1.act(function () {
            var _a;
            (_a = document.querySelector('.test-provider')) === null || _a === void 0 ? void 0 : _a.click();
        });
        expect((_b = document.querySelector('.test-component')) === null || _b === void 0 ? void 0 : _b.dataset.active).toBe('true');
        expect(onUpdate).toBeCalledTimes(2);
        // No match, but update because "active" changed, (v.index: 2, p.index: 1)
        test_utils_1.act(function () {
            var _a;
            (_a = document.querySelector('.test-provider')) === null || _a === void 0 ? void 0 : _a.click();
        });
        expect((_c = document.querySelector('.test-component')) === null || _c === void 0 ? void 0 : _c.dataset.active).toBe('false');
        expect(onUpdate).toBeCalledTimes(3);
        // Match previous => no update, (v.index: 3, p.index: 1)
        test_utils_1.act(function () {
            var _a;
            (_a = document.querySelector('.test-provider')) === null || _a === void 0 ? void 0 : _a.click();
        });
        expect((_d = document.querySelector('.test-component')) === null || _d === void 0 ? void 0 : _d.dataset.active).toBe('false');
        expect(onUpdate).toBeCalledTimes(3);
    });
    it('updates are propogated inside React.memo()', function () {
        var _a, _b;
        // https://reactjs.org/docs/react-api.html#reactmemo
        // Will never pass updates
        var MemoComponent = React.memo(TestComponent, function () { return true; });
        var onUpdate = jest.fn();
        ReactDOM.render(React.createElement(TestProvider, null,
            React.createElement(MemoComponent, { index: 1, onUpdate: onUpdate })), container);
        expect((_a = document.querySelector('.test-component')) === null || _a === void 0 ? void 0 : _a.dataset.active).toBe('false');
        test_utils_1.act(function () {
            var _a;
            (_a = document.querySelector('.test-provider')) === null || _a === void 0 ? void 0 : _a.click();
        });
        expect((_b = document.querySelector('.test-component')) === null || _b === void 0 ? void 0 : _b.dataset.active).toBe('true');
        expect(onUpdate).toBeCalledTimes(2);
    });
});
