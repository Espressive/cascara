import _extends from "@babel/runtime/helpers/esm/extends";
import _inheritsLoose from "@babel/runtime/helpers/esm/inheritsLoose";
import _invoke from "lodash/invoke";
import _keys from "lodash/keys";
import _uniqueId from "lodash/uniqueId";
import { FocusZoneDirection, FocusZoneTabbableElements, IS_ENTER_DISABLED_ATTRIBUTE, IS_FOCUSABLE_ATTRIBUTE, getCode, keyboardKey, SpacebarKey } from '@fluentui/accessibility';
import * as React from 'react';
import cx from 'classnames';
import * as ReactDOM from 'react-dom';
import * as PropTypes from 'prop-types';
import { elementContains, findScrollableParent, getDocument as _getDocument, getParent, getWindow, raiseClick, shouldWrapFocus as _shouldWrapFocus } from '@uifabric/utilities';
import { getElementType } from '../utils/getElementType';
import { getUnhandledProps } from '../utils/getUnhandledProps';
import { getNextElement, getPreviousElement, isElementFocusZone, isElementFocusSubZone, isElementTabbable, getElementIndexPath, getFocusableByIndexPath, FOCUSZONE_ID_ATTRIBUTE } from './focusUtilities';
var TABINDEX = 'tabindex';
var NO_VERTICAL_WRAP = 'data-no-vertical-wrap';
var NO_HORIZONTAL_WRAP = 'data-no-horizontal-wrap';
var LARGE_DISTANCE_FROM_CENTER = 999999999;
var LARGE_NEGATIVE_DISTANCE_FROM_CENTER = -999999999;
var _allInstances = {};
var outerZones = {
  _windowToOuterZoneMap: new Map(),
  register: function register(window, FZ) {
    var _this$_windowToOuterZ2;

    if (this._windowToOuterZoneMap.get(window)) {
      var _this$_windowToOuterZ;

      (_this$_windowToOuterZ = this._windowToOuterZoneMap.get(window)) == null ? void 0 : _this$_windowToOuterZ.add(FZ);
    } else {
      this._windowToOuterZoneMap.set(window, new Set([FZ]));
    }

    return (_this$_windowToOuterZ2 = this._windowToOuterZoneMap.get(window)) == null ? void 0 : _this$_windowToOuterZ2.size;
  },
  unregister: function unregister(window, FZ) {
    var _this$_windowToOuterZ3, _this$_windowToOuterZ4;

    (_this$_windowToOuterZ3 = this._windowToOuterZoneMap.get(window)) == null ? void 0 : _this$_windowToOuterZ3.delete(FZ);

    if (((_this$_windowToOuterZ4 = this._windowToOuterZoneMap.get(window)) == null ? void 0 : _this$_windowToOuterZ4.size) === 0) {
      this._windowToOuterZoneMap.delete(window);
    }
  },
  getOutZone: function getOutZone(window) {
    return this._windowToOuterZoneMap.get(window);
  }
};
var ALLOWED_INPUT_TYPES = ['text', 'number', 'password', 'email', 'tel', 'url', 'search'];
var ALLOW_VIRTUAL_ELEMENTS = false;
/**
 * Handle global tab presses so that we can patch tabindexes on the fly.
 */

function _onKeyDownCapture(ev) {
  if (getCode(ev) === keyboardKey.Tab) {
    var _outerZones$getOutZon;

    (_outerZones$getOutZon = outerZones.getOutZone(getWindow(ev.target))) == null ? void 0 : _outerZones$getOutZon.forEach(function (zone) {
      return zone.updateTabIndexes();
    });
  }
}

export var FocusZone = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(FocusZone, _React$Component);

  /** The most recently focused child element. */

  /**
   * The index path to the last focused child element.
   */

  /**
   * Flag to define when we've intentionally parked focus on the root element to temporarily
   * hold focus until items appear within the zone.
   */

  /** The child element with tabindex=0. */

  /** Used to allow us to move to next focusable element even when we're focusing on a input element when pressing tab */
  function FocusZone(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this._root = {
      current: null
    };
    _this._id = void 0;
    _this._activeElement = void 0;
    _this._lastIndexPath = void 0;
    _this._isParked = false;
    _this._parkedTabIndex = void 0;
    _this._defaultFocusElement = void 0;
    _this._focusAlignment = void 0;
    _this._isInnerZone = void 0;
    _this._processingTabKey = void 0;
    _this.windowElement = void 0;

    _this.setRef = function (elem) {
      // findDOMNode needed to get correct DOM ref with react-hot-loader, see https://github.com/gaearon/react-hot-loader/issues/964
      _this._root.current = ReactDOM.findDOMNode(elem);
    };

    _this._onBlur = function () {
      _this.setParkedFocus(false);
    };

    _this._onFocus = function (ev) {
      var _ev$target;

      var _this$props = _this.props,
          onActiveElementChanged = _this$props.onActiveElementChanged,
          stopFocusPropagation = _this$props.stopFocusPropagation,
          shouldFocusInnerElementWhenReceivedFocus = _this$props.shouldFocusInnerElementWhenReceivedFocus,
          defaultTabbableElement = _this$props.defaultTabbableElement,
          shouldIgnoreNotFocusable = _this$props.shouldIgnoreNotFocusable;

      if (shouldIgnoreNotFocusable && ((_ev$target = ev.target) == null ? void 0 : _ev$target.dataset.isFocusable) === 'false') {
        return;
      }

      var newActiveElement;

      var isImmediateDescendant = _this.isImmediateDescendantOfZone(ev.target);

      if (isImmediateDescendant) {
        newActiveElement = ev.target;
      } else {
        var parentElement = ev.target;

        while (parentElement && parentElement !== _this._root.current) {
          if (isElementTabbable(parentElement) && _this.isImmediateDescendantOfZone(parentElement)) {
            newActiveElement = parentElement;
            break;
          }

          parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);
        }
      } // If an inner focusable element should be focused when FocusZone container receives focus


      if (shouldFocusInnerElementWhenReceivedFocus && ev.target === _this._root.current) {
        var maybeElementToFocus = defaultTabbableElement && typeof defaultTabbableElement === 'function' && defaultTabbableElement(_this._root.current); // try to focus defaultTabbable element

        if (maybeElementToFocus && isElementTabbable(maybeElementToFocus)) {
          newActiveElement = maybeElementToFocus;
          maybeElementToFocus.focus();
        } else {
          // force focus on first focusable element
          _this.focus(true);

          if (_this._activeElement) {
            // set to null as new active element was handled in method above
            newActiveElement = null;
          }
        }
      }

      if (newActiveElement && newActiveElement !== _this._activeElement) {
        _this._activeElement = newActiveElement;

        if (isImmediateDescendant) {
          _this.setFocusAlignment(_this._activeElement);

          _this.updateTabIndexes();
        }
      }

      if (onActiveElementChanged) {
        onActiveElementChanged(_this._activeElement, ev);
      }

      if (stopFocusPropagation) {
        ev.stopPropagation();
      }

      _invoke(_this.props, 'onFocus', ev);
    };

    _this._onMouseDown = function (ev) {
      var disabled = _this.props.disabled;

      if (disabled) {
        return;
      }

      var target = ev.target;
      var path = [];

      while (target && target !== _this._root.current) {
        path.push(target);
        target = getParent(target, ALLOW_VIRTUAL_ELEMENTS);
      }

      while (path.length) {
        target = path.pop();

        if (target && isElementTabbable(target)) {
          _this.setActiveElement(target, true);
        }

        if (isElementFocusZone(target)) {
          // Stop here since the focus zone will take care of its own children.
          break;
        }
      }
    };

    _this._onKeyDown = function (ev) {
      var _this$props2 = _this.props,
          direction = _this$props2.direction,
          disabled = _this$props2.disabled,
          shouldEnterInnerZone = _this$props2.shouldEnterInnerZone,
          pagingSupportDisabled = _this$props2.pagingSupportDisabled;

      if (disabled) {
        return undefined;
      }

      var doc = _getDocument(_this._root.current);

      if (_this.props.onKeyDown) {
        _this.props.onKeyDown(ev);
      } // @ts-ignore


      if (doc.activeElement === _this._root.current && _this._isInnerZone) {
        // If this element has focus, it is being controlled by a parent.
        // Ignore the keystroke.
        return undefined;
      } // If the default has been prevented, do not process keyboard events.


      if (ev.isDefaultPrevented()) {
        return undefined;
      }

      if (shouldEnterInnerZone && shouldEnterInnerZone(ev) && _this.isImmediateDescendantOfZone(ev.target)) {
        // Try to focus
        var innerZone = _this.getFirstInnerZone();

        if (innerZone) {
          if (!innerZone.focus(true)) {
            return undefined;
          }
        } else if (isElementFocusSubZone(ev.target)) {
          if (!_this.focusElement(getNextElement(ev.target, ev.target.firstChild, true))) {
            return undefined;
          }
        } else {
          return undefined;
        }
      } else if (ev.altKey) {
        return undefined;
      } else {
        switch (getCode(ev)) {
          case SpacebarKey:
            // @ts-ignore
            if (_this.tryInvokeClickForFocusable(ev.target)) {
              break;
            }

            return undefined;

          case keyboardKey.ArrowLeft:
            if (direction !== FocusZoneDirection.vertical) {
              _this.preventDefaultWhenHandled(ev);

              if (_this.moveFocusLeft()) {
                break;
              }
            }

            return undefined;

          case keyboardKey.ArrowRight:
            if (direction !== FocusZoneDirection.vertical) {
              _this.preventDefaultWhenHandled(ev);

              if (_this.moveFocusRight()) {
                break;
              }
            }

            return undefined;

          case keyboardKey.ArrowUp:
            if (direction !== FocusZoneDirection.horizontal) {
              _this.preventDefaultWhenHandled(ev);

              if (_this.moveFocusUp()) {
                break;
              }
            }

            return undefined;

          case keyboardKey.ArrowDown:
            if (direction !== FocusZoneDirection.horizontal) {
              _this.preventDefaultWhenHandled(ev);

              if (_this.moveFocusDown()) {
                break;
              }
            }

            return undefined;

          case keyboardKey.PageDown:
            if (!pagingSupportDisabled && _this.moveFocusPaging(true)) {
              break;
            }

            return undefined;

          case keyboardKey.PageUp:
            if (!pagingSupportDisabled && _this.moveFocusPaging(false)) {
              break;
            }

            return undefined;

          case keyboardKey.Tab:
            if (_this.props.handleTabKey === FocusZoneTabbableElements.all || _this.props.handleTabKey === FocusZoneTabbableElements.inputOnly && _this.isElementInput(ev.target)) {
              var focusChanged = false;
              _this._processingTabKey = true;

              if (direction === FocusZoneDirection.vertical || !_this.shouldWrapFocus(_this._activeElement, NO_HORIZONTAL_WRAP)) {
                focusChanged = ev.shiftKey ? _this.moveFocusUp() : _this.moveFocusDown();
              } else {
                var tabWithDirection = _this.props.isRtl ? !ev.shiftKey : ev.shiftKey;
                focusChanged = tabWithDirection ? _this.moveFocusLeft() : _this.moveFocusRight();
              }

              _this._processingTabKey = false;

              if (focusChanged) {
                break;
              }
            } else if (_this.props.shouldResetActiveElementWhenTabFromZone) {
              _this._activeElement = null;
            }

            return undefined;

          case keyboardKey.Home:
            if (_this.isContentEditableElement(ev.target) || _this.isElementInput(ev.target) && !_this.shouldInputLoseFocus(ev.target, false)) {
              return false;
            }

            var firstChild = _this._root.current && _this._root.current.firstChild;

            if (_this._root.current && firstChild && _this.focusElement(getNextElement(_this._root.current, firstChild, true))) {
              break;
            }

            return undefined;

          case keyboardKey.End:
            if (_this.isContentEditableElement(ev.target) || _this.isElementInput(ev.target) && !_this.shouldInputLoseFocus(ev.target, false)) {
              return false;
            }

            var lastChild = _this._root.current && _this._root.current.lastChild;

            if (_this._root.current && _this.focusElement(getPreviousElement(_this._root.current, lastChild, true, true, true))) {
              break;
            }

            return undefined;

          case keyboardKey.Enter:
            // @ts-ignore
            if (_this.tryInvokeClickForFocusable(ev.target)) {
              break;
            }

            return undefined;

          default:
            return undefined;
        }
      }

      ev.preventDefault();
      ev.stopPropagation();
      return undefined;
    };

    _this.getHorizontalDistanceFromCenter = function (isForward, activeRect, targetRect) {
      var leftAlignment = _this._focusAlignment.left; // ClientRect values can be floats that differ by very small fractions of a decimal.
      // If the difference between top and bottom are within a pixel then we should treat
      // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,
      // but without Math.Floor they will be handled incorrectly.

      var targetRectTop = Math.floor(targetRect.top);
      var activeRectBottom = Math.floor(activeRect.bottom);
      var targetRectBottom = Math.floor(targetRect.bottom);
      var activeRectTop = Math.floor(activeRect.top);
      var isValidCandidateOnpagingDown = isForward && targetRectTop > activeRectBottom;
      var isValidCandidateOnpagingUp = !isForward && targetRectBottom < activeRectTop;

      if (isValidCandidateOnpagingDown || isValidCandidateOnpagingUp) {
        if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {
          return 0;
        }

        return Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);
      }

      if (!_this.shouldWrapFocus(_this._activeElement, NO_VERTICAL_WRAP)) {
        return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
      }

      return LARGE_DISTANCE_FROM_CENTER;
    };

    _this._id = _uniqueId('FocusZone');
    _this._focusAlignment = {
      left: 0,
      top: 0
    };
    _this._processingTabKey = false;
    return _this;
  }

  var _proto = FocusZone.prototype;

  _proto.componentDidMount = function componentDidMount() {
    _allInstances[this._id] = this;
    this.setRef(this); // called here to support functional components, we only need HTMLElement ref anyway

    if (!this._root.current) {
      return;
    } // @ts-ignore


    this.windowElement = getWindow(this._root.current);
    var parentElement = getParent(this._root.current, ALLOW_VIRTUAL_ELEMENTS);

    var doc = _getDocument(this._root.current); // @ts-ignore


    while (parentElement && parentElement !== doc.body && parentElement.nodeType === 1) {
      if (isElementFocusZone(parentElement)) {
        this._isInnerZone = true;
        break;
      }

      parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);
    }

    if (!this._isInnerZone && this.windowElement) {
      var _outerZones$getOutZon2;

      outerZones.register(this.windowElement, this);

      if (((_outerZones$getOutZon2 = outerZones.getOutZone(this.windowElement)) == null ? void 0 : _outerZones$getOutZon2.size) === 1) {
        this.windowElement.addEventListener('keydown', _onKeyDownCapture, true);
      }
    }

    this._root.current.addEventListener('blur', this._onBlur, true); // Assign initial tab indexes so that we can set initial focus as appropriate.


    this.updateTabIndexes();

    if (this.props.defaultTabbableElement && typeof this.props.defaultTabbableElement === 'string') {
      this._activeElement = this.getDocument().querySelector(this.props.defaultTabbableElement);
    }

    if (this.props.shouldFocusOnMount) {
      this.focus();
    }
  };

  _proto.componentDidUpdate = function componentDidUpdate() {
    if (!this._root.current) {
      return;
    }

    var doc = _getDocument(this._root.current);

    if (doc && this._lastIndexPath && (doc.activeElement === doc.body || doc.activeElement === null || !this.props.preventFocusRestoration && doc.activeElement === this._root.current)) {
      // The element has been removed after the render, attempt to restore focus.
      var elementToFocus = getFocusableByIndexPath(this._root.current, this._lastIndexPath);

      if (elementToFocus) {
        this.setActiveElement(elementToFocus, true);
        elementToFocus.focus();
        this.setParkedFocus(false);
      } else {
        // We had a focus path to restore, but now that path is unresolvable. Park focus
        // on the container until we can try again.
        this.setParkedFocus(true);
      }
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    delete _allInstances[this._id];
    outerZones.unregister(this.windowElement, this);

    if (!this._isInnerZone) {
      if (this.windowElement && !outerZones.getOutZone(this.windowElement)) {
        this.windowElement.removeEventListener('keydown', _onKeyDownCapture, true);
      }
    }

    if (this._root.current) {
      this._root.current.removeEventListener('blur', this._onBlur, true);
    }

    this._activeElement = null;
    this._defaultFocusElement = null;
  };

  _proto.render = function render() {
    var className = this.props.className;
    var ElementType = getElementType(this.props);
    var unhandledProps = getUnhandledProps(_keys(FocusZone.propTypes), this.props); // Note, right before rendering/reconciling proceeds, we need to record if focus
    // was in the zone before the update. This helper will track this and, if focus
    // was actually in the zone, what the index path to the element is at this time.
    // Then, later in componentDidUpdate, we can evaluate if we need to restore it in
    // the case the element was removed.

    this.evaluateFocusBeforeRender();
    return /*#__PURE__*/React.createElement(ElementType, _extends({}, unhandledProps, {
      className: cx(FocusZone.className, className),
      "data-focuszone-id": this._id,
      onKeyDown: this._onKeyDown,
      onFocus: this._onFocus,
      onMouseDownCapture: this._onMouseDown
    }), this.props.children);
  }
  /**
   * Sets focus to the first tabbable item in the zone.
   * @param forceIntoFirstElement - If true, focus will be forced into the first element, even if focus is already in the focus zone.
   * @returns True if focus could be set to an active element, false if no operation was taken.
   */
  ;

  _proto.focus = function focus(forceIntoFirstElement) {
    if (forceIntoFirstElement === void 0) {
      forceIntoFirstElement = false;
    }

    if (this._root.current) {
      if (!forceIntoFirstElement && this._root.current.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true' && this._isInnerZone) {
        var ownerZoneElement = this.getOwnerZone(this._root.current);

        if (ownerZoneElement !== this._root.current) {
          var ownerZone = _allInstances[ownerZoneElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE)];

          return !!ownerZone && ownerZone.focusElement(this._root.current);
        }

        return false;
      }

      if (!forceIntoFirstElement && this._activeElement && elementContains(this._root.current, this._activeElement, ALLOW_VIRTUAL_ELEMENTS) && isElementTabbable(this._activeElement)) {
        this._activeElement.focus();

        return true;
      }

      var firstChild = this._root.current.firstChild;
      return this.focusElement(getNextElement(this._root.current, firstChild, true));
    }

    return false;
  }
  /**
   * Sets focus to the last tabbable item in the zone.
   * @returns True if focus could be set to an active element, false if no operation was taken.
   */
  ;

  _proto.focusLast = function focusLast() {
    if (this._root.current) {
      var lastChild = this._root.current && this._root.current.lastChild;
      return this.focusElement(getPreviousElement(this._root.current, lastChild, true, true, true));
    }

    return false;
  }
  /**
   * Sets focus to a specific child element within the zone. This can be used in conjunction with
   * shouldReceiveFocus to create delayed focus scenarios (like animate the scroll position to the correct
   * location and then focus.)
   * @param element - The child element within the zone to focus.
   * @param forceAlignment - If true, focus alignment will be set according to the element provided.
   * @returns True if focus could be set to an active element, false if no operation was taken.
   */
  ;

  _proto.focusElement = function focusElement(element, forceAlignment) {
    var shouldReceiveFocus = this.props.shouldReceiveFocus;

    if (shouldReceiveFocus && !shouldReceiveFocus(element)) {
      return false;
    }

    if (element) {
      this.setActiveElement(element, forceAlignment);

      if (this._activeElement) {
        this._activeElement.focus();
      }

      return true;
    }

    return false;
  };

  // Record if focus was in the zone, what the index path to the element is at this time.
  _proto.evaluateFocusBeforeRender = function evaluateFocusBeforeRender() {
    if (!this._root.current) {
      return;
    }

    var doc = _getDocument(this._root.current);

    if (!doc) {
      return;
    }

    var focusedElement = doc.activeElement; // Only update the index path if we are not parked on the root.

    if (focusedElement !== this._root.current) {
      var shouldRestoreFocus = elementContains(this._root.current, focusedElement, ALLOW_VIRTUAL_ELEMENTS);
      this._lastIndexPath = shouldRestoreFocus ? getElementIndexPath(this._root.current, doc.activeElement) : undefined;
    }
  }
  /**
   * When focus is in the zone at render time but then all focusable elements are removed,
   * we "park" focus temporarily on the root. Once we update with focusable children, we restore
   * focus to the closest path from previous. If the user tabs away from the parked container,
   * we restore focusability to the pre-parked state.
   */
  ;

  _proto.setParkedFocus = function setParkedFocus(isParked) {
    if (this._root.current && this._isParked !== isParked) {
      this._isParked = isParked;

      if (isParked) {
        if (!this.props.allowFocusRoot) {
          this._parkedTabIndex = this._root.current.getAttribute('tabindex');

          this._root.current.setAttribute('tabindex', '-1');
        }

        this._root.current.focus();
      } else if (!this.props.allowFocusRoot) {
        if (this._parkedTabIndex) {
          this._root.current.setAttribute('tabindex', this._parkedTabIndex);

          this._parkedTabIndex = undefined;
        } else {
          this._root.current.removeAttribute('tabindex');
        }
      }
    }
  };

  _proto.setActiveElement = function setActiveElement(element, forceAlignment) {
    var previousActiveElement = this._activeElement;
    this._activeElement = element;

    if (previousActiveElement) {
      if (isElementFocusZone(previousActiveElement)) {
        this.updateTabIndexes(previousActiveElement);
      }

      previousActiveElement.tabIndex = -1;
    }

    if (this._activeElement) {
      if (!this._focusAlignment || forceAlignment) {
        this.setFocusAlignment(element, true, true);
      }

      this._activeElement.tabIndex = 0;
    }
  };

  _proto.preventDefaultWhenHandled = function preventDefaultWhenHandled(ev) {
    this.props.preventDefaultWhenHandled && ev.preventDefault();
  }
  /**
   * Handle the keystrokes.
   */
  ;

  /**
   * Walk up the dom try to find a focusable element.
   */
  _proto.tryInvokeClickForFocusable = function tryInvokeClickForFocusable(targetElement) {
    var target = targetElement;

    if (target === this._root.current || !this.props.shouldRaiseClicks) {
      return false;
    }

    do {
      if (target.tagName === 'BUTTON' || target.tagName === 'A' || target.tagName === 'INPUT' || target.tagName === 'TEXTAREA') {
        return false;
      }

      if (this.isImmediateDescendantOfZone(target) && target.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true' && target.getAttribute(IS_ENTER_DISABLED_ATTRIBUTE) !== 'true') {
        raiseClick(target);
        return true;
      }

      target = getParent(target, ALLOW_VIRTUAL_ELEMENTS);
    } while (target !== this._root.current);

    return false;
  }
  /**
   * Traverse to find first child zone.
   */
  ;

  _proto.getFirstInnerZone = function getFirstInnerZone(forRootElement) {
    var rootElement = forRootElement || this._activeElement || this._root.current;

    if (!rootElement) {
      return null;
    }

    if (isElementFocusZone(rootElement)) {
      return _allInstances[rootElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE)];
    }

    var child = rootElement.firstElementChild;

    while (child) {
      if (isElementFocusZone(child)) {
        return _allInstances[child.getAttribute(FOCUSZONE_ID_ATTRIBUTE)];
      }

      var match = this.getFirstInnerZone(child);

      if (match) {
        return match;
      }

      child = child.nextElementSibling;
    }

    return null;
  };

  _proto.moveFocus = function moveFocus(isForward, getDistanceFromCenter, // @ts-ignore
  ev, useDefaultWrap) {
    if (useDefaultWrap === void 0) {
      useDefaultWrap = true;
    }

    var element = this._activeElement;
    var candidateDistance = -1;
    var candidateElement = undefined;
    var changedFocus = false;
    var isBidirectional = this.props.direction === FocusZoneDirection.bidirectional;

    if (!element || !this._root.current) {
      return false;
    }

    if (this.isElementInput(element)) {
      if (!this.shouldInputLoseFocus(element, isForward)) {
        return false;
      }
    }

    var activeRect = isBidirectional ? element.getBoundingClientRect() : null;

    do {
      element = isForward ? getNextElement(this._root.current, element) : getPreviousElement(this._root.current, element);

      if (isBidirectional) {
        if (element) {
          var _targetRect = element.getBoundingClientRect();

          var elementDistance = getDistanceFromCenter(activeRect, _targetRect);

          if (elementDistance === -1 && candidateDistance === -1) {
            candidateElement = element;
            break;
          }

          if (elementDistance > -1 && (candidateDistance === -1 || elementDistance < candidateDistance)) {
            candidateDistance = elementDistance;
            candidateElement = element;
          }

          if (candidateDistance >= 0 && elementDistance < 0) {
            break;
          }
        }
      } else {
        candidateElement = element;
        break;
      }
    } while (element); // Focus the closest candidate


    if (candidateElement && candidateElement !== this._activeElement) {
      changedFocus = true;
      this.focusElement(candidateElement);
    } else if (this.props.isCircularNavigation && useDefaultWrap) {
      if (isForward) {
        return this.focusElement(getNextElement(this._root.current, this._root.current.firstElementChild, true));
      }

      return this.focusElement(getPreviousElement(this._root.current, this._root.current.lastElementChild, true, true, true));
    }

    return changedFocus;
  };

  _proto.moveFocusDown = function moveFocusDown() {
    var _this2 = this;

    var targetTop = -1;
    var leftAlignment = this._focusAlignment.left;

    if (this.moveFocus(true, function (activeRect, targetRect) {
      var distance = -1; // ClientRect values can be floats that differ by very small fractions of a decimal.
      // If the difference between top and bottom are within a pixel then we should treat
      // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,
      // but without Math.Floor they will be handled incorrectly.

      var targetRectTop = Math.floor(targetRect.top);
      var activeRectBottom = Math.floor(activeRect.bottom);

      if (targetRectTop < activeRectBottom) {
        if (!_this2.shouldWrapFocus(_this2._activeElement, NO_VERTICAL_WRAP)) {
          return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
        }

        return LARGE_DISTANCE_FROM_CENTER;
      }

      if (targetTop === -1 && targetRectTop >= activeRectBottom || targetRectTop === targetTop) {
        targetTop = targetRectTop;

        if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {
          distance = 0;
        } else {
          distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);
        }
      }

      return distance;
    })) {
      this.setFocusAlignment(this._activeElement, true, true);
      return true;
    }

    return false;
  };

  _proto.moveFocusUp = function moveFocusUp() {
    var _this3 = this;

    var targetTop = -1;
    var leftAlignment = this._focusAlignment.left;

    if (this.moveFocus(false, function (activeRect, targetRect) {
      var distance = -1; // ClientRect values can be floats that differ by very small fractions of a decimal.
      // If the difference between top and bottom are within a pixel then we should treat
      // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,
      // but without Math.Floor they will be handled incorrectly.

      var targetRectBottom = Math.floor(targetRect.bottom);
      var targetRectTop = Math.floor(targetRect.top);
      var activeRectTop = Math.floor(activeRect.top);

      if (targetRectBottom > activeRectTop) {
        if (!_this3.shouldWrapFocus(_this3._activeElement, NO_VERTICAL_WRAP)) {
          return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
        }

        return LARGE_DISTANCE_FROM_CENTER;
      }

      if (targetTop === -1 && targetRectBottom <= activeRectTop || targetRectTop === targetTop) {
        targetTop = targetRectTop;

        if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {
          distance = 0;
        } else {
          distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);
        }
      }

      return distance;
    })) {
      this.setFocusAlignment(this._activeElement, true, true);
      return true;
    }

    return false;
  };

  _proto.moveFocusLeft = function moveFocusLeft() {
    var _this4 = this;

    var shouldWrap = this.shouldWrapFocus(this._activeElement, NO_HORIZONTAL_WRAP);

    if (this.moveFocus( // @ts-ignore
    this.props.isRtl, function (activeRect, targetRect) {
      var distance = -1;
      var topBottomComparison;

      if (_this4.props.isRtl) {
        // When in RTL, this comparison should be the same as the one in moveFocusRight for LTR.
        // Going left at a leftmost rectangle will go down a line instead of up a line like in LTR.
        // This is important, because we want to be comparing the top of the target rect
        // with the bottom of the active rect.
        topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));
      } else {
        topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));
      }

      if (topBottomComparison && targetRect.right <= activeRect.right && _this4.props.direction !== FocusZoneDirection.vertical) {
        distance = activeRect.right - targetRect.right;
      } else if (!shouldWrap) {
        distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
      }

      return distance;
    }, undefined
    /* ev */
    , shouldWrap)) {
      this.setFocusAlignment(this._activeElement, true, false);
      return true;
    }

    return false;
  };

  _proto.moveFocusRight = function moveFocusRight() {
    var _this5 = this;

    var shouldWrap = this.shouldWrapFocus(this._activeElement, NO_HORIZONTAL_WRAP);

    if (this.moveFocus(!this.props.isRtl, function (activeRect, targetRect) {
      var distance = -1;
      var topBottomComparison;

      if (_this5.props.isRtl) {
        // When in RTL, this comparison should be the same as the one in moveFocusLeft for LTR.
        // Going right at a rightmost rectangle will go up a line instead of down a line like in LTR.
        // This is important, because we want to be comparing the bottom of the target rect
        // with the top of the active rect.
        topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));
      } else {
        topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));
      }

      if (topBottomComparison && targetRect.left >= activeRect.left && _this5.props.direction !== FocusZoneDirection.vertical) {
        distance = targetRect.left - activeRect.left;
      } else if (!shouldWrap) {
        distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
      }

      return distance;
    }, undefined
    /* ev */
    , shouldWrap)) {
      this.setFocusAlignment(this._activeElement, true, false);
      return true;
    }

    return false;
  };

  _proto.moveFocusPaging = function moveFocusPaging(isForward, useDefaultWrap) {
    if (useDefaultWrap === void 0) {
      useDefaultWrap = true;
    }

    var element = this._activeElement;

    if (!element || !this._root.current) {
      return false;
    }

    if (this.isElementInput(element)) {
      if (!this.shouldInputLoseFocus(element, isForward)) {
        return false;
      }
    }

    var scrollableParent = findScrollableParent(element);

    if (!scrollableParent) {
      return false;
    }

    var candidateDistance = -1;
    var candidateElement = undefined;
    var targetTop = -1;
    var targetBottom = -1;
    var pagesize = scrollableParent.clientHeight;
    var activeRect = element.getBoundingClientRect();

    do {
      element = isForward ? getNextElement(this._root.current, element) : getPreviousElement(this._root.current, element);

      if (element) {
        var _targetRect2 = element.getBoundingClientRect();

        var targetRectTop = Math.floor(_targetRect2.top);
        var activeRectBottom = Math.floor(activeRect.bottom);
        var targetRectBottom = Math.floor(_targetRect2.bottom);
        var activeRectTop = Math.floor(activeRect.top);
        var elementDistance = this.getHorizontalDistanceFromCenter(isForward, activeRect, _targetRect2);
        var isElementPassedPageSizeOnPagingDown = isForward && targetRectTop > activeRectBottom + pagesize;
        var isElementPassedPageSizeOnPagingUp = !isForward && targetRectBottom < activeRectTop - pagesize;

        if (isElementPassedPageSizeOnPagingDown || isElementPassedPageSizeOnPagingUp) {
          break;
        }

        if (elementDistance > -1) {
          // for paging down
          if (isForward && targetRectTop > targetTop) {
            targetTop = targetRectTop;
            candidateDistance = elementDistance;
            candidateElement = element;
          } else if (!isForward && targetRectBottom < targetBottom) {
            // for paging up
            targetBottom = targetRectBottom;
            candidateDistance = elementDistance;
            candidateElement = element;
          } else if (candidateDistance === -1 || elementDistance <= candidateDistance) {
            candidateDistance = elementDistance;
            candidateElement = element;
          }
        }
      }
    } while (element);

    var changedFocus = false; // Focus the closest candidate

    if (candidateElement && candidateElement !== this._activeElement) {
      changedFocus = true;
      this.focusElement(candidateElement);
      this.setFocusAlignment(candidateElement, false, true);
    } else if (this.props.isCircularNavigation && useDefaultWrap) {
      if (isForward) {
        return this.focusElement(getNextElement(this._root.current, this._root.current.firstElementChild, true));
      }

      return this.focusElement(getPreviousElement(this._root.current, this._root.current.lastElementChild, true, true, true));
    }

    return changedFocus;
  };

  _proto.setFocusAlignment = function setFocusAlignment(element, isHorizontal, isVertical) {
    if (this.props.direction === FocusZoneDirection.bidirectional && (!this._focusAlignment || isHorizontal || isVertical)) {
      var rect = element.getBoundingClientRect();
      var left = rect.left + rect.width / 2;
      var top = rect.top + rect.height / 2;

      if (!this._focusAlignment) {
        this._focusAlignment = {
          left: left,
          top: top
        };
      }

      if (isHorizontal) {
        this._focusAlignment.left = left;
      }

      if (isVertical) {
        this._focusAlignment.top = top;
      }
    }
  };

  _proto.isImmediateDescendantOfZone = function isImmediateDescendantOfZone(element) {
    return this.getOwnerZone(element) === this._root.current;
  };

  _proto.getOwnerZone = function getOwnerZone(element) {
    var doc = _getDocument(this._root.current);

    var parentElement = getParent(element, ALLOW_VIRTUAL_ELEMENTS); // @ts-ignore

    while (parentElement && parentElement !== this._root.current && parentElement !== doc.body) {
      if (isElementFocusZone(parentElement)) {
        return parentElement;
      }

      parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);
    }

    return this._root.current;
  };

  _proto.updateTabIndexes = function updateTabIndexes(onElement) {
    var element = onElement;

    if (!this._activeElement && this.props.defaultTabbableElement && typeof this.props.defaultTabbableElement === 'function') {
      this._activeElement = this.props.defaultTabbableElement(this._root.current);
    }

    if (!element && this._root.current) {
      this._defaultFocusElement = null;
      element = this._root.current;

      if (this._activeElement && !elementContains(element, this._activeElement, ALLOW_VIRTUAL_ELEMENTS)) {
        this._activeElement = null;
      }
    } // If active element changes state to disabled, set it to null.
    // Otherwise, we lose keyboard accessibility to other elements in focus zone.


    if (this._activeElement && !isElementTabbable(this._activeElement)) {
      this._activeElement = null;
    }

    var childNodes = element && element.children;

    for (var childIndex = 0; childNodes && childIndex < childNodes.length; childIndex++) {
      var child = childNodes[childIndex];

      if (!isElementFocusZone(child)) {
        // If the item is explicitly set to not be focusable then TABINDEX needs to be set to -1.
        if (child.getAttribute && child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'false') {
          child.setAttribute(TABINDEX, '-1');
        }

        if (isElementTabbable(child)) {
          if (this.props.disabled) {
            child.setAttribute(TABINDEX, '-1');
          } else if (!this._isInnerZone && (!this._activeElement && !this._defaultFocusElement || this._activeElement === child)) {
            this._defaultFocusElement = child;

            if (child.getAttribute(TABINDEX) !== '0') {
              child.setAttribute(TABINDEX, '0');
            }
          } else if (child.getAttribute(TABINDEX) !== '-1') {
            child.setAttribute(TABINDEX, '-1');
          }
        } else if (child.tagName === 'svg' && child.getAttribute('focusable') !== 'false') {
          // Disgusting IE hack. Sad face.
          child.setAttribute('focusable', 'false');
        }
      } else if (child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true') {
        if (!this._isInnerZone && (!this._activeElement && !this._defaultFocusElement || this._activeElement === child)) {
          this._defaultFocusElement = child;

          if (child.getAttribute(TABINDEX) !== '0') {
            child.setAttribute(TABINDEX, '0');
          }
        } else if (child.getAttribute(TABINDEX) !== '-1') {
          child.setAttribute(TABINDEX, '-1');
        }
      }

      this.updateTabIndexes(child);
    }
  };

  _proto.isContentEditableElement = function isContentEditableElement(element) {
    return element && element.getAttribute('contenteditable') === 'true';
  };

  _proto.isElementInput = function isElementInput(element) {
    if (element && element.tagName && (element.tagName.toLowerCase() === 'input' || element.tagName.toLowerCase() === 'textarea')) {
      return true;
    }

    return false;
  };

  _proto.shouldInputLoseFocus = function shouldInputLoseFocus(element, isForward) {
    // If a tab was used, we want to focus on the next element.
    if (!this._processingTabKey && element && element.type && ALLOWED_INPUT_TYPES.indexOf(element.type.toLowerCase()) > -1) {
      var selectionStart = element.selectionStart;
      var selectionEnd = element.selectionEnd;
      var isRangeSelected = selectionStart !== selectionEnd;
      var inputValue = element.value;
      var isReadonly = element.readOnly; // We shouldn't lose focus in the following cases:
      // 1. There is range selected.
      // 2. When selection start is larger than 0 and it is backward and not readOnly.
      // 3. when selection start is not the end of length and it is forward and not readOnly.
      // 4. We press any of the arrow keys when our handleTabKey isn't none or undefined (only losing focus if we hit tab)
      // and if shouldInputLoseFocusOnArrowKey is defined, if scenario prefers to not loose the focus which is determined by calling the
      // callback shouldInputLoseFocusOnArrowKey

      if (isRangeSelected || selectionStart > 0 && !isForward && !isReadonly || selectionStart !== inputValue.length && isForward && !isReadonly || !!this.props.handleTabKey && !(this.props.shouldInputLoseFocusOnArrowKey && this.props.shouldInputLoseFocusOnArrowKey(element))) {
        return false;
      }
    }

    return true;
  };

  _proto.shouldWrapFocus = function shouldWrapFocus(element, noWrapDataAttribute) {
    return !!this.props.checkForNoWrap ? _shouldWrapFocus(element, noWrapDataAttribute) : true;
  };

  _proto.getDocument = function getDocument() {
    return _getDocument(this._root.current);
  };

  return FocusZone;
}(React.Component);
FocusZone.propTypes = {
  className: PropTypes.string,
  direction: PropTypes.number,
  defaultTabbableElement: PropTypes.func,
  shouldFocusOnMount: PropTypes.bool,
  shouldResetActiveElementWhenTabFromZone: PropTypes.bool,
  shouldRaiseClicks: PropTypes.bool,
  shouldFocusInnerElementWhenReceivedFocus: PropTypes.bool,
  disabled: PropTypes.bool,
  as: PropTypes.elementType,
  isCircularNavigation: PropTypes.bool,
  shouldEnterInnerZone: PropTypes.func,
  onActiveElementChanged: PropTypes.func,
  shouldReceiveFocus: PropTypes.func,
  handleTabKey: PropTypes.number,
  shouldInputLoseFocusOnArrowKey: PropTypes.func,
  stopFocusPropagation: PropTypes.bool,
  onFocus: PropTypes.func,
  preventDefaultWhenHandled: PropTypes.bool,
  isRtl: PropTypes.bool,
  preventFocusRestoration: PropTypes.bool,
  pagingSupportDisabled: PropTypes.bool,
  shouldIgnoreNotFocusable: PropTypes.bool
};
FocusZone.defaultProps = {
  isCircularNavigation: false,
  direction: FocusZoneDirection.bidirectional,
  as: 'div',
  preventDefaultWhenHandled: true,
  shouldRaiseClicks: false
};
FocusZone.displayName = 'FocusZone';
FocusZone.className = 'ms-FocusZone';
FocusZone.outerZones = outerZones;
//# sourceMappingURL=FocusZone.js.map
