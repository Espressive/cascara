{"version":3,"sources":["FocusZone/focusUtilities.ts"],"names":["IS_FOCUSABLE_ATTRIBUTE","getParent","getWindow","IS_VISIBLE_ATTRIBUTE","FOCUSZONE_ID_ATTRIBUTE","FOCUSZONE_SUB_ATTRIBUTE","HIDDEN_FROM_ACC_TREE","getDocument","getFirstFocusable","rootElement","currentElement","includeElementsInFocusZones","getNextElement","getLastFocusable","getPreviousElement","getFirstTabbable","checkNode","getLastTabbable","suppressParentTraversal","traverseChildren","tabbable","isCurrentElementVisible","isElementVisible","isElementFocusZone","isElementFocusSubZone","childMatch","lastElementChild","isElementTabbable","childMatchSiblingMatch","previousElementSibling","childMatchParent","parentElement","childMatchParentMatch","siblingMatch","suppressChildTraversal","firstElementChild","nextElementSibling","element","getAttribute","visibilityAttribute","undefined","offsetHeight","offsetParent","isVisible","checkTabIndex","disabled","tabIndex","tabIndexAttributeValue","parseInt","isFocusableAttribute","isTabIndexSet","result","tagName","targetToFocusOnNextRepaint","focusAsync","win","requestAnimationFrame","focus","getFocusableByIndexPath","parent","path","index","nextChild","children","Math","min","length","getElementIndexPath","fromElement","toElement","unshift","Array","prototype","indexOf","call"],"mappings":"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","sourcesContent":["import { IS_FOCUSABLE_ATTRIBUTE } from '@fluentui/accessibility';\nimport { getParent, getWindow } from '@uifabric/utilities';\n\nexport const IS_VISIBLE_ATTRIBUTE = 'data-is-visible';\nexport const FOCUSZONE_ID_ATTRIBUTE = 'data-focuszone-id';\nexport const FOCUSZONE_SUB_ATTRIBUTE = 'data-is-sub-focuszone';\nexport const HIDDEN_FROM_ACC_TREE = 'data-is-hidden-from-acc-tree';\n\nexport { getDocument, getParent, getWindow } from '@uifabric/utilities';\n\n/**\n * Gets the first focusable element.\n *\n * @public\n */\nexport function getFirstFocusable(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement,\n  includeElementsInFocusZones?: boolean,\n): HTMLElement | null {\n  return getNextElement(\n    rootElement,\n    currentElement,\n    true /* checkNode */,\n    false /* suppressParentTraversal */,\n    false /* suppressChildTraversal */,\n    includeElementsInFocusZones,\n  );\n}\n\n/**\n * Gets the last focusable element.\n *\n * @public\n */\nexport function getLastFocusable(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement,\n  includeElementsInFocusZones?: boolean,\n): HTMLElement | null {\n  return getPreviousElement(\n    rootElement,\n    currentElement,\n    true /* checkNode */,\n    false /* suppressParentTraversal */,\n    true /* traverseChildren */,\n    includeElementsInFocusZones,\n  );\n}\n\n/**\n * Gets the first tabbable element.\n * The difference between focusable and tabbable is that tabbable elements are focusable elements that also have tabIndex != -1.\n * @param rootElement - The parent element to search beneath.\n * @param currentElement - The descendant of rootElement to start the search at.  This element is the first one checked,\n * and iteration continues forward.  Typical use passes rootElement.firstChild.\n * @param includeElementsInFocusZones - true if traversal should go into FocusZone descendants.\n * @public\n */\nexport function getFirstTabbable(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement,\n  includeElementsInFocusZones?: boolean,\n  checkNode?: boolean,\n): HTMLElement | null {\n  return getNextElement(\n    rootElement,\n    currentElement,\n    checkNode,\n    false /* suppressParentTraversal */,\n    false /* suppressChildTraversal */,\n    includeElementsInFocusZones,\n    true /* tabbable */,\n  );\n}\n\n/**\n * Gets the last tabbable element.\n * The difference between focusable and tabbable is that tabbable elements are focusable elements that also have tabIndex != -1.\n * @param rootElement - The parent element to search beneath.\n * @param currentElement - The descendant of rootElement to start the search at.  This element is the first one checked,\n * and iteration continues in reverse.  Typical use passes rootElement.lastChild.\n * @param includeElementsInFocusZones - true if traversal should go into FocusZone descendants.\n * @public\n */\nexport function getLastTabbable(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement,\n  includeElementsInFocusZones?: boolean,\n  checkNode?: boolean,\n): HTMLElement | null {\n  return getPreviousElement(\n    rootElement,\n    currentElement,\n    checkNode,\n    false /* suppressParentTraversal */,\n    true /* traverseChildren */,\n    includeElementsInFocusZones,\n    true /* tabbable */,\n  );\n}\n\n/**\n * Traverse to find the previous element.\n * If tabbable is true, the element must have tabIndex != -1.\n *\n * @public\n */\nexport function getPreviousElement(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement | null,\n  checkNode?: boolean,\n  suppressParentTraversal?: boolean,\n  traverseChildren?: boolean,\n  includeElementsInFocusZones?: boolean,\n  tabbable?: boolean,\n): HTMLElement | null {\n  if (!currentElement || currentElement === rootElement) {\n    return null;\n  }\n\n  const isCurrentElementVisible = isElementVisible(currentElement);\n\n  // Check its children.\n  if (\n    traverseChildren &&\n    isCurrentElementVisible &&\n    (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))\n  ) {\n    const childMatch = getPreviousElement(\n      rootElement,\n      currentElement.lastElementChild as HTMLElement,\n      true,\n      true,\n      true,\n      includeElementsInFocusZones,\n      tabbable,\n    );\n\n    if (childMatch) {\n      if ((tabbable && isElementTabbable(childMatch, true)) || !tabbable) {\n        return childMatch;\n      }\n\n      const childMatchSiblingMatch = getPreviousElement(\n        rootElement,\n        childMatch.previousElementSibling as HTMLElement,\n        true,\n        true,\n        true,\n        includeElementsInFocusZones,\n        tabbable,\n      );\n      if (childMatchSiblingMatch) {\n        return childMatchSiblingMatch;\n      }\n\n      let childMatchParent = childMatch.parentElement;\n\n      // At this point if we have not found any potential matches\n      // start looking at the rest of the subtree under the currentParent.\n      // NOTE: We do not want to recurse here because doing so could\n      // cause elements to get skipped.\n      while (childMatchParent && childMatchParent !== currentElement) {\n        const childMatchParentMatch = getPreviousElement(\n          rootElement,\n          childMatchParent.previousElementSibling as HTMLElement,\n          true,\n          true,\n          true,\n          includeElementsInFocusZones,\n          tabbable,\n        );\n\n        if (childMatchParentMatch) {\n          return childMatchParentMatch;\n        }\n\n        childMatchParent = childMatchParent.parentElement;\n      }\n    }\n  }\n\n  // Check the current node, if it's not the first traversal.\n  if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement, tabbable)) {\n    return currentElement;\n  }\n\n  // Check its previous sibling.\n  const siblingMatch = getPreviousElement(\n    rootElement,\n    currentElement.previousElementSibling as HTMLElement,\n    true,\n    true,\n    true,\n    includeElementsInFocusZones,\n    tabbable,\n  );\n\n  if (siblingMatch) {\n    return siblingMatch;\n  }\n\n  // Check its parent.\n  if (!suppressParentTraversal) {\n    return getPreviousElement(\n      rootElement,\n      currentElement.parentElement,\n      true,\n      false,\n      false,\n      includeElementsInFocusZones,\n      tabbable,\n    );\n  }\n\n  return null;\n}\n\n/**\n * Traverse to find the next focusable element.\n * If tabbable is true, the element must have tabIndex != -1.\n *\n * @public\n */\nexport function getNextElement(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement | null,\n  checkNode?: boolean,\n  suppressParentTraversal?: boolean,\n  suppressChildTraversal?: boolean,\n  includeElementsInFocusZones?: boolean,\n  tabbable?: boolean,\n): HTMLElement | null {\n  if (!currentElement || (currentElement === rootElement && suppressChildTraversal)) {\n    return null;\n  }\n\n  const isCurrentElementVisible = isElementVisible(currentElement);\n\n  // Check the current node, if it's not the first traversal.\n  if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement, tabbable)) {\n    return currentElement;\n  }\n\n  // Check its children.\n  if (\n    !suppressChildTraversal &&\n    isCurrentElementVisible &&\n    (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))\n  ) {\n    const childMatch = getNextElement(\n      rootElement,\n      currentElement.firstElementChild as HTMLElement,\n      true,\n      true,\n      false,\n      includeElementsInFocusZones,\n      tabbable,\n    );\n\n    if (childMatch) {\n      return childMatch;\n    }\n  }\n\n  if (currentElement === rootElement) {\n    return null;\n  }\n\n  // Check its sibling.\n  const siblingMatch = getNextElement(\n    rootElement,\n    currentElement.nextElementSibling as HTMLElement,\n    true,\n    true,\n    false,\n    includeElementsInFocusZones,\n    tabbable,\n  );\n\n  if (siblingMatch) {\n    return siblingMatch;\n  }\n\n  if (!suppressParentTraversal) {\n    return getNextElement(\n      rootElement,\n      currentElement.parentElement,\n      false,\n      false,\n      true,\n      includeElementsInFocusZones,\n      tabbable,\n    );\n  }\n\n  return null;\n}\n\n/**\n * Determines if an element is visible.\n *\n * @public\n */\nexport function isElementVisible(element: HTMLElement | undefined | null): boolean {\n  // If the element is not valid, return false.\n  if (!element || !element.getAttribute) {\n    return false;\n  }\n\n  const visibilityAttribute = element.getAttribute(IS_VISIBLE_ATTRIBUTE);\n\n  // If the element is explicitly marked with the visibility attribute, return that value as boolean.\n  if (visibilityAttribute !== null && visibilityAttribute !== undefined) {\n    return visibilityAttribute === 'true';\n  }\n\n  // Fallback to other methods of determining actual visibility.\n  return (\n    element.offsetHeight !== 0 ||\n    element.offsetParent !== null ||\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (element as any).isVisible === true\n  ); // used as a workaround for testing.\n}\n\n/**\n * Determines if an element can receive focus programmatically or via a mouse click.\n * If checkTabIndex is true, additionally checks to ensure the element can be focused with the tab key, meaning tabIndex != -1.\n *\n * @public\n */\nexport function isElementTabbable(element: HTMLElement, checkTabIndex?: boolean): boolean {\n  // If this element is null or is disabled, it is not considered tabbable.\n  if (!element || (element as HTMLButtonElement).disabled) {\n    return false;\n  }\n\n  let tabIndex = 0;\n  let tabIndexAttributeValue: string | null = null;\n\n  if (element && element.getAttribute) {\n    tabIndexAttributeValue = element.getAttribute('tabIndex');\n\n    if (tabIndexAttributeValue) {\n      tabIndex = parseInt(tabIndexAttributeValue, 10);\n    }\n  }\n\n  const isFocusableAttribute = element.getAttribute ? element.getAttribute(IS_FOCUSABLE_ATTRIBUTE) : null;\n  const isTabIndexSet = tabIndexAttributeValue !== null && tabIndex >= 0;\n\n  const result =\n    !!element &&\n    isFocusableAttribute !== 'false' &&\n    (element.tagName === 'A' ||\n      element.tagName === 'BUTTON' ||\n      element.tagName === 'INPUT' ||\n      element.tagName === 'TEXTAREA' ||\n      isFocusableAttribute === 'true' ||\n      isTabIndexSet ||\n      (element.getAttribute && element.getAttribute('role') === 'button'));\n\n  return checkTabIndex ? tabIndex !== -1 && result : result;\n}\n\n/**\n * Determines if a given element is a focus zone.\n *\n * @public\n */\nexport function isElementFocusZone(element?: HTMLElement): boolean {\n  return !!(element && element.getAttribute && !!element.getAttribute(FOCUSZONE_ID_ATTRIBUTE));\n}\n\n/**\n * Determines if a given element is a focus sub zone.\n *\n * @public\n */\nexport function isElementFocusSubZone(element?: HTMLElement): boolean {\n  return !!(element && element.getAttribute && element.getAttribute(FOCUSZONE_SUB_ATTRIBUTE) === 'true');\n}\n\nlet targetToFocusOnNextRepaint: HTMLElement | { focus: () => void } | null | undefined = undefined;\n\n/**\n * Sets focus to an element asynchronously. The focus will be set at the next browser repaint,\n * meaning it won't cause any extra recalculations. If more than one focusAsync is called during one frame,\n * only the latest called focusAsync element will actually be focused\n * @param element - The element to focus\n */\nexport function focusAsync(element: HTMLElement | { focus: () => void } | undefined | null): void {\n  if (element) {\n    // An element was already queued to be focused, so replace that one with the new element\n    if (targetToFocusOnNextRepaint) {\n      targetToFocusOnNextRepaint = element;\n      return;\n    }\n\n    targetToFocusOnNextRepaint = element;\n\n    const win = getWindow(element as Element);\n\n    if (win) {\n      // element.focus() is a no-op if the element is no longer in the DOM, meaning this is always safe\n      win.requestAnimationFrame(() => {\n        targetToFocusOnNextRepaint && targetToFocusOnNextRepaint.focus();\n\n        // We are done focusing for this frame, so reset the queued focus element\n        targetToFocusOnNextRepaint = undefined;\n      });\n    }\n  }\n}\n\n/**\n * Finds the closest focusable element via an index path from a parent. See\n * `getElementIndexPath` for getting an index path from an element to a child.\n */\nexport function getFocusableByIndexPath(parent: HTMLElement, path: number[]): HTMLElement | undefined {\n  let element = parent;\n\n  for (const index of path) {\n    const nextChild = element.children[Math.min(index, element.children.length - 1)] as HTMLElement;\n\n    if (!nextChild) {\n      break;\n    }\n    element = nextChild;\n  }\n\n  element =\n    isElementTabbable(element) && isElementVisible(element)\n      ? element\n      : getNextElement(parent, element, true) || getPreviousElement(parent, element)!;\n\n  return element as HTMLElement;\n}\n\n/**\n * Finds the element index path from a parent element to a child element.\n *\n * If you had this node structure: \"A has children [B, C] and C has child D\",\n * the index path from A to D would be [1, 0], or `parent.chidren[1].children[0]`.\n */\nexport function getElementIndexPath(fromElement: HTMLElement, toElement: HTMLElement): number[] {\n  const path: number[] = [];\n  let currentElement: HTMLElement = toElement;\n\n  while (currentElement && fromElement && currentElement !== fromElement) {\n    const parent = getParent(currentElement, false);\n\n    if (parent === null) {\n      return [];\n    }\n\n    path.unshift(Array.prototype.indexOf.call(parent.children, currentElement));\n    currentElement = parent;\n  }\n\n  return path;\n}\n"],"file":"focusUtilities.js"}