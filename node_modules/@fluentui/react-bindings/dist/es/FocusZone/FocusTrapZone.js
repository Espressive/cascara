import _extends from "@babel/runtime/helpers/esm/extends";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inheritsLoose from "@babel/runtime/helpers/esm/inheritsLoose";
import _keys from "lodash/keys";
import { EventListener } from '@fluentui/react-component-event-listener';
import * as React from 'react';
import * as ReactDOM from 'react-dom';
import * as PropTypes from 'prop-types';
import { getElementType } from '../utils/getElementType';
import { getUnhandledProps } from '../utils/getUnhandledProps';
import { getNextElement, getFirstTabbable, getLastTabbable, getWindow, getDocument, focusAsync, HIDDEN_FROM_ACC_TREE } from './focusUtilities';

/** FocusTrapZone is used to trap the focus in any html element placed in body
 *  and hide other elements outside of Focus Trap Zone from accessibility tree.
 *  Pressing tab will circle focus within the inner focusable elements of the FocusTrapZone. */
export var FocusTrapZone = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(FocusTrapZone, _React$Component);

  function FocusTrapZone() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this._root = {
      current: null
    };
    _this._previouslyFocusedElementOutsideTrapZone = void 0;
    _this._previouslyFocusedElementInTrapZone = void 0;
    _this._firstBumper = /*#__PURE__*/React.createRef();
    _this._lastBumper = /*#__PURE__*/React.createRef();
    _this._hasFocus = false;
    _this.windowRef = /*#__PURE__*/React.createRef();

    _this.createRef = function (elem) {
      _this._root.current = ReactDOM.findDOMNode(elem); // @ts-ignore

      _this.windowRef.current = getWindow(_this._root.current);
    };

    _this.shouldHandleOutsideClick = function () {
      return !_this.props.isClickableOutsideFocusTrap || !_this.props.focusTriggerOnOutsideClick;
    };

    _this._onRootFocus = function (ev) {
      if (_this.props.onFocus) {
        _this.props.onFocus(ev);
      }

      _this._hasFocus = true;
    };

    _this._onRootBlur = function (ev) {
      if (_this.props.onBlur) {
        _this.props.onBlur(ev);
      }

      var relatedTarget = ev.relatedTarget;

      if (ev.relatedTarget === null) {
        // In IE11, due to lack of support, event.relatedTarget is always
        // null making every onBlur call to be "outside" of the ComboBox
        // even when it's not. Using document.activeElement is another way
        // for us to be able to get what the relatedTarget without relying
        // on the event
        var doc = getDocument(_this._root.current); // @ts-ignore

        relatedTarget = doc.activeElement;
      } // @ts-ignore


      if (!_this._root.current.contains(relatedTarget)) {
        _this._hasFocus = false;
      }
    };

    _this._onFirstBumperFocus = function () {
      _this._onBumperFocus(true);
    };

    _this._onLastBumperFocus = function () {
      _this._onBumperFocus(false);
    };

    _this._onBumperFocus = function (isFirstBumper) {
      if (!_this._root.current) {
        return;
      }

      var currentBumper = isFirstBumper === _this._hasFocus ? _this._lastBumper.current : _this._firstBumper.current;
      var nextFocusable = isFirstBumper === _this._hasFocus ? getLastTabbable(_this._root.current, currentBumper, true, false) : getFirstTabbable(_this._root.current, currentBumper, true, false);

      if (nextFocusable) {
        if (_this._isBumper(nextFocusable)) {
          // This can happen when FTZ contains no tabbable elements. Focus will take care of finding a focusable element in FTZ.
          _this._findElementAndFocusAsync();
        } else {
          nextFocusable.focus();
        }
      }
    };

    _this._enableFocusTrapZone = function () {
      var _this$props$disabled = _this.props.disabled,
          disabled = _this$props$disabled === void 0 ? false : _this$props$disabled;

      if (disabled) {
        return;
      }

      FocusTrapZone._focusStack.push(_assertThisInitialized(_this));

      _this._bringFocusIntoZone();

      _this._hideContentFromAccessibilityTree();
    };

    _this._bringFocusIntoZone = function () {
      var _this$props$disableFi = _this.props.disableFirstFocus,
          disableFirstFocus = _this$props$disableFi === void 0 ? false : _this$props$disableFi;
      _this._previouslyFocusedElementOutsideTrapZone = _this._getPreviouslyFocusedElementOutsideTrapZone();

      if ( // @ts-ignore
      !_this._root.current.contains(_this._previouslyFocusedElementOutsideTrapZone) && !disableFirstFocus) {
        _this._findElementAndFocusAsync();
      }
    };

    _this._releaseFocusTrapZone = function () {
      var ignoreExternalFocusing = _this.props.ignoreExternalFocusing;
      FocusTrapZone._focusStack = FocusTrapZone._focusStack.filter(function (value) {
        return _assertThisInitialized(_this) !== value;
      }); // try to focus element which triggered FocusTrapZone - prviously focused element outside trap zone

      var doc = getDocument(_this._root.current); // @ts-ignore

      var activeElement = doc.activeElement;

      if (!ignoreExternalFocusing && _this._previouslyFocusedElementOutsideTrapZone && ( // @ts-ignore
      _this._root.current.contains(activeElement) || activeElement === doc.body)) {
        _this._focusAsync(_this._previouslyFocusedElementOutsideTrapZone);
      } // if last active focus trap zone is going to be released - show previously hidden content in accessibility tree


      var lastActiveFocusTrap = FocusTrapZone._focusStack.length && FocusTrapZone._focusStack[FocusTrapZone._focusStack.length - 1];

      if (!lastActiveFocusTrap) {
        _this._showContentInAccessibilityTree();
      } else if (lastActiveFocusTrap._root.current && lastActiveFocusTrap._root.current.hasAttribute(HIDDEN_FROM_ACC_TREE)) {
        lastActiveFocusTrap._root.current.removeAttribute(HIDDEN_FROM_ACC_TREE);

        lastActiveFocusTrap._root.current.removeAttribute('aria-hidden');
      }
    };

    _this._findElementAndFocusAsync = function () {
      if (!_this._root.current) {
        return;
      }

      var _this$props = _this.props,
          focusPreviouslyFocusedInnerElement = _this$props.focusPreviouslyFocusedInnerElement,
          firstFocusableSelector = _this$props.firstFocusableSelector;

      if (focusPreviouslyFocusedInnerElement && _this._previouslyFocusedElementInTrapZone && _this._root.current.contains(_this._previouslyFocusedElementInTrapZone)) {
        // focus on the last item that had focus in the zone before we left the zone
        _this._focusAsync(_this._previouslyFocusedElementInTrapZone);

        return;
      }

      var focusSelector = firstFocusableSelector && (typeof firstFocusableSelector === 'string' ? firstFocusableSelector : firstFocusableSelector());
      var firstFocusableChild = null;

      if (focusSelector) {
        firstFocusableChild = _this._root.current.querySelector(focusSelector);
      } // Fall back to first element if query selector did not match any elements.


      if (!firstFocusableChild) {
        firstFocusableChild = getNextElement(_this._root.current, _this._root.current.firstChild, false, false, false, true);
      }

      firstFocusableChild && _this._focusAsync(firstFocusableChild);
    };

    _this._onFocusCapture = function (ev) {
      _this.props.onFocusCapture && _this.props.onFocusCapture(ev);

      if (ev.target !== ev.currentTarget && !_this._isBumper(ev.target)) {
        // every time focus changes within the trap zone, remember the focused element so that
        // it can be restored if focus leaves the pane and returns via keystroke (i.e. via a call to this.focus(true))
        _this._previouslyFocusedElementInTrapZone = ev.target;
      }
    };

    _this._forceFocusInTrap = function (ev, triggeredElement) {
      if (FocusTrapZone._focusStack.length && _assertThisInitialized(_this) === FocusTrapZone._focusStack[FocusTrapZone._focusStack.length - 1]) {
        // @ts-ignore
        if (!_this._root.current.contains(triggeredElement)) {
          _this._findElementAndFocusAsync();

          ev.preventDefault();
          ev.stopPropagation();
        }
      }
    };

    _this._handleOutsideFocus = function (ev) {
      var doc = getDocument(_this._root.current); // @ts-ignore

      var focusedElement = doc.activeElement;
      focusedElement && _this._forceFocusInTrap(ev, focusedElement);
    };

    _this._handleOutsideClick = function (ev) {
      var clickedElement = ev.target;
      var _this$props2 = _this.props,
          isClickableOutsideFocusTrap = _this$props2.isClickableOutsideFocusTrap,
          focusTriggerOnOutsideClick = _this$props2.focusTriggerOnOutsideClick;

      if (!isClickableOutsideFocusTrap) {
        clickedElement && _this._forceFocusInTrap(ev, clickedElement);
      } else if (!focusTriggerOnOutsideClick) {
        var isOutsideFocusTrapZone = _this._root.current && !_this._root.current.contains(clickedElement);
        var isOutsideTriggerElement = _this._previouslyFocusedElementOutsideTrapZone && !_this._previouslyFocusedElementOutsideTrapZone.contains(clickedElement);

        if (isOutsideFocusTrapZone && isOutsideTriggerElement) {
          // set it to NULL, so the trigger will not be focused on componentWillUnmount
          // @ts-ignore
          _this._previouslyFocusedElementOutsideTrapZone = null;
        }
      }
    };

    _this._onKeyboardHandler = function (ev) {
      if (_this.props.onKeyDown) {
        _this.props.onKeyDown(ev);
      } // do not propogate keyboard events outside focus trap zone
      // https://github.com/microsoft/fluent-ui-react/pull/1180


      ev.stopPropagation();
    };

    _this._getPreviouslyFocusedElementOutsideTrapZone = function () {
      var elementToFocusOnDismiss = _this.props.elementToFocusOnDismiss;
      var previouslyFocusedElement = _this._previouslyFocusedElementOutsideTrapZone;

      if (elementToFocusOnDismiss && previouslyFocusedElement !== elementToFocusOnDismiss) {
        previouslyFocusedElement = elementToFocusOnDismiss;
      } else if (!previouslyFocusedElement) {
        var doc = getDocument(_this._root.current); // @ts-ignore

        previouslyFocusedElement = doc.activeElement;
      }

      return previouslyFocusedElement;
    };

    _this._hideContentFromAccessibilityTree = function () {
      var doc = getDocument(_this._root.current); // @ts-ignore

      var bodyChildren = doc.body && doc.body.children || []; // @ts-ignore

      if (bodyChildren.length && !doc.body.contains(_this._root.current)) {
        // In case popup render options will change

        /* eslint-disable-next-line no-console */
        console.warn('Body element does not contain trap zone element. Please, ensure the trap zone element is placed inside body, so it will work properly.');
      }

      for (var index = 0; index < bodyChildren.length; index++) {
        var currentChild = bodyChildren[index];
        var isOrHasFocusTrapZone = currentChild === _this._root.current || currentChild.contains(_this._root.current);
        var isAriaLiveRegion = currentChild.hasAttribute('aria-live');

        if (!isOrHasFocusTrapZone && !isAriaLiveRegion && currentChild.getAttribute('aria-hidden') !== 'true') {
          currentChild.setAttribute('aria-hidden', 'true');
          currentChild.setAttribute(HIDDEN_FROM_ACC_TREE, 'true');
        }
      }
    };

    _this._showContentInAccessibilityTree = function () {
      var doc = getDocument(_this._root.current); // @ts-ignore

      var hiddenElements = doc.querySelectorAll("[" + HIDDEN_FROM_ACC_TREE + "=\"true\"]");

      for (var index = 0; index < hiddenElements.length; index++) {
        var element = hiddenElements[index];
        element.removeAttribute('aria-hidden');
        element.removeAttribute(HIDDEN_FROM_ACC_TREE);
      }
    };

    return _this;
  }

  var _proto = FocusTrapZone.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this._enableFocusTrapZone();
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var _this$props3 = this.props,
        forceFocusInsideTrapOnComponentUpdate = _this$props3.forceFocusInsideTrapOnComponentUpdate,
        forceFocusInsideTrapOnOutsideFocus = _this$props3.forceFocusInsideTrapOnOutsideFocus,
        disabled = _this$props3.disabled;
    var doc = getDocument(this._root.current); // @ts-ignore

    var activeElement = doc.activeElement; // if after componentDidUpdate focus is not inside the focus trap, bring it back

    if (!disabled && // @ts-ignore
    !this._root.current.contains(activeElement) && forceFocusInsideTrapOnComponentUpdate) {
      this._bringFocusIntoZone();

      return;
    }

    var prevForceFocusInsideTrap = prevProps.forceFocusInsideTrapOnOutsideFocus !== undefined ? prevProps.forceFocusInsideTrapOnOutsideFocus : true;
    var newForceFocusInsideTrap = forceFocusInsideTrapOnOutsideFocus !== undefined ? forceFocusInsideTrapOnOutsideFocus : true;
    var prevDisabled = prevProps.disabled !== undefined ? prevProps.disabled : false;
    var newDisabled = disabled !== undefined ? disabled : false;

    if (!prevForceFocusInsideTrap && newForceFocusInsideTrap || prevDisabled && !newDisabled) {
      // Transition from forceFocusInsideTrap / FTZ disabled to enabled.
      // Emulate what happens when a FocusTrapZone gets mounted.
      this._enableFocusTrapZone();
    } else if (prevForceFocusInsideTrap && !newForceFocusInsideTrap || !prevDisabled && newDisabled) {
      // Transition from forceFocusInsideTrap / FTZ enabled to disabled.
      // Emulate what happens when a FocusTrapZone gets unmounted.
      this._releaseFocusTrapZone();
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    // don't handle return focus unless forceFocusInsideTrapOnOutsideFocus is true or focus is still within FocusTrapZone
    var doc = getDocument(this._root.current);

    if (!this.props.disabled || this.props.forceFocusInsideTrapOnOutsideFocus || // @ts-ignore
    !this._root.current.contains(doc.activeElement)) {
      this._releaseFocusTrapZone();
    } // Dispose of element references so the DOM Nodes can be garbage-collected


    delete this._previouslyFocusedElementInTrapZone;
    delete this._previouslyFocusedElementOutsideTrapZone;
  };

  _proto.render = function render() {
    var _this$props4 = this.props,
        className = _this$props4.className,
        forceFocusInsideTrapOnOutsideFocus = _this$props4.forceFocusInsideTrapOnOutsideFocus,
        ariaLabelledBy = _this$props4.ariaLabelledBy,
        _this$props4$disabled = _this$props4.disabled,
        disabled = _this$props4$disabled === void 0 ? false : _this$props4$disabled;
    var unhandledProps = getUnhandledProps(_keys(FocusTrapZone.propTypes), this.props);
    var ElementType = getElementType(this.props);
    var bumperProps = {
      'aria-hidden': true,
      style: {
        pointerEvents: 'none',
        position: 'fixed' // 'fixed' prevents browsers from scrolling to bumpers when viewport does not contain them

      },
      tabIndex: disabled ? -1 : 0,
      // make bumpers tabbable only when enabled
      'data-is-visible': true
    };
    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(ElementType, _extends({}, unhandledProps, {
      className: className,
      ref: this.createRef,
      "aria-labelledby": ariaLabelledBy,
      onKeyDown: this._onKeyboardHandler,
      onFocusCapture: this._onFocusCapture,
      onFocus: this._onRootFocus,
      onBlur: this._onRootBlur
    }), /*#__PURE__*/React.createElement("div", _extends({}, bumperProps, {
      ref: this._firstBumper,
      onFocus: this._onFirstBumperFocus
    })), this.props.children, /*#__PURE__*/React.createElement("div", _extends({}, bumperProps, {
      ref: this._lastBumper,
      onFocus: this._onLastBumperFocus
    }))), forceFocusInsideTrapOnOutsideFocus && /*#__PURE__*/React.createElement(EventListener, {
      capture: true,
      listener: this._handleOutsideFocus,
      targetRef: this.windowRef,
      type: "focus"
    }), this.shouldHandleOutsideClick() && /*#__PURE__*/React.createElement(EventListener, {
      capture: true,
      listener: this._handleOutsideClick,
      targetRef: this.windowRef,
      type: "click"
    }));
  };

  _proto._isBumper = function _isBumper(element) {
    return element === this._firstBumper.current || element === this._lastBumper.current;
  };

  _proto._focusAsync = function _focusAsync(element) {
    if (!this._isBumper(element)) {
      focusAsync(element);
    }
  };

  return FocusTrapZone;
}(React.Component);
FocusTrapZone._focusStack = [];
FocusTrapZone.propTypes = {
  as: PropTypes.elementType,
  className: PropTypes.string,
  elementToFocusOnDismiss: PropTypes.object,
  ariaLabelledBy: PropTypes.string,
  isClickableOutsideFocusTrap: PropTypes.bool,
  ignoreExternalFocusing: PropTypes.bool,
  forceFocusInsideTrapOnOutsideFocus: PropTypes.bool,
  forceFocusInsideTrapOnComponentUpdate: PropTypes.bool,
  firstFocusableSelector: PropTypes.string,
  disableFirstFocus: PropTypes.bool,
  focusPreviouslyFocusedInnerElement: PropTypes.bool,
  focusTriggerOnOutsideClick: PropTypes.bool
};
FocusTrapZone.defaultProps = {
  as: 'div',
  isClickableOutsideFocusTrap: true,
  forceFocusInsideTrapOnOutsideFocus: false
};
//# sourceMappingURL=FocusTrapZone.js.map
