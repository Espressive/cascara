import _isEmpty from "lodash/isEmpty";
import _filter from "lodash/filter";
import { isDebugEnabled } from '@fluentui/styles';
import { resolveVariables } from './resolveVariables';
import { resolveStyles } from './resolveStyles';
export var getStyles = function getStyles(options) {
  var primaryDisplayName = options.primaryDisplayName,
      telemetry = options.telemetry; //
  // To compute styles we are going through three stages:
  // - resolve variables (siteVariables => componentVariables + props.variables)
  // - resolve styles (with resolvedVariables & props.styles & props.design)
  // - compute classes (with resolvedStyles)
  // - conditionally add sources for evaluating debug information to component

  var telemetryPartStart = telemetry != null && telemetry.enabled ? performance.now() : 0;
  var resolvedVariables = resolveVariables(options.allDisplayNames, options.theme, options.inlineStylesProps.variables, options.performance.enableVariablesCaching);

  if (telemetry != null && telemetry.enabled && telemetry.performance[primaryDisplayName]) {
    telemetry.performance[primaryDisplayName].msResolveVariablesTotal += performance.now() - telemetryPartStart;
  }

  var _resolveStyles = resolveStyles(options, resolvedVariables),
      classes = _resolveStyles.classes,
      resolvedStyles = _resolveStyles.resolvedStyles,
      resolvedStylesDebug = _resolveStyles.resolvedStylesDebug; // conditionally add sources for evaluating debug information to component


  if (process.env.NODE_ENV !== 'production' && isDebugEnabled) {
    options.saveDebug({
      componentName: options.allDisplayNames.join(':'),
      componentVariables: _filter(resolvedVariables._debug, function (variables) {
        return !_isEmpty(variables.resolved);
      }),
      componentStyles: resolvedStylesDebug,
      siteVariables: _filter(options.theme.siteVariables._debug, function (siteVars) {
        if (_isEmpty(siteVars) || _isEmpty(siteVars.resolved)) {
          return false;
        }

        var keys = Object.keys(siteVars.resolved);

        if (keys.length === 1 && keys.pop() === 'fontSizes' && _isEmpty(siteVars.resolved['fontSizes'])) {
          return false;
        }

        return true;
      })
    });
  }

  return {
    classes: classes,
    variables: resolvedVariables,
    styles: resolvedStyles,
    theme: options.theme
  };
};
//# sourceMappingURL=getStyles.js.map
