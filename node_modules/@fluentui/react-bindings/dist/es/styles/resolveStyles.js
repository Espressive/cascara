import _isNil from "lodash/isNil";
import _isPlainObject from "lodash/isPlainObject";
import { isDebugEnabled, mergeComponentStyles, withDebugId } from '@fluentui/styles';
import cx from 'classnames';
// this weak map is used as cache for the classes
var classesCache = new WeakMap(); // this weak map is used as cache for the styles

var stylesCache = new WeakMap();
/**
 * Both resolvedStyles and classes are objects of getters with lazy evaluation
 *
 * Additionally if the cacheEnabled option is provided, than the resolved styles
 * and classes are caching the results in WeakMaps. The key of the maps contains the following:
 * - theme
 * - displayName
 * - slot name
 * - styling props
 * - rtl mode
 * - disable animations mode
 */

export var resolveStyles = function resolveStyles(options, resolvedVariables) {
  var allDisplayNames = options.allDisplayNames,
      componentClassName = options.className,
      theme = options.theme,
      primaryDisplayName = options.primaryDisplayName,
      componentProps = options.componentProps,
      inlineStylesProps = options.inlineStylesProps,
      rtl = options.rtl,
      disableAnimations = options.disableAnimations,
      renderer = options.renderer,
      performanceFlags = options.performance,
      telemetry = options.telemetry;
  var className = inlineStylesProps.className,
      design = inlineStylesProps.design,
      styles = inlineStylesProps.styles,
      variables = inlineStylesProps.variables;
  var noInlineStylesOverrides = !(design || styles);
  var noVariableOverrides = performanceFlags.enableBooleanVariablesCaching || !variables;
  /* istanbul ignore else */

  if (process.env.NODE_ENV !== 'production') {
    if (!performanceFlags.enableStylesCaching && performanceFlags.enableBooleanVariablesCaching) {
      throw new Error('@fluentui/react-northstar: Please check your "performance" settings on "Provider", to enable "enableBooleanVariablesCaching" you need to enable "enableStylesCaching"');
    }
  }

  if (performanceFlags.enableBooleanVariablesCaching) {
    if (_isPlainObject(variables)) {
      var hasOnlyBooleanVariables = Object.keys(variables).every(function (variableName) {
        return variables[variableName] === null || typeof variables[variableName] === 'undefined' || typeof variables[variableName] === 'boolean';
      });

      if (!hasOnlyBooleanVariables) {
        noVariableOverrides = false;
      }
    } else if (!_isNil(variables)) {
      noVariableOverrides = false;
    }
  }

  var cacheEnabled = performanceFlags.enableStylesCaching && noInlineStylesOverrides && noVariableOverrides; // Merge theme styles with inline overrides if any

  var mergedStyles;

  if (allDisplayNames.length === 1) {
    mergedStyles = theme.componentStyles[allDisplayNames[0]] || {
      root: function root() {
        return {};
      }
    };
  } else {
    var _styles = allDisplayNames.map(function (displayName) {
      return theme.componentStyles[displayName];
    }).filter(Boolean);

    if (_styles.length > 0) {
      mergedStyles = _styles.reduce(function (acc, styles) {
        return mergeComponentStyles(acc, styles);
      }, {});
    } else {
      mergedStyles = {
        root: function root() {
          return {};
        }
      };
    }
  }

  if (!noInlineStylesOverrides) {
    mergedStyles = mergeComponentStyles(mergedStyles, mergeComponentStyles(design && withDebugId({
      root: design
    }, 'props.design'), styles && withDebugId({
      root: styles
    }, 'props.styles')));
  }

  var styleParam = {
    props: componentProps,
    variables: resolvedVariables,
    theme: theme,
    rtl: rtl,
    disableAnimations: disableAnimations
  }; // Heads Up! Keep in sync with Design.tsx render logic

  var rendererParam = {
    direction: rtl ? 'rtl' : 'ltr',
    disableAnimations: disableAnimations,
    displayName: allDisplayNames.join(':'),
    // does not affect styles, only used by useEnhancedRenderer in docs
    sanitizeCss: performanceFlags.enableSanitizeCssPlugin
  };
  var resolvedStylesDebug = {};

  if (cacheEnabled && theme) {
    if (!stylesCache.has(theme)) {
      stylesCache.set(theme, {});
    }

    if (!classesCache.has(theme)) {
      classesCache.set(theme, {});
    }
  }

  var propsCacheKey = cacheEnabled ? JSON.stringify(componentProps) : '';
  var variablesCacheKey = cacheEnabled && performanceFlags.enableBooleanVariablesCaching ? JSON.stringify(variables) : '';
  var componentCacheKey = cacheEnabled ? allDisplayNames.join(':') + ":" + propsCacheKey + ":" + variablesCacheKey + ":" + styleParam.rtl + styleParam.disableAnimations : '';

  if (typeof Proxy === 'undefined') {
    //
    //
    // IE11 branch of code, feel free to remove later.
    // Keep it sync with another branch below!
    //
    //
    var _resolvedStyles = {};
    var _classes = {};
    Object.keys(mergedStyles).forEach(function (slotName) {
      // resolve/render slot styles once and cache
      var lazyEvaluationKey = slotName + "__return";
      var slotCacheKey = componentCacheKey + slotName;
      Object.defineProperty(_resolvedStyles, slotName, {
        enumerable: false,
        configurable: false,
        set: function set(val) {
          // Add to the cache if it's enabled
          if (cacheEnabled && theme) {
            var _Object$assign;

            stylesCache.set(theme, Object.assign({}, stylesCache.get(theme), (_Object$assign = {}, _Object$assign[slotCacheKey] = val, _Object$assign)));
          }

          _resolvedStyles[lazyEvaluationKey] = val;
        },
        get: function get() {
          // If caching enabled and entry exists, get from cache, avoid lazy evaluation
          if (cacheEnabled && theme) {
            var stylesThemeCache = stylesCache.get(theme) || {};

            if (stylesThemeCache[slotCacheKey]) {
              return stylesThemeCache[slotCacheKey];
            }
          }

          if (_resolvedStyles[lazyEvaluationKey]) {
            return _resolvedStyles[lazyEvaluationKey];
          }

          var telemetryPartStart = telemetry != null && telemetry.enabled ? performance.now() : 0; // resolve/render slot styles once and cache

          _resolvedStyles[lazyEvaluationKey] = mergedStyles[slotName](styleParam);

          if (cacheEnabled && theme) {
            var _Object$assign2;

            stylesCache.set(theme, Object.assign({}, stylesCache.get(theme), (_Object$assign2 = {}, _Object$assign2[slotCacheKey] = _resolvedStyles[lazyEvaluationKey], _Object$assign2)));
          }

          if (process.env.NODE_ENV !== 'production' && isDebugEnabled) {
            resolvedStylesDebug[slotName] = _resolvedStyles[slotName]['_debug'];
            delete _resolvedStyles[slotName]['_debug'];
          }

          if (telemetry != null && telemetry.enabled && telemetry.performance[primaryDisplayName]) {
            telemetry.performance[primaryDisplayName].msResolveStylesTotal += performance.now() - telemetryPartStart;
          }

          return _resolvedStyles[lazyEvaluationKey];
        }
      });
      Object.defineProperty(_classes, slotName, {
        enumerable: false,
        configurable: false,
        set: function set(val) {
          if (cacheEnabled && theme) {
            var _Object$assign3;

            classesCache.set(theme, Object.assign({}, classesCache.get(theme), (_Object$assign3 = {}, _Object$assign3[slotCacheKey] = val, _Object$assign3)));
          }

          _classes[lazyEvaluationKey] = val;
        },
        get: function get() {
          if (cacheEnabled && theme) {
            var classesThemeCache = classesCache.get(theme) || {}; //
            // Cached styles
            //

            if (classesThemeCache[slotCacheKey] || classesThemeCache[slotCacheKey] === '') {
              if (telemetry != null && telemetry.performance[primaryDisplayName]) {
                if (slotName === 'root') {
                  telemetry.performance[primaryDisplayName].stylesRootCacheHits++;
                } else {
                  telemetry.performance[primaryDisplayName].stylesSlotsCacheHits++;
                }
              }

              return slotName === 'root' ? cx(componentClassName, classesThemeCache[slotCacheKey], className) : classesThemeCache[slotCacheKey];
            }
          } //
          // Lazy eval
          //


          if (_classes[lazyEvaluationKey]) {
            return slotName === 'root' ? cx(componentClassName, _classes[lazyEvaluationKey], className) : _classes[lazyEvaluationKey];
          } // this resolves the getter magic


          var styleObj = _resolvedStyles[slotName];
          var telemetryPartStart = telemetry != null && telemetry.enabled ? performance.now() : 0;

          if (styleObj) {
            _classes[lazyEvaluationKey] = renderer.renderRule(styleObj, rendererParam);

            if (cacheEnabled && theme) {
              var _Object$assign4;

              classesCache.set(theme, Object.assign({}, classesCache.get(theme), (_Object$assign4 = {}, _Object$assign4[slotCacheKey] = _classes[lazyEvaluationKey], _Object$assign4)));
            }
          }

          var resultClassName = slotName === 'root' ? cx(componentClassName, _classes[lazyEvaluationKey], className) : _classes[lazyEvaluationKey];

          if (telemetry != null && telemetry.enabled && telemetry.performance[primaryDisplayName]) {
            telemetry.performance[primaryDisplayName].msRenderStylesTotal += performance.now() - telemetryPartStart;
          }

          return resultClassName;
        }
      });
    });
    return {
      resolvedStyles: _resolvedStyles,
      resolvedStylesDebug: resolvedStylesDebug,
      classes: _classes
    };
  }

  var resolvedStyles = new Proxy({}, {
    get: function get(target, slotName) {
      var _mergedStyles$slotNam, _mergedStyles;

      var slotCacheKey = componentCacheKey + slotName; // If caching enabled and entry exists, get from cache, avoid lazy evaluation

      if (cacheEnabled && theme) {
        var stylesThemeCache = stylesCache.get(theme) || {};

        if (stylesThemeCache[slotCacheKey]) {
          return stylesThemeCache[slotCacheKey];
        }
      }

      if (target[slotName]) {
        return target[slotName];
      }

      var telemetryPartStart = telemetry != null && telemetry.enabled ? performance.now() : 0; // resolve/render slot styles once and cache

      target[slotName] = (_mergedStyles$slotNam = (_mergedStyles = mergedStyles)[slotName]) == null ? void 0 : _mergedStyles$slotNam.call(_mergedStyles, styleParam);

      if (cacheEnabled && theme) {
        var _Object$assign5;

        stylesCache.set(theme, Object.assign({}, stylesCache.get(theme), (_Object$assign5 = {}, _Object$assign5[slotCacheKey] = target[slotName], _Object$assign5)));
      }

      if (process.env.NODE_ENV !== 'production' && isDebugEnabled) {
        resolvedStylesDebug[slotName] = target[slotName]['_debug'];
        delete target[slotName]['_debug'];
      }

      if (telemetry != null && telemetry.enabled && telemetry.performance[primaryDisplayName]) {
        telemetry.performance[primaryDisplayName].msResolveStylesTotal += performance.now() - telemetryPartStart;
      }

      return target[slotName];
    }
  });
  var classes = new Proxy({}, {
    get: function get(target, slotName) {
      var slotCacheKey = componentCacheKey + slotName;

      if (cacheEnabled && theme) {
        var classesThemeCache = classesCache.get(theme) || {}; //
        // Cached styles
        //

        if (classesThemeCache[slotCacheKey] || classesThemeCache[slotCacheKey] === '') {
          if (telemetry != null && telemetry.performance[primaryDisplayName]) {
            if (slotName === 'root') {
              telemetry.performance[primaryDisplayName].stylesRootCacheHits++;
            } else {
              telemetry.performance[primaryDisplayName].stylesSlotsCacheHits++;
            }
          }

          return slotName === 'root' ? cx(componentClassName, classesThemeCache[slotCacheKey], className) : classesThemeCache[slotCacheKey];
        }
      } //
      // Lazy eval
      //


      if (target[slotName]) {
        return slotName === 'root' ? cx(componentClassName, target[slotName], className) : target[slotName];
      } // this resolves the getter magic


      var styleObj = resolvedStyles[slotName];
      var telemetryPartStart = telemetry != null && telemetry.enabled ? performance.now() : 0;

      if (styleObj) {
        target[slotName] = renderer.renderRule(styleObj, rendererParam);

        if (cacheEnabled && theme) {
          var _Object$assign6;

          classesCache.set(theme, Object.assign({}, classesCache.get(theme), (_Object$assign6 = {}, _Object$assign6[slotCacheKey] = target[slotName], _Object$assign6)));
        }
      }

      var resultClassName = slotName === 'root' ? cx(componentClassName, target[slotName], className) : target[slotName];

      if (telemetry != null && telemetry.enabled && telemetry.performance[primaryDisplayName]) {
        telemetry.performance[primaryDisplayName].msRenderStylesTotal += performance.now() - telemetryPartStart;
      }

      return resultClassName;
    }
  });
  return {
    resolvedStyles: resolvedStyles,
    resolvedStylesDebug: resolvedStylesDebug,
    classes: classes
  };
};
//# sourceMappingURL=resolveStyles.js.map
