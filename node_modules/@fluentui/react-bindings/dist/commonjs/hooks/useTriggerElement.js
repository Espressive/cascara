"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.useTriggerElement = useTriggerElement;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _reactComponentRef = require("@fluentui/react-component-ref");

var React = _interopRequireWildcard(require("react"));

var ReactIs = _interopRequireWildcard(require("react-is"));

var _childrenExist = require("../utils/childrenExist");

// https://github.com/facebook/react/blob/c4e0768d7487a9359b74986e3b07841d2520f593/packages/react-dom/src/events/getListener.js#L15-L22
function isDisabledInteractive(node) {
  return (node.nodeName === 'BUTTON' || node.nodeName === 'INPUT' || node.nodeName === 'SELECT' || node.nodeName === 'TEXTAREA') && node.disabled;
}

function isInteractiveFilter(node) {
  return isDisabledInteractive(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
}
/**
 * Performs consistent checks for components that are using `trigger` pattern (`Tooltip`, `Popup`). Ensures that
 * `children` or `trigger` props will always pass a valid React element to what additional props and handlers can
 * be applied.
 */


function useTriggerElement(props) {
  var trigger = (0, _childrenExist.childrenExist)(props.children) ? props.children : props.trigger;
  var element = trigger ? React.Children.only(trigger) : null; // An exception should not be thrown in tests as components might be rendered without styles

  if (process.env.NODE_ENV !== 'production' && process.env.NODE_ENV !== 'test') {
    if (ReactIs.isFragment(element)) {
      throw new Error('useTriggerElement(): A "React.Fragment" cannot be used as a "trigger" as it will be impossible to spread props on it');
    } // Hooks are used only for dev mode validations and will be removed in production builds

    /* eslint-disable react-hooks/rules-of-hooks */


    var ref = React.useRef();
    React.useEffect(function () {
      if (ref.current) {
        var _ref$current$ownerDoc;

        if (isDisabledInteractive(ref.current)) {
          // eslint-disable-next-line no-console
          console.warn(['useTriggerElement(): Disabled elements should used as a "trigger" accurately as it may lead to ', 'unexpected behavior as pointer events are ignored on disabled elements. Please wrap your "trigger" with', 'an additional element like a "div" if you need to show tooltips or popups on disabled elements, an', 'example is available in docs:', 'https://fluentsite.z22.web.core.windows.net/components/tooltip/definition#usage-disabled-trigger'].join(' '));
        }

        var treeWalker = (_ref$current$ownerDoc = ref.current.ownerDocument) == null ? void 0 : _ref$current$ownerDoc.createTreeWalker(ref.current, NodeFilter.SHOW_ELEMENT, {
          acceptNode: isInteractiveFilter
        });

        while (treeWalker != null && treeWalker.nextNode()) {
          var _node$ownerDocument, _node$ownerDocument$d;

          var node = treeWalker.currentNode;
          var nodeStyles = (_node$ownerDocument = node.ownerDocument) == null ? void 0 : (_node$ownerDocument$d = _node$ownerDocument.defaultView) == null ? void 0 : _node$ownerDocument$d.getComputedStyle(node);

          if ((nodeStyles == null ? void 0 : nodeStyles.pointerEvents) !== 'none') {
            throw new Error(['useTriggerElement(): A disabled element should have explicit "pointer-events: "none" in its styles', 'due a bug in Chrome that breaks "onMouseLeave" event in React:', 'https://github.com/facebook/react/issues/19692'].join(' '));
          }
        }
      }
    }, []);
    return element ?
    /*#__PURE__*/

    /* Required as components may call handlers via `trigger.props`, Ref will pass unhandled props down */
    React.createElement(_reactComponentRef.Ref, (0, _extends2.default)({}, element.props, {
      innerRef: ref
    }), element) : null;
  }

  return element;
}
//# sourceMappingURL=useTriggerElement.js.map
