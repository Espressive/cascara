"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.getStyles = void 0;

var _isEmpty2 = _interopRequireDefault(require("lodash/isEmpty"));

var _filter2 = _interopRequireDefault(require("lodash/filter"));

var _styles = require("@fluentui/styles");

var _resolveVariables = require("./resolveVariables");

var _resolveStyles2 = require("./resolveStyles");

var getStyles = function getStyles(options) {
  var primaryDisplayName = options.primaryDisplayName,
      telemetry = options.telemetry; //
  // To compute styles we are going through three stages:
  // - resolve variables (siteVariables => componentVariables + props.variables)
  // - resolve styles (with resolvedVariables & props.styles & props.design)
  // - compute classes (with resolvedStyles)
  // - conditionally add sources for evaluating debug information to component

  var telemetryPartStart = telemetry != null && telemetry.enabled ? performance.now() : 0;
  var resolvedVariables = (0, _resolveVariables.resolveVariables)(options.allDisplayNames, options.theme, options.inlineStylesProps.variables, options.performance.enableVariablesCaching);

  if (telemetry != null && telemetry.enabled && telemetry.performance[primaryDisplayName]) {
    telemetry.performance[primaryDisplayName].msResolveVariablesTotal += performance.now() - telemetryPartStart;
  }

  var _resolveStyles = (0, _resolveStyles2.resolveStyles)(options, resolvedVariables),
      classes = _resolveStyles.classes,
      resolvedStyles = _resolveStyles.resolvedStyles,
      resolvedStylesDebug = _resolveStyles.resolvedStylesDebug; // conditionally add sources for evaluating debug information to component


  if (process.env.NODE_ENV !== 'production' && _styles.isDebugEnabled) {
    options.saveDebug({
      componentName: options.allDisplayNames.join(':'),
      componentVariables: (0, _filter2.default)(resolvedVariables._debug, function (variables) {
        return !(0, _isEmpty2.default)(variables.resolved);
      }),
      componentStyles: resolvedStylesDebug,
      siteVariables: (0, _filter2.default)(options.theme.siteVariables._debug, function (siteVars) {
        if ((0, _isEmpty2.default)(siteVars) || (0, _isEmpty2.default)(siteVars.resolved)) {
          return false;
        }

        var keys = Object.keys(siteVars.resolved);

        if (keys.length === 1 && keys.pop() === 'fontSizes' && (0, _isEmpty2.default)(siteVars.resolved['fontSizes'])) {
          return false;
        }

        return true;
      })
    });
  }

  return {
    classes: classes,
    variables: resolvedVariables,
    styles: resolvedStyles,
    theme: options.theme
  };
};

exports.getStyles = getStyles;
//# sourceMappingURL=getStyles.js.map
