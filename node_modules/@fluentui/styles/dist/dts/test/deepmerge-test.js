"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var styles_1 = require("@fluentui/styles");
describe('deepmerge', function () {
    test("always returns an object", function () {
        expect(styles_1.deepmerge({}, {})).toStrictEqual({});
        expect(styles_1.deepmerge(null, null)).toStrictEqual({});
        expect(styles_1.deepmerge(undefined, undefined)).toStrictEqual({});
        expect(styles_1.deepmerge(null, undefined)).toStrictEqual({});
        expect(styles_1.deepmerge(undefined, null)).toStrictEqual({});
        expect(styles_1.deepmerge({}, undefined)).toStrictEqual({});
        expect(styles_1.deepmerge(undefined, {})).toStrictEqual({});
        expect(styles_1.deepmerge({}, null)).toStrictEqual({});
        expect(styles_1.deepmerge(null, {})).toStrictEqual({});
    });
    test('undefined overwrites previous value', function () {
        var merged = styles_1.deepmerge({ color: 'black' }, { color: undefined });
        expect(merged).toStrictEqual({ color: undefined });
    });
    test('null overwrites previous value', function () {
        var merged = styles_1.deepmerge({ color: 'black' }, { color: null });
        expect(merged).toStrictEqual({ color: null });
    });
    test('undefined gets overwritten by next value', function () {
        var merged = styles_1.deepmerge({ color: undefined }, { color: 'black' });
        expect(merged).toStrictEqual({ color: 'black' });
    });
    test('null gets overwritten by next value', function () {
        var merged = styles_1.deepmerge({ color: null }, { color: 'black' });
        expect(merged).toStrictEqual({ color: 'black' });
    });
    test('merges top level keys', function () {
        var target = { overridden: false, keep: true };
        var source = { overridden: true, add: true };
        expect(styles_1.deepmerge(target, source)).toStrictEqual({
            overridden: true,
            keep: true,
            add: true,
        });
    });
    test('deep merges nested keys', function () {
        var target = {
            nested: {
                replaced: false,
                valueToValue: 'targetVTV',
                nullToValue: null,
                undefinedToValue: undefined,
                valueToNull: 'targetVTN',
                valueToUndefined: 'targetVTU',
                deep: {
                    dOne: 1,
                    deepValueToValue: 'targetDVTV',
                    deepNullToValue: null,
                    deepUndefinedToValue: undefined,
                    deepValueToNull: 'targetDVTN',
                    deepValueToUndefined: 'targetDVTU',
                },
            },
        };
        var source = {
            nested: {
                valueToValue: 'sourceVTV',
                nullToValue: 'sourceNTV',
                undefinedToValue: 'sourceUTV',
                valueToNull: null,
                valueToUndefined: undefined,
                other: 'value',
                deep: {
                    dTwo: 'two',
                    deepValueToValue: 'sourceDVTV',
                    deepNullToValue: 'sourceDNTV',
                    deepUndefinedToValue: 'sourceDUTV',
                    deepValueToNull: null,
                    deepValueToUndefined: undefined,
                },
            },
        };
        expect(styles_1.deepmerge(target, source)).toStrictEqual({
            nested: {
                replaced: false,
                other: 'value',
                valueToValue: 'sourceVTV',
                nullToValue: 'sourceNTV',
                undefinedToValue: 'sourceUTV',
                valueToNull: null,
                valueToUndefined: undefined,
                deep: {
                    dOne: 1,
                    dTwo: 'two',
                    deepValueToValue: 'sourceDVTV',
                    deepNullToValue: 'sourceDNTV',
                    deepUndefinedToValue: 'sourceDUTV',
                    deepValueToNull: null,
                    deepValueToUndefined: undefined,
                },
            },
        });
    });
    test('array replaces an array and does NOT concat (CSS fallback value requirement)', function () {
        var target = { overridden: [1, 2, 3] };
        var source = { overridden: [4, 5] };
        expect(styles_1.deepmerge(target, source)).toStrictEqual({
            overridden: [4, 5],
        });
    });
    test('different value types replace previous value', function () {
        expect(styles_1.deepmerge({ color: 'black' }, { color: ['green', 'red'] })).toStrictEqual({
            color: ['green', 'red'],
        });
        expect(styles_1.deepmerge({ color: ['green', 'red'] }, { color: 'black' })).toStrictEqual({
            color: 'black',
        });
        expect(styles_1.deepmerge({ color: { nested: 'object' } }, { color: ['green', 'red'] })).toStrictEqual({
            color: ['green', 'red'],
        });
        expect(styles_1.deepmerge({ color: ['green', 'red'] }, { color: { nested: 'object' } })).toStrictEqual({
            color: { nested: 'object' },
        });
        expect(styles_1.deepmerge({ color: { nested: 'object' } }, { color: undefined })).toStrictEqual({
            color: undefined,
        });
    });
    test('merges more objects', function () {
        var target = { a: 1, b: 2, c: 3, d: 4, e: 5 };
        var source1 = { b: 'bS1', d: false, bb: 'bbS1' };
        var source2 = { c: 'bS2', cc: 'bbS2' };
        var source3 = { d: 'bS3', dd: 'bbS3' };
        expect(styles_1.deepmerge(target, source1, source2, source3)).toStrictEqual({
            a: 1,
            b: 'bS1',
            c: 'bS2',
            d: 'bS3',
            e: 5,
            bb: 'bbS1',
            cc: 'bbS2',
            dd: 'bbS3',
        });
    });
    it('can handle prototype pollution', function () {
        var obj1 = {
            __proto__: { payload: 'malicious value' },
            constructor: { foo: 'malicious value' },
        };
        // used to check it keeps other properties
        var obj2 = {
            __proto__: { payload: 'malicious value' },
            prototype: { payload: 'malicious value' },
            constructor: { foo: 'malicious value' },
            foo: { bar: 'baz' },
        };
        // used to check deep cycles
        var obj3 = {
            __proto__: { payload: 'malicious value' },
            constructor: { foo: 'malicious value' },
            a: { b: 'baz', __proto__: { payload: 'malicious value' } },
        };
        expect(styles_1.deepmerge({}, obj1)).toEqual({});
        expect(styles_1.deepmerge({}, obj2)).toEqual({ foo: { bar: 'baz' } });
        expect(styles_1.deepmerge({}, obj1, obj2)).toEqual({ foo: { bar: 'baz' } });
        expect(styles_1.deepmerge(obj1, obj2, obj3)).toEqual({
            a: { b: 'baz' },
            foo: { bar: 'baz' },
        });
    });
});
