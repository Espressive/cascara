"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeThemes = exports.mergeStyles = exports.mergeAnimations = exports.mergeStaticStyles = exports.mergeFontFaces = exports.mergeThemeStyles = exports.mergeThemeVariables = exports.mergeThemeVariables__DEV = exports.mergeThemeVariables__PROD = exports.mergeSiteVariables = exports.mergeSiteVariables__DEV = exports.mergeSiteVariables__PROD = exports.mergeComponentVariables = exports.mergeComponentVariables__DEV = exports.mergeComponentVariables__PROD = exports.mergeComponentStyles = exports.mergeComponentStyles__DEV = exports.mergeComponentStyles__PROD = exports.emptyTheme = void 0;
var tslib_1 = require("tslib");
var _ = require("lodash");
var callable_1 = require("./callable");
var debugEnabled_1 = require("./debugEnabled");
var deepmerge_1 = require("./deepmerge");
var objectKeysToValues_1 = require("./objectKeysToValues");
var toCompactArray_1 = require("./toCompactArray");
var withDebugId_1 = require("./withDebugId");
exports.emptyTheme = {
    siteVariables: {
        fontSizes: {},
    },
    componentVariables: {},
    componentStyles: {},
    fontFaces: [],
    staticStyles: [],
    animations: {},
};
// ----------------------------------------
// Component level merge functions
// ----------------------------------------
/**
 * Merges a single component's styles (keyed by component part) with another component's styles.
 */
var mergeComponentStyles__PROD = function (stylesA, stylesB) {
    var result = {};
    if (stylesA) {
        Object.keys(stylesA).forEach(function (partName) {
            var slotA = stylesA[partName];
            var slotB = stylesB === null || stylesB === void 0 ? void 0 : stylesB[partName];
            // if there is no source, merging is a no-op, skip it
            if (typeof slotA === 'undefined' || slotA === null) {
                return;
            }
            // no target means source doesn't need to merge onto anything
            // just ensure source is callable (prepared format)
            if (typeof slotB === 'undefined' || slotB === null) {
                result[partName] = typeof slotA === 'function' ? slotA : function () { return slotA; };
                return;
            }
            if (slotA === slotB) {
                result[partName] = typeof slotA === 'function' ? slotA : function () { return slotA; };
            }
        });
    }
    if (stylesB) {
        Object.keys(stylesB).forEach(function (partName) {
            var slotA = stylesA === null || stylesA === void 0 ? void 0 : stylesA[partName];
            var slotB = stylesB[partName];
            // if there is no source, merging is a no-op, skip it
            if (typeof slotB === 'undefined' || slotB === null) {
                return;
            }
            // no target means source doesn't need to merge onto anything
            // just ensure source is callable (prepared format)
            if (typeof slotA === 'undefined' || slotA === null) {
                result[partName] = typeof slotB === 'function' ? slotB : function () { return slotB; };
                return;
            }
            if (slotA === slotB) {
                return;
            }
            // We have both target and source, replace with merge fn
            result[partName] = function mergedStyleFunction(styleParam) {
                // originalTarget is always prepared, fn is guaranteed
                return _.merge(typeof slotA === 'function' ? slotA(styleParam) : slotA, typeof slotB === 'function' ? slotB(styleParam) : slotB);
            };
        });
    }
    return result;
};
exports.mergeComponentStyles__PROD = mergeComponentStyles__PROD;
var mergeComponentStyles__DEV = function (stylesA, stylesB) {
    if (!debugEnabled_1.isEnabled) {
        return exports.mergeComponentStyles__PROD(stylesA, stylesB);
    }
    var mergedKeys = tslib_1.__spreadArrays((stylesA ? Object.keys(stylesA) : []), (stylesB ? Object.keys(stylesB) : []));
    var result = {};
    mergedKeys.forEach(function (slotName) {
        var slotA = function (styleParam) {
            var _a = callable_1.callable(stylesA === null || stylesA === void 0 ? void 0 : stylesA[slotName])(styleParam) || {}, _b = _a._debug, _debug = _b === void 0 ? undefined : _b, styles = tslib_1.__rest(_a, ["_debug"]);
            // new object required to prevent circular JSON structure error in <Debug />
            return tslib_1.__assign(tslib_1.__assign({}, styles), { _debug: _debug || [{ styles: tslib_1.__assign({}, styles), debugId: stylesA._debugId }] });
        };
        var slotB = function (styleParam) {
            var _a = callable_1.callable(stylesB === null || stylesB === void 0 ? void 0 : stylesB[slotName])(styleParam) || {}, _b = _a._debug, _debug = _b === void 0 ? undefined : _b, styles = tslib_1.__rest(_a, ["_debug"]);
            // new object required to prevent circular JSON structure error in <Debug />
            return tslib_1.__assign(tslib_1.__assign({}, styles), { _debug: _debug || [{ styles: tslib_1.__assign({}, styles), debugId: stylesB._debugId }] });
        };
        if ((stylesA === null || stylesA === void 0 ? void 0 : stylesA[slotName]) && (stylesB === null || stylesB === void 0 ? void 0 : stylesB[slotName])) {
            // We have both, replace with merge fn
            result[slotName] = function (styleParam) {
                // slot* are always prepared, fn is guaranteed, _debug always exists
                var _a = slotA(styleParam), debugA = _a._debug, resolvedStylesA = tslib_1.__rest(_a, ["_debug"]);
                var _b = slotB(styleParam), debugB = _b._debug, resolvedStylesB = tslib_1.__rest(_b, ["_debug"]);
                var merged = _.merge(resolvedStylesA, resolvedStylesB);
                merged._debug = debugA.concat(debugB || { styles: resolvedStylesB, debugId: resolvedStylesB._debugId });
                return merged;
            };
        }
        else if (stylesA === null || stylesA === void 0 ? void 0 : stylesA[slotName]) {
            result[slotName] = slotA;
        }
        else if (stylesB === null || stylesB === void 0 ? void 0 : stylesB[slotName]) {
            result[slotName] = slotB;
        }
    });
    return result;
};
exports.mergeComponentStyles__DEV = mergeComponentStyles__DEV;
exports.mergeComponentStyles = process.env.NODE_ENV === 'production' ? exports.mergeComponentStyles__PROD : exports.mergeComponentStyles__DEV;
/**
 * Merges a single component's variables with another component's variables.
 */
var mergeComponentVariables__PROD = function () {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    var initial = function () { return ({}); };
    // filtering is required as some arguments can be undefined
    var filteredSources = sources.filter(Boolean);
    // a short circle to avoid calls of deepmerge()
    if (filteredSources.length === 1) {
        return typeof filteredSources[0] === 'function' ? filteredSources[0] : callable_1.callable(filteredSources[0]);
    }
    return filteredSources.reduce(function (acc, next) {
        return function mergeComponentVariables() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var accumulatedVariables = acc.apply(void 0, args);
            var fn = typeof next === 'function' ? next : callable_1.callable(next);
            var computedComponentVariables = fn.apply(void 0, args);
            return deepmerge_1.deepmerge(accumulatedVariables, computedComponentVariables);
        };
    }, initial);
};
exports.mergeComponentVariables__PROD = mergeComponentVariables__PROD;
var mergeComponentVariables__DEV = function () {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    if (!debugEnabled_1.isEnabled) {
        return exports.mergeComponentVariables__PROD.apply(void 0, sources);
    }
    var initial = function () { return ({}); };
    return sources.reduce(function (acc, next) {
        return function (siteVariables) {
            var _a = acc(siteVariables), _b = _a._debug, _debug = _b === void 0 ? [] : _b, accumulatedVariables = tslib_1.__rest(_a, ["_debug"]);
            var _c = callable_1.callable(next)(siteVariables) || {}, _d = _c._debug, computedDebug = _d === void 0 ? undefined : _d, _e = _c._debugId, _debugId = _e === void 0 ? undefined : _e, computedComponentVariables = tslib_1.__rest(_c, ["_debug", "_debugId"]);
            var merged = deepmerge_1.deepmerge(accumulatedVariables, computedComponentVariables);
            merged._debug = _debug.concat(computedDebug || {
                resolved: computedComponentVariables,
                debugId: _debugId,
                input: siteVariables
                    ? siteVariables._invertedKeys && callable_1.callable(next)(siteVariables._invertedKeys)
                    : callable_1.callable(next)(),
            });
            return merged;
        };
    }, initial);
};
exports.mergeComponentVariables__DEV = mergeComponentVariables__DEV;
exports.mergeComponentVariables = process.env.NODE_ENV === 'production' ? exports.mergeComponentVariables__PROD : exports.mergeComponentVariables__DEV;
// ----------------------------------------
// Theme level merge functions
// ----------------------------------------
/**
 * Site variables can safely be merged at each Provider in the tree.
 * They are flat objects and do not depend on render-time values, such as props.
 */
var mergeSiteVariables__PROD = function () {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    var initial = {
        fontSizes: {},
    };
    return deepmerge_1.deepmerge.apply(void 0, tslib_1.__spreadArrays([initial], sources));
};
exports.mergeSiteVariables__PROD = mergeSiteVariables__PROD;
var mergeSiteVariables__DEV = function () {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    if (!debugEnabled_1.isEnabled) {
        return exports.mergeSiteVariables__PROD.apply(void 0, sources);
    }
    var initial = {
        fontSizes: {},
    };
    return sources.reduce(function (acc, next) {
        var _a = acc._debug, _debug = _a === void 0 ? [] : _a, accumulatedSiteVariables = tslib_1.__rest(acc, ["_debug"]);
        var _b = next || {}, _c = _b._debug, computedDebug = _c === void 0 ? undefined : _c, _d = _b._invertedKeys, _invertedKeys = _d === void 0 ? undefined : _d, _e = _b._debugId, _debugId = _e === void 0 ? undefined : _e, nextSiteVariables = tslib_1.__rest(_b, ["_debug", "_invertedKeys", "_debugId"]);
        var merged = deepmerge_1.deepmerge(tslib_1.__assign(tslib_1.__assign({}, accumulatedSiteVariables), { _invertedKeys: undefined }), nextSiteVariables);
        merged._debug = _debug.concat(computedDebug || { resolved: nextSiteVariables, debugId: _debugId });
        merged._invertedKeys = _invertedKeys || objectKeysToValues_1.objectKeyToValues(merged, function (key) { return "siteVariables." + key; });
        return merged;
    }, initial);
};
exports.mergeSiteVariables__DEV = mergeSiteVariables__DEV;
exports.mergeSiteVariables = process.env.NODE_ENV === 'production' ? exports.mergeSiteVariables__PROD : exports.mergeSiteVariables__DEV;
/**
 * Component variables can be objects, functions, or an array of these.
 * The functions must be called with the final result of siteVariables, otherwise
 *   the component variable objects would have no ability to apply siteVariables.
 * Therefore, componentVariables must be resolved by the component at render time.
 * We instead pass down call stack of component variable functions to be resolved later.
 */
var mergeThemeVariables__PROD = function () {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    var displayNames = _.union.apply(_, _.map(sources, _.keys));
    return displayNames.reduce(function (componentVariables, displayName) {
        componentVariables[displayName] = exports.mergeComponentVariables.apply(void 0, _.map(sources, displayName));
        return componentVariables;
    }, {});
};
exports.mergeThemeVariables__PROD = mergeThemeVariables__PROD;
var mergeThemeVariables__DEV = function () {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    if (!debugEnabled_1.isEnabled) {
        return exports.mergeThemeVariables__PROD.apply(void 0, sources);
    }
    var displayNames = _.union.apply(_, _.map(sources, _.keys));
    return displayNames.reduce(function (componentVariables, displayName) {
        componentVariables[displayName] = exports.mergeComponentVariables.apply(void 0, _.map(sources, function (source) { return source && withDebugId_1.withDebugId(source[displayName], source._debugId); }));
        return componentVariables;
    }, {});
};
exports.mergeThemeVariables__DEV = mergeThemeVariables__DEV;
exports.mergeThemeVariables = process.env.NODE_ENV === 'production' ? exports.mergeThemeVariables__PROD : exports.mergeThemeVariables__DEV;
/**
 * See mergeThemeVariables() description.
 * Component styles adhere to the same pattern as component variables, except
 *   that they return style objects.
 */
var mergeThemeStyles = function () {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    var initial = {};
    return sources.reduce(function (themeComponentStyles, next) {
        _.forEach(next, function (stylesByPart, displayName) {
            themeComponentStyles[displayName] = exports.mergeComponentStyles(themeComponentStyles[displayName], withDebugId_1.withDebugId(stylesByPart, next._debugId));
        });
        return themeComponentStyles;
    }, initial);
};
exports.mergeThemeStyles = mergeThemeStyles;
var mergeFontFaces = function () {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    return toCompactArray_1.toCompactArray.apply(void 0, sources);
};
exports.mergeFontFaces = mergeFontFaces;
var mergeStaticStyles = function () {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    return toCompactArray_1.toCompactArray.apply(void 0, sources);
};
exports.mergeStaticStyles = mergeStaticStyles;
var mergeAnimations = function () {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    return Object.assign.apply(Object, tslib_1.__spreadArrays([{}], sources));
};
exports.mergeAnimations = mergeAnimations;
var mergeStyles = function () {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return sources.reduce(function (acc, next) {
            return _.merge(acc, callable_1.callable(next).apply(void 0, args));
        }, {});
    };
};
exports.mergeStyles = mergeStyles;
var mergeThemes = function () {
    var themes = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        themes[_i] = arguments[_i];
    }
    return themes.reduce(function (acc, next) {
        if (!next)
            return acc;
        var nextDebugId = next['_debugId'];
        acc.siteVariables = exports.mergeSiteVariables(acc.siteVariables, withDebugId_1.withDebugId(next.siteVariables, nextDebugId));
        acc.componentVariables = exports.mergeThemeVariables(acc.componentVariables, withDebugId_1.withDebugId(next.componentVariables, nextDebugId));
        acc.componentStyles = exports.mergeThemeStyles(acc.componentStyles, withDebugId_1.withDebugId(next.componentStyles, nextDebugId));
        acc.fontFaces = exports.mergeFontFaces.apply(void 0, tslib_1.__spreadArrays(acc.fontFaces, (next.fontFaces || [])));
        acc.staticStyles = exports.mergeStaticStyles.apply(void 0, tslib_1.__spreadArrays(acc.staticStyles, (next.staticStyles || [])));
        acc.animations = exports.mergeAnimations(acc.animations, next.animations);
        return acc;
    }, tslib_1.__assign({}, exports.emptyTheme));
};
exports.mergeThemes = mergeThemes;
