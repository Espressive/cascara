"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.ref = exports.design = exports.animation = exports.align = exports.size = exports.accessibility = exports.deprecate = exports.collectionShorthandWithKindProp = exports.collectionShorthand = exports.collectionObjectShorthand = exports.itemShorthandWithoutJSX = exports.itemShorthandWithKindProp = exports.itemShorthand = exports.objectItemShorthand = exports.shorthandObjectAllowingChildren = exports.shorthandAllowingChildren = exports.wrapperShorthand = exports.nodeContent = exports.multipleProp = exports.demand = exports.givenProps = exports.some = exports.every = exports.disallow = exports.never = exports.suggest = exports.domNode = void 0;

var _difference2 = _interopRequireDefault(require("lodash/difference"));

var _trim2 = _interopRequireDefault(require("lodash/trim"));

var _isObject2 = _interopRequireDefault(require("lodash/isObject"));

var _pick2 = _interopRequireDefault(require("lodash/pick"));

var _keys2 = _interopRequireDefault(require("lodash/keys"));

var _isPlainObject2 = _interopRequireDefault(require("lodash/isPlainObject"));

var _isFunction2 = _interopRequireDefault(require("lodash/isFunction"));

var _compact2 = _interopRequireDefault(require("lodash/compact"));

var _first2 = _interopRequireDefault(require("lodash/first"));

var _isNil2 = _interopRequireDefault(require("lodash/isNil"));

var _min2 = _interopRequireDefault(require("lodash/min"));

var _sum2 = _interopRequireDefault(require("lodash/sum"));

var _map2 = _interopRequireDefault(require("lodash/map"));

var _sortBy2 = _interopRequireDefault(require("lodash/sortBy"));

var _take2 = _interopRequireDefault(require("lodash/take"));

var _memoize2 = _interopRequireDefault(require("lodash/memoize"));

var PropTypes = _interopRequireWildcard(require("prop-types"));

var _leven = _interopRequireDefault(require("./leven"));

var typeOf = function typeOf(x) {
  return Object.prototype.toString.call(x);
};
/**
 * Ensure a prop is a valid DOM node.
 */


var domNode = function domNode(props, propName) {
  // skip if prop is undefined
  if (props[propName] === undefined) return undefined; // skip if prop is null

  if (props[propName] === null) return null; // skip if prop is valid

  if (props[propName] instanceof Element) return undefined;
  return new Error("Invalid prop \"" + propName + "\" supplied, expected a DOM node.");
};
/**
 * Similar to PropTypes.oneOf but shows closest matches.
 * Word order is ignored allowing `left chevron` to match `chevron left`.
 * Useful for very large lists of options (e.g. Icon name, Flag name, etc.)
 * @param suggestions - An array of allowed values.
 */


exports.domNode = domNode;

var suggest = function suggest(suggestions) {
  if (!Array.isArray(suggestions)) {
    throw new Error('Invalid argument supplied to suggest, expected an instance of array.');
  }

  var findBestSuggestions = (0, _memoize2.default)(function (str) {
    var propValueWords = str.split(' ');
    return (0, _take2.default)((0, _sortBy2.default)((0, _map2.default)(suggestions, function (suggestion) {
      var suggestionWords = suggestion.split(' ');
      var propValueScore = (0, _sum2.default)((0, _map2.default)((0, _map2.default)(propValueWords, function (x) {
        return (0, _map2.default)(suggestionWords, function (y) {
          return (0, _leven.default)(x, y);
        });
      }), _min2.default));
      var suggestionScore = (0, _sum2.default)((0, _map2.default)((0, _map2.default)(suggestionWords, function (x) {
        return (0, _map2.default)(propValueWords, function (y) {
          return (0, _leven.default)(x, y);
        });
      }), _min2.default));
      return {
        suggestion: suggestion,
        score: propValueScore + suggestionScore
      };
    }), ['score', 'suggestion']), 3);
  }); // Convert the suggestions list into a hash map for O(n) lookup times. Ensure
  // the words in each key are sorted alphabetically so that we have a consistent
  // way of looking up a value in the map, i.e. we can sort the words in the
  // incoming propValue and look that up without having to check all permutations.

  var suggestionsLookup = suggestions.reduce(function (acc, key) {
    acc[key.split(' ').sort().join(' ')] = true;
    return acc;
  }, {});
  return function (props, propName, componentName) {
    var propValue = props[propName]; // skip if prop is undefined or is included in the suggestions

    if (!propValue || suggestionsLookup[propValue]) return undefined; // check if the words were correct but ordered differently.
    // Since we're matching for classNames we need to allow any word order
    // to pass validation, e.g. `left chevron` vs `chevron left`.

    var propValueSorted = propValue.split(' ').sort().join(' ');
    if (suggestionsLookup[propValueSorted]) return undefined; // find best suggestions

    var bestMatches = findBestSuggestions(propValue); // skip if a match scored 0

    if (bestMatches.some(function (x) {
      return x.score === 0;
    })) return undefined;
    return new Error(["Invalid prop `" + propName + "` of value `" + propValue + "` supplied to `" + componentName + "`.", "\n\nInstead of `" + propValue + "`, did you mean:", bestMatches.map(function (x) {
      return "\n  - " + x.suggestion;
    }).join(''), '\n'].join(''));
  };
};
/**
 * The prop cannot be used.
 * Similar to `deprecate` but with different error message.
 */


exports.suggest = suggest;

var never = function never(props, propName, componentName) {
  if ((0, _isNil2.default)(props[propName]) || props[propName] === false) return undefined;
  return new Error("Prop `" + propName + "` in `" + componentName + "` cannot be used.");
};
/**
 * Disallow other props from being defined with this prop.
 * @param disallowedProps - An array of props that cannot be used with this prop.
 */


exports.never = never;

var disallow = function disallow(disallowedProps) {
  return function (props, propName, componentName) {
    if (!Array.isArray(disallowedProps)) {
      throw new Error(['Invalid argument supplied to disallow, expected an instance of array.', " See `" + propName + "` prop in `" + componentName + "`."].join(''));
    } // skip if prop is undefined


    if ((0, _isNil2.default)(props[propName]) || props[propName] === false) return undefined; // find disallowed props with values

    var disallowed = disallowedProps.reduce(function (acc, disallowedProp) {
      if (!(0, _isNil2.default)(props[disallowedProp]) && props[disallowedProp] !== false) {
        return [].concat(acc, [disallowedProp]);
      }

      return acc;
    }, []);

    if (disallowed.length > 0) {
      return new Error(["Prop `" + propName + "` in `" + componentName + "` conflicts with props: `" + disallowed.join('`, `') + "`.", 'They cannot be defined together, choose one or the other.'].join(' '));
    }

    return undefined;
  };
};
/**
 * Ensure a prop adherers to multiple prop type validators.
 * @param validators - An array of propType functions.
 */


exports.disallow = disallow;

var every = function every(validators) {
  return function (props, propName, componentName) {
    for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      args[_key - 3] = arguments[_key];
    }

    if (!Array.isArray(validators)) {
      throw new Error(['Invalid argument supplied to every, expected an instance of array.', "See `" + propName + "` prop in `" + componentName + "`."].join(' '));
    }

    return (0, _first2.default)((0, _compact2.default)((0, _map2.default)(validators, function (validator) {
      if (typeof validator !== 'function') {
        throw new Error("every() argument \"validators\" should contain functions, found: " + typeOf(validator) + ".");
      }

      return validator.apply(void 0, [props, propName, componentName].concat(args));
    }))); // we can only return one error at a time
  };
};
/**
 * Ensure a prop adherers to at least one of the given prop type validators.
 * @param validators - An array of propType functions.
 */


exports.every = every;

var some = function some(validators) {
  return function (props, propName, componentName) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
      args[_key2 - 3] = arguments[_key2];
    }

    if (!Array.isArray(validators)) {
      throw new Error(['Invalid argument supplied to some, expected an instance of array.', "See `" + propName + "` prop in `" + componentName + "`."].join(' '));
    }

    var errors = (0, _compact2.default)((0, _map2.default)(validators, function (validator) {
      if (!(0, _isFunction2.default)(validator)) {
        throw new Error("some() argument \"validators\" should contain functions, found: " + typeOf(validator) + ".");
      }

      return validator.apply(void 0, [props, propName, componentName].concat(args));
    })); // fail only if all validators failed

    if (errors.length === validators.length) {
      var error = new Error('One of these validators must pass:');
      error.message += "\n" + (0, _map2.default)(errors, function (err) {
        return "- " + err.message;
      }).join('\n');
      return error;
    }

    return undefined;
  };
};
/**
 * Ensure a validator passes only when a component has a given propsShape.
 * @param propsShape - An object describing the prop shape.
 * @param validator - A propType function.
 */


exports.some = some;

var givenProps = function givenProps(propsShape, validator) {
  return function (props, propName, componentName) {
    for (var _len3 = arguments.length, args = new Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {
      args[_key3 - 3] = arguments[_key3];
    }

    if (!(0, _isPlainObject2.default)(propsShape)) {
      throw new Error(['Invalid argument supplied to givenProps, expected an object.', "See `" + propName + "` prop in `" + componentName + "`."].join(' '));
    }

    if (typeof validator !== 'function') {
      throw new Error(['Invalid argument supplied to givenProps, expected a function.', "See `" + propName + "` prop in `" + componentName + "`."].join(' '));
    }

    var shouldValidate = (0, _keys2.default)(propsShape).every(function (key) {
      var val = propsShape[key]; // require propShape validators to pass or prop values to match

      return typeof val === 'function' ? !val.apply(void 0, [props, key, componentName].concat(args)) : val === props[propName];
    });
    if (!shouldValidate) return undefined;
    var error = validator.apply(void 0, [props, propName, componentName].concat(args));

    if (error) {
      // poor mans shallow pretty print, prevents JSON circular reference errors
      var prettyProps = "{ " + (0, _keys2.default)((0, _pick2.default)(props, (0, _keys2.default)(propsShape))).map(function (key) {
        var val = props[key];
        var renderedValue = val;
        if (typeof val === 'string') renderedValue = "\"" + val + "\"";else if (Array.isArray(val)) renderedValue = "[" + val.join(', ') + "]";else if ((0, _isObject2.default)(val)) renderedValue = '{...}';
        return key + ": " + renderedValue;
      }).join(', ') + " }";
      error.message = "Given props " + prettyProps + ": " + error.message;
      return error;
    }
  };
};
/**
 * Define prop dependencies by requiring other props.
 * @param requiredProps - An array of required prop names.
 */


exports.givenProps = givenProps;

var demand = function demand(requiredProps) {
  return function (props, propName, componentName) {
    if (!Array.isArray(requiredProps)) {
      throw new Error(['Invalid `requiredProps` argument supplied to require, expected an instance of array.', " See `" + propName + "` prop in `" + componentName + "`."].join(''));
    } // skip if prop is undefined


    if (props[propName] === undefined) return undefined;
    var missingRequired = requiredProps.filter(function (requiredProp) {
      return props[requiredProp] === undefined;
    });

    if (missingRequired.length > 0) {
      return new Error("`" + propName + "` prop in `" + componentName + "` requires props: `" + missingRequired.join('`, `') + "`.");
    }

    return undefined;
  };
};
/**
 * Ensure an multiple prop contains a string with only possible values.
 * @param possible - An array of possible values to prop.
 */


exports.demand = demand;

var multipleProp = function multipleProp(possible) {
  return function (props, propName, componentName) {
    if (!Array.isArray(possible)) {
      throw new Error(['Invalid argument supplied to some, expected an instance of array.', "See `" + propName + "` prop in `" + componentName + "`."].join(' '));
    }

    var propValue = props[propName]; // skip if prop is undefined

    if ((0, _isNil2.default)(propValue) || propValue === false) return undefined;
    var values = propValue.replace('large screen', 'large-screen').replace(/ vertically/g, '-vertically').split(' ').map(function (val) {
      return (0, _trim2.default)(val).replace('-', ' ');
    });
    var invalid = (0, _difference2.default)(values, possible); // fail only if there are invalid values

    if (invalid.length > 0) {
      return new Error("`" + propName + "` prop in `" + componentName + "` has invalid values: `" + invalid.join('`, `') + "`.");
    }

    return undefined;
  };
};
/**
 * Ensure a component can render as a node passed as a prop value in place of children.
 */


exports.multipleProp = multipleProp;
var nodeContent = every([disallow(['children']), PropTypes.node]);
exports.nodeContent = nodeContent;
var wrapperShorthand = PropTypes.oneOfType([PropTypes.node, PropTypes.object, PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.node, PropTypes.object]))]);
/**
 * A shorthand prop which can be used together with `children`.
 */

exports.wrapperShorthand = wrapperShorthand;
var shorthandAllowingChildren = PropTypes.oneOfType([PropTypes.node, PropTypes.object, PropTypes.func]);
exports.shorthandAllowingChildren = shorthandAllowingChildren;
var shorthandObjectAllowingChildren = PropTypes.oneOfType([PropTypes.object, PropTypes.func]);
/**
 * ObjectItemShorthand is a description of a component that can be
 * a props object or a render function.
 */

exports.shorthandObjectAllowingChildren = shorthandObjectAllowingChildren;
var objectItemShorthand = every([disallow(['children']), shorthandAllowingChildren]);
/**
 * Item shorthand is a description of a component that can be a literal,
 * a props object, an element or a render function.
 */

exports.objectItemShorthand = objectItemShorthand;
var itemShorthand = every([disallow(['children']), shorthandAllowingChildren]);
exports.itemShorthand = itemShorthand;

var itemShorthandWithKindProp = function itemShorthandWithKindProp(kindPropValues) {
  return every([disallow(['children']), PropTypes.oneOfType([PropTypes.node, PropTypes.shape({
    kind: PropTypes.oneOf(kindPropValues)
  }), PropTypes.func])]);
};

exports.itemShorthandWithKindProp = itemShorthandWithKindProp;
var itemShorthandWithoutJSX = every([disallow(['children']), PropTypes.oneOfType([PropTypes.func, PropTypes.number, PropTypes.object, PropTypes.string, PropTypes.oneOf([false])])]);
/**
 * Collection shorthand ensures a prop is an array of item shorthand.
 */

exports.itemShorthandWithoutJSX = itemShorthandWithoutJSX;
var collectionObjectShorthand = every([disallow(['children']), PropTypes.arrayOf(objectItemShorthand)]);
/**
 * Collection shorthand ensures a prop is an array of item shorthand.
 */

exports.collectionObjectShorthand = collectionObjectShorthand;
var collectionShorthand = every([disallow(['children']), PropTypes.arrayOf(itemShorthand)]);
exports.collectionShorthand = collectionShorthand;

var collectionShorthandWithKindProp = function collectionShorthandWithKindProp(kindPropValues) {
  return every([disallow(['children']), PropTypes.arrayOf(itemShorthandWithKindProp(kindPropValues))]);
};
/**
 * Show a deprecated warning for component props with a help message and optional validator.
 * @param help - A help message to display with the deprecation warning.
 * @param validator - A propType function.
 */


exports.collectionShorthandWithKindProp = collectionShorthandWithKindProp;

var deprecate = function deprecate(help, validator) {
  return function (props, propName, componentName) {
    if (typeof help !== 'string') {
      throw new Error(['Invalid `help` argument supplied to deprecate, expected a string.', "See `" + propName + "` prop in `" + componentName + "`."].join(' '));
    } // skip if prop is undefined


    if (props[propName] === undefined) return undefined; // deprecation error and help

    var error = new Error("The `" + propName + "` prop in `" + componentName + "` is deprecated.");
    if (help) error.message += " " + help; // add optional validation error message

    if (validator) {
      if (typeof validator === 'function') {
        for (var _len4 = arguments.length, args = new Array(_len4 > 3 ? _len4 - 3 : 0), _key4 = 3; _key4 < _len4; _key4++) {
          args[_key4 - 3] = arguments[_key4];
        }

        var validationError = validator.apply(void 0, [props, propName, componentName].concat(args));

        if (validationError) {
          error.message = error.message + " " + validationError.message;
        }
      } else {
        throw new Error(['Invalid argument supplied to deprecate, expected a function.', "See `" + propName + "` prop in `" + componentName + "`."].join(' '));
      }
    }

    return error;
  };
};

exports.deprecate = deprecate;
var accessibility = PropTypes.func;
exports.accessibility = accessibility;
var size = PropTypes.oneOf(['smallest', 'smaller', 'small', 'medium', 'large', 'larger', 'largest']);
exports.size = size;
var align = PropTypes.oneOf(['start', 'end', 'center', 'justify']);
exports.align = align;
var animation = PropTypes.oneOfType([// Validator is broken in the latest @react/types
PropTypes.shape({
  name: PropTypes.string.isRequired,
  delay: PropTypes.string,
  direction: PropTypes.string,
  duration: PropTypes.string,
  fillMode: PropTypes.string,
  iterationCount: PropTypes.string,
  playState: PropTypes.string,
  timingFunction: PropTypes.string
}), PropTypes.string]); // Heads Up!
// Keep in sync with packages/react/src/themes/types.ts

exports.animation = animation;
var design = PropTypes.shape({
  position: PropTypes.string,
  display: PropTypes.string,
  top: PropTypes.string,
  right: PropTypes.string,
  bottom: PropTypes.string,
  left: PropTypes.string,
  padding: PropTypes.string,
  paddingTop: PropTypes.string,
  paddingRight: PropTypes.string,
  paddingBottom: PropTypes.string,
  paddingLeft: PropTypes.string,
  margin: PropTypes.string,
  marginTop: PropTypes.string,
  marginRight: PropTypes.string,
  marginBottom: PropTypes.string,
  marginLeft: PropTypes.string,
  width: PropTypes.string,
  height: PropTypes.string,
  minWidth: PropTypes.string,
  maxWidth: PropTypes.string,
  minHeight: PropTypes.string,
  maxHeight: PropTypes.string
});
/** A checker that matches the React.Ref type. */

exports.design = design;
var ref = PropTypes.oneOfType([PropTypes.func, PropTypes.object]);
exports.ref = ref;
//# sourceMappingURL=index.js.map
