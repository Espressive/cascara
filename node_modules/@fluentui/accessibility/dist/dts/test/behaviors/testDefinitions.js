"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.definitions = void 0;
var tslib_1 = require("tslib");
var accessibility_1 = require("@fluentui/accessibility");
var testHelper_1 = require("./testHelper");
exports.definitions = [];
var testHelper = new testHelper_1.TestHelper();
var keysAndAliases = tslib_1.__assign(tslib_1.__assign({}, accessibility_1.keyboardKey), { Spacebar: accessibility_1.SpacebarKey });
// Example:  Adds attribute 'aria-pressed=true' based on the property 'active'
exports.definitions.push({
    regexp: /Adds attribute '([\w-]+)=(\w+)' based on the property '(\w+)'\./g,
    testMethod: function (parameters) {
        var _a = parameters.props, attributeToBeAdded = _a[0], attributeExpectedValue = _a[1], propertyDependingOn = _a[2];
        var property = {};
        property[propertyDependingOn] = attributeExpectedValue;
        var expectedResult = parameters.behavior(property).attributes.root[attributeToBeAdded];
        expect(testHelper.convertToMatchingTypeIfApplicable(expectedResult)).toEqual(testHelper.convertToMatchingTypeIfApplicable(attributeExpectedValue));
    },
});
// Example:  Adds role='listbox'.
exports.definitions.push({
    regexp: /Adds role='(\w+)'\./g,
    testMethod: function (parameters) {
        var roleToBeAdded = tslib_1.__spreadArrays(parameters.props)[0];
        var property = {};
        var expectedResult = parameters.behavior(property).attributes.root['role'];
        expect(expectedResult).toEqual(roleToBeAdded);
    },
});
// Example:  Adds role 'menuitem' to 'anchor' slot
exports.definitions.push({
    regexp: /Adds role '(\w+)' to '([\w-]+)' slot/g,
    testMethod: function (parameters) {
        var _a = parameters.props, roleToBeAdded = _a[0], elementWhereToBeAdded = _a[1];
        var property = {};
        var expectedResult = parameters.behavior(property).attributes[elementWhereToBeAdded]['role'];
        expect(expectedResult).toEqual(roleToBeAdded);
    },
});
// Example: Adds attribute 'tabIndex=0' to 'anchor' slot.
//          Adds attribute 'data-is-focusable=true' to 'anchor' slot.
exports.definitions.push({
    regexp: /Adds attribute '([\w-]+)=([\w\-d]+)' to '([\w-]+)' slot\./g,
    testMethod: function (parameters) {
        var _a = parameters.props, attributeToBeAdded = _a[0], attributeExpectedValue = _a[1], elementWhereToBeAdded = _a[2];
        var property = {};
        var expectedResult = parameters.behavior(property).attributes[elementWhereToBeAdded][attributeToBeAdded];
        expect(testHelper.convertToMatchingTypeIfApplicable(expectedResult)).toEqual(testHelper.convertToMatchingTypeIfApplicable(attributeExpectedValue));
    },
});
// Example: Adds attribute 'aria-expanded=true' based on the property 'menuOpen' if the component has 'menu' property to 'anchor' slot.
exports.definitions.push({
    regexp: /Adds attribute '([\w-]+)=([\w\d]+)' based on the property '([\w-]+)' if the component has '([\w-]+)' property to '([\w-]+)' slot\./g,
    testMethod: function (parameters) {
        var _a = parameters.props, attributeToBeAdded = _a[0], attributeExpectedValue = _a[1], propertyBasedOn = _a[2], propertyDependingOn = _a[3], elementWhereToBeAdded = _a[4];
        var property = {};
        property[propertyDependingOn] = [{}, {}];
        property[propertyBasedOn] = true;
        var expectedResult = parameters.behavior(property).attributes[elementWhereToBeAdded][attributeToBeAdded];
        expect(expectedResult).toEqual(testHelper.convertToMatchingTypeIfApplicable(attributeExpectedValue));
        // when property depending on is undefined, then there should not be 'aria' attribute added
        var propertyDependingOnValue = undefined;
        property[propertyDependingOn] = propertyDependingOnValue;
        var expectedResultDependingPropertyUndefined = parameters.behavior(property).attributes[elementWhereToBeAdded][attributeToBeAdded];
        expect(expectedResultDependingPropertyUndefined).toEqual(propertyDependingOnValue);
        // when property based on is undefined, then there should 'aria' attribute get false value
        property[propertyDependingOn] = [{}, {}];
        property[propertyBasedOn] = undefined;
        var expectedResultBasedOnPropertyUndefined = parameters.behavior(property).attributes[elementWhereToBeAdded][attributeToBeAdded];
        expect(expectedResultBasedOnPropertyUndefined).toEqual(false);
    },
});
// Example: Adds attribute 'aria-expanded=true' based on the property 'active' to 'button' slot.
//          Adds attribute 'aria-label' based on the property 'aria-label' to 'anchor' slot.
exports.definitions.push({
    regexp: /Adds attribute '([\w-]+)=*([\w-]*)' based on the property '([\w-]+)' to '([\w-]+)' slot\./g,
    testMethod: function (parameters) {
        var _a = parameters.props, attributeToBeAdded = _a[0], attibuteValue = _a[1], propertyDependingOn = _a[2], elementWhereToBeAdded = _a[3];
        var property = {};
        var propertyDependingOnValue = attibuteValue || 'value of property';
        property[propertyDependingOn] = propertyDependingOnValue;
        var expectedResult = parameters.behavior(property).attributes[elementWhereToBeAdded][attributeToBeAdded];
        expect(testHelper.convertToMatchingTypeIfApplicable(expectedResult)).toEqual(testHelper.convertToMatchingTypeIfApplicable(propertyDependingOnValue));
    },
});
// Example: Adds attribute 'aria-selected=true' to 'anchor' slot based on the property 'active'. This can be overriden by directly providing 'aria-selected' property to the component.
exports.definitions.push({
    regexp: /Adds attribute '([\w-]+)=([\w\d]+)' to '([\w-]+)' slot based on the property '([\w-]+)'\. This can be overriden by providing '[\w-]+' property directly to the component\./g,
    testMethod: function (parameters) {
        var _a, _b;
        var _c = parameters.props, attributeToBeAdded = _c[0], valueOfAttributeToBeAdded = _c[1], component = _c[2], propertyBasedOn = _c[3], overridingProperty = _c[4];
        var propertyWithOverride = (_a = {}, _a[overridingProperty] = valueOfAttributeToBeAdded, _a);
        var propertyWithoutOverride = (_b = {}, _b[propertyBasedOn] = valueOfAttributeToBeAdded, _b);
        var expectedResultPropOveride = parameters.behavior(propertyWithOverride).attributes[component][attributeToBeAdded];
        var expectedResultPropBasedOn = parameters.behavior(propertyWithoutOverride).attributes[component][attributeToBeAdded];
        expect(testHelper.convertToMatchingTypeIfApplicable(expectedResultPropOveride)).toEqual(testHelper.convertToMatchingTypeIfApplicable(valueOfAttributeToBeAdded));
        expect(testHelper.convertToMatchingTypeIfApplicable(expectedResultPropBasedOn)).toEqual(testHelper.convertToMatchingTypeIfApplicable(valueOfAttributeToBeAdded));
    },
});
// Example: Adds attribute 'aria-disabled=true' based on the property 'disabled'. This can be overriden by providing 'aria-disabled' property directly to the component.
exports.definitions.push({
    regexp: /Adds attribute '([\w-]+)=([\w\d]+)' based on the property '([\w-]+)'\. This can be overriden by providing '[\w-]+' property directly to the component\./g,
    testMethod: function (parameters) {
        var _a = parameters.props, attributeToBeAdded = _a[0], valueOfAttributeToBeAdded = _a[1], overridingProperty = _a[2];
        var propertyWithOverride = {};
        propertyWithOverride[overridingProperty] = valueOfAttributeToBeAdded;
        var expectedResultAttributeDefined = parameters.behavior(propertyWithOverride).attributes.root[attributeToBeAdded];
        expect(testHelper.convertToMatchingTypeIfApplicable(expectedResultAttributeDefined)).toEqual(testHelper.convertToMatchingTypeIfApplicable(valueOfAttributeToBeAdded));
    },
});
function testMethodConditionallyAddAttribute(parameters, component, propertyDependsOn, valueOfProperty, valueOfPropertyOtherwise, attributeToBeAdded, valueOfAttributeToBeAddedIfTrue, valueOfAttributeToBeAddedOtherwise) {
    var propertyWithAriaSelected = {};
    propertyWithAriaSelected[propertyDependsOn] = valueOfPropertyOtherwise;
    var expectedResultAttributeNotDefined = parameters.behavior(propertyWithAriaSelected).attributes[component][attributeToBeAdded];
    expect(testHelper.convertToMatchingTypeIfApplicable(expectedResultAttributeNotDefined)).toEqual(testHelper.convertToMatchingTypeIfApplicable(valueOfAttributeToBeAddedOtherwise));
    propertyWithAriaSelected[propertyDependsOn] = valueOfProperty;
    var expectedResultAttributeDefined = parameters.behavior(propertyWithAriaSelected).attributes[component][attributeToBeAdded];
    expect(testHelper.convertToMatchingTypeIfApplicable(expectedResultAttributeDefined)).toEqual(testHelper.convertToMatchingTypeIfApplicable(valueOfAttributeToBeAddedIfTrue));
}
// Example: Adds attribute 'aria-disabled=true' to 'trigger' slot if 'disabled' property is true. Does not set the attribute otherwise.
exports.definitions.push({
    regexp: /Adds attribute '([\w-]+)=([\w\d-]+)' to '([\w-]+)' slot if '([\w-]+)' property is true\. Does not set the attribute otherwise\./g,
    testMethod: function (parameters) {
        var _a = parameters.props, attributeToBeAdded = _a[0], valueOfAttributeToBeAdded = _a[1], component = _a[2], propertyDependsOn = _a[3];
        testMethodConditionallyAddAttribute(parameters, component, propertyDependsOn, true, undefined, attributeToBeAdded, valueOfAttributeToBeAdded, undefined);
    },
});
// Example: Adds attribute 'aria-disabled=true' to 'trigger' slot if 'disabled' property is false or undefined. Does not set the attribute if true.
exports.definitions.push({
    regexp: /Adds attribute '([\w-]+)=([\w\d-]+)' to '([\w-]+)' slot if '([\w-]+)' property is false or undefined\. Does not set the attribute if true\./g,
    testMethod: function (parameters) {
        var _a = parameters.props, attributeToBeAdded = _a[0], valueOfAttributeToBeAdded = _a[1], component = _a[2], propertyDependsOn = _a[3];
        testMethodConditionallyAddAttribute(parameters, component, propertyDependsOn, undefined, true, attributeToBeAdded, valueOfAttributeToBeAdded, undefined);
    },
});
// Example: Adds attribute 'aria-disabled=true' to 'trigger' slot if 'disabled' property is true. Sets the attribute to 'false' otherwise.
exports.definitions.push({
    regexp: /Adds attribute '([\w-]+)=([\w\d]+)' to '([\w-]+)' slot if '([\w-]+)' property is true\. Sets the attribute to '([\w\d-]+)' otherwise\./g,
    testMethod: function (parameters) {
        var _a = parameters.props, attributeToBeAdded = _a[0], valueOfAttributeToBeAddedIfTrue = _a[1], component = _a[2], propertyDependsOn = _a[3], valueOfAttributeToBeAddedOtherwise = _a[4];
        testMethodConditionallyAddAttribute(parameters, component, propertyDependsOn, true, undefined, attributeToBeAdded, valueOfAttributeToBeAddedIfTrue, valueOfAttributeToBeAddedOtherwise);
    },
});
// Adds attribute 'aria-haspopup=true' to 'root' slot if 'menu' property is set.
exports.definitions.push({
    regexp: /Adds attribute '([\w-]+)=([\w\d]+)' to '([\w-]+)' slot if '([\w-]+)' property is set\./g,
    testMethod: function (parameters) {
        var _a = parameters.props, attributeToBeAdded = _a[0], valueOfAttributeToBeAddedIfTrue = _a[1], component = _a[2], propertyDependsOn = _a[3], valueOfAttributeToBeAddedOtherwise = _a[4];
        testMethodConditionallyAddAttribute(parameters, component, propertyDependsOn, 'custom-value', undefined, attributeToBeAdded, valueOfAttributeToBeAddedIfTrue, valueOfAttributeToBeAddedOtherwise);
    },
});
// Adds attribute 'aria-haspopup=true' to 'trigger' slot if 'contextMenu' property is not set.
exports.definitions.push({
    regexp: /Adds attribute '([\w-]+)=([\w\d]+)' to '([\w-]+)' slot if '([\w-]+)' property is not set\./g,
    testMethod: function (parameters) {
        var _a, _b;
        var _c = parameters.props, attributeToBeAdded = _c[0], valueOfAttributeToBeAdded = _c[1], slot = _c[2], propertyDependsOn = _c[3];
        var propertyDependsOnUndefined = {};
        var expectedResultAttributeNotDefined = parameters.behavior(propertyDependsOnUndefined).attributes[slot][attributeToBeAdded];
        expect(testHelper.convertToMatchingTypeIfApplicable(expectedResultAttributeNotDefined)).toEqual(testHelper.convertToMatchingTypeIfApplicable(valueOfAttributeToBeAdded));
        var propertyDependsOnFalse = (_a = {},
            _a[propertyDependsOn] = false,
            _a);
        var expectedResultAttributeDefinedFalse = parameters.behavior(propertyDependsOnFalse).attributes[slot][attributeToBeAdded];
        expect(testHelper.convertToMatchingTypeIfApplicable(expectedResultAttributeDefinedFalse)).toEqual(testHelper.convertToMatchingTypeIfApplicable(valueOfAttributeToBeAdded));
        var propertyDependsOnExists = (_b = {},
            _b[propertyDependsOn] = true,
            _b);
        var expectedResultAttributeDefined = parameters.behavior(propertyDependsOnExists).attributes[slot][attributeToBeAdded];
        expect(testHelper.convertToMatchingTypeIfApplicable(expectedResultAttributeDefined)).toEqual(undefined);
    },
});
// Example: Adds attribute 'aria-hidden=true', if there is no 'alt' property provided.
exports.definitions.push({
    regexp: /Adds attribute '([\w-]+)=(\w+)', if there is no '([\w-]+)' property provided\./g,
    testMethod: function (parameters) {
        var _a;
        var _b = parameters.props, attributeToBeAdded = _b[0], attributeExpectedValue = _b[1], propertyDependingOn = _b[2];
        var property = {};
        var expectedResult = parameters.behavior(property).attributes.root[attributeToBeAdded];
        expect(testHelper.convertToMatchingTypeIfApplicable(expectedResult)).toBe(testHelper.convertToMatchingTypeIfApplicable(attributeExpectedValue));
        var dependingOnProperty = (_a = {}, _a[propertyDependingOn] = 'mockText', _a);
        var expectedResultForPropertyDependingOn = parameters.behavior(dependingOnProperty).attributes.root[attributeToBeAdded];
        expect(testHelper.convertToMatchingTypeIfApplicable(expectedResultForPropertyDependingOn)).toBe(testHelper.convertToMatchingTypeIfApplicable(undefined));
    },
});
// Example:  Adds attribute 'aria-expanded=true' based on the property 'open' if the component has 'hasSubtree' property false or undefined. Does not set anything if true.
exports.definitions.push({
    regexp: /Adds attribute '([\w-]+)=(\w+)' based on the property '(\w+)' if the component has '(\w+)' property false or undefined. Does not set anything if true\./g,
    testMethod: function (parameters) {
        var _a = parameters.props, attributeToBeAdded = _a[0], attributeExpectedValue = _a[1], propertyDependingOnFirst = _a[2], propertyDependingOnSecond = _a[3];
        var property = {};
        property[propertyDependingOnFirst] = attributeExpectedValue;
        property[propertyDependingOnSecond] = false;
        var actualResultIfFalse = parameters.behavior(property).attributes.root[attributeToBeAdded];
        expect(testHelper.convertToMatchingTypeIfApplicable(actualResultIfFalse)).toEqual(testHelper.convertToMatchingTypeIfApplicable(attributeExpectedValue));
        property[propertyDependingOnSecond] = undefined;
        var actualResultIfUndefined = parameters.behavior(property).attributes.root[attributeToBeAdded];
        expect(testHelper.convertToMatchingTypeIfApplicable(actualResultIfUndefined)).toEqual(testHelper.convertToMatchingTypeIfApplicable(attributeExpectedValue));
        var propertyFirstPropUndefined = {};
        propertyFirstPropUndefined[propertyDependingOnSecond] = true;
        var actualResultFirstPropertyNegateUndefined = parameters.behavior(propertyFirstPropUndefined).attributes.root[attributeToBeAdded];
        expect(testHelper.convertToMatchingTypeIfApplicable(actualResultFirstPropertyNegateUndefined)).toEqual(undefined);
    },
});
// Example:  Adds attribute 'aria-expanded=true' based on the property 'open' if the component has 'hasSubtree' property.
exports.definitions.push({
    regexp: /Adds attribute '([\w-]+)=(\w+)' based on the property '(\w+)' if the component has '(\w+)' property\./g,
    testMethod: function (parameters) {
        var _a = parameters.props, attributeToBeAdded = _a[0], attributeExpectedValue = _a[1], propertyDependingOnFirst = _a[2], propertyDependingOnSecond = _a[3];
        var property = {};
        property[propertyDependingOnFirst] = attributeExpectedValue;
        property[propertyDependingOnSecond] = true;
        var actualResult = parameters.behavior(property).attributes.root[attributeToBeAdded];
        expect(testHelper.convertToMatchingTypeIfApplicable(actualResult)).toEqual(testHelper.convertToMatchingTypeIfApplicable(attributeExpectedValue));
        if (typeof testHelper.convertToMatchingTypeIfApplicable(attributeExpectedValue) === 'boolean') {
            var propertyFirstPropNegate = {};
            propertyFirstPropNegate[propertyDependingOnFirst] = !testHelper.convertToMatchingTypeIfApplicable(attributeExpectedValue);
            propertyFirstPropNegate[propertyDependingOnSecond] = true;
            var actualResultFirstPropertyNegate = parameters.behavior(propertyFirstPropNegate).attributes.root[attributeToBeAdded];
            expect(testHelper.convertToMatchingTypeIfApplicable(actualResultFirstPropertyNegate)).toEqual(!testHelper.convertToMatchingTypeIfApplicable(attributeExpectedValue));
        }
        var propertyFirstPropUndefined = {};
        propertyFirstPropUndefined[propertyDependingOnFirst] = true;
        propertyFirstPropUndefined[propertyDependingOnSecond] = undefined;
        var actualResultFirstPropertyNegateUndefined = parameters.behavior(propertyFirstPropUndefined).attributes.root[attributeToBeAdded];
        expect(testHelper.convertToMatchingTypeIfApplicable(actualResultFirstPropertyNegateUndefined)).toEqual(undefined);
    },
});
// Example: Adds role='button' if element type is other than 'button'.
exports.definitions.push({
    regexp: /Adds role='(\w+)' if element type is other than '(\w+)'\./g,
    testMethod: function (parameters) {
        var _a = parameters.props, roleToBeAdded = _a[0], as = _a[1];
        var property = {};
        var expectedResult = parameters.behavior(property).attributes.root.role;
        expect(testHelper.convertToMatchingTypeIfApplicable(expectedResult)).toBe(testHelper.convertToMatchingTypeIfApplicable(roleToBeAdded));
        var propertyAsButton = { as: as };
        var expectedResultAsButton = parameters.behavior(propertyAsButton).attributes.root.role;
        expect(testHelper.convertToMatchingTypeIfApplicable(expectedResultAsButton)).toBe(testHelper.convertToMatchingTypeIfApplicable(undefined));
    },
});
// Example: Adds attribute 'tabIndex=0' if element type is other than 'button'.
exports.definitions.push({
    regexp: /Adds attribute '([\w-]+)=([\w\d]+)' if element type is other than '(\w+)'\./g,
    testMethod: function (parameters) {
        var _a = parameters.props, attributeToBeAdded = _a[0], attributeExpectedValue = _a[1], as = _a[2];
        var property = {};
        var expectedResult = parameters.behavior(property).attributes.root[attributeToBeAdded];
        expect(testHelper.convertToMatchingTypeIfApplicable(expectedResult)).toBe(testHelper.convertToMatchingTypeIfApplicable(attributeExpectedValue));
        var propertyAsButton = { as: as };
        var expectedResultAsButton = parameters.behavior(propertyAsButton).attributes.root[attributeToBeAdded];
        expect(testHelper.convertToMatchingTypeIfApplicable(expectedResultAsButton)).toBe(testHelper.convertToMatchingTypeIfApplicable(undefined));
    },
});
// Example: Applies 'gridRowBehavior' for 'row' child component.
exports.definitions.push({
    regexp: /Applies '(\w+)' for '(\w+)' child component\./g,
    testMethod: function (parameters) {
        var _a = parameters.props, behaviorToBeUsed = _a[0], childComponent = _a[1];
        var property = {};
        var expectedResult = parameters.behavior(property).childBehaviors[childComponent];
        expect(expectedResult.name).toBe(behaviorToBeUsed);
    },
});
/*
 * ********************** FOCUS ZONE **********************
 */
exports.definitions.push({
    regexp: /arrow key navigation in horizontal direction/g,
    testMethod: function (parameters) {
        var actualFocusZoneHorizontal = parameters.behavior({}).focusZone;
        expect(actualFocusZoneHorizontal.props.direction).toBe(accessibility_1.FocusZoneDirection.horizontal);
    },
});
exports.definitions.push({
    regexp: /arrow key navigation in vertical direction/g,
    testMethod: function (parameters) {
        var actualFocusZoneHorizontal = parameters.behavior({}).focusZone;
        expect(actualFocusZoneHorizontal.props.direction).toBe(accessibility_1.FocusZoneDirection.vertical);
    },
});
exports.definitions.push({
    regexp: /arrow key navigation in bidirectional direction/g,
    testMethod: function (parameters) {
        var actualFocusZoneHorizontal = parameters.behavior({}).focusZone;
        expect(actualFocusZoneHorizontal.props.direction).toBe(accessibility_1.FocusZoneDirection.bidirectional);
    },
});
exports.definitions.push({
    regexp: /arrow key navigation in bidirectionalDomOrder direction/g,
    testMethod: function (parameters) {
        var actualFocusZoneHorizontal = parameters.behavior({}).focusZone;
        expect(actualFocusZoneHorizontal.props.direction).toBe(accessibility_1.FocusZoneDirection.bidirectionalDomOrder);
    },
});
exports.definitions.push({
    regexp: /Keyboard navigation is circular/g,
    testMethod: function (parameters) {
        var actualFocusZone = parameters.behavior({}).focusZone;
        expect(actualFocusZone.props.isCircularNavigation).toBe(true);
    },
});
// for e.g If 'vertical' prop is used, provides keyboard navigation in vertical direction.
exports.definitions.push({
    regexp: /.'vertical' prop is used.*vertical direction/g,
    testMethod: function (parameters) {
        var actualFocusZoneVertical = parameters.behavior({ vertical: true }).focusZone;
        expect(actualFocusZoneVertical.props.direction).toBe(accessibility_1.FocusZoneDirection.vertical);
    },
});
exports.definitions.push({
    regexp: /Focused active element of the component is reset when TAB from the component/g,
    testMethod: function (parameters) {
        var actualFocusZoneHorizontal = parameters.behavior({}).focusZone;
        expect(actualFocusZoneHorizontal.props.shouldResetActiveElementWhenTabFromZone).toBe(true);
    },
});
exports.definitions.push({
    regexp: /Focus is set initially on the specified default tabbable element/g,
    testMethod: function (parameters) {
        var actualFocusZoneHorizontal = parameters.behavior({}).focusZone;
        expect(actualFocusZoneHorizontal.props.defaultTabbableElement).toBeTruthy();
    },
});
exports.definitions.push({
    regexp: /Focus can be moved inside a child component with embeded inner FocusZone by pressing a specified key/g,
    testMethod: function (parameters) {
        var actualFocusZoneHorizontal = parameters.behavior({}).focusZone;
        expect(actualFocusZoneHorizontal.props.shouldEnterInnerZone).toBeTruthy();
    },
});
exports.definitions.push({
    regexp: /Does not handle PageDown and PageUp/g,
    testMethod: function (parameters) {
        var actualFocusZoneHorizontal = parameters.behavior({}).focusZone;
        expect(actualFocusZoneHorizontal.props.pagingSupportDisabled).toBeTruthy();
    },
});
exports.definitions.push({
    regexp: /Focus is moved within the focusable children of the component using TAB key/g,
    testMethod: function (parameters) {
        var actualFocusZoneHorizontal = parameters.behavior({}).focusZone;
        expect(actualFocusZoneHorizontal.props.handleTabKey).toBe(accessibility_1.FocusZoneTabbableElements.all);
    },
});
exports.definitions.push({
    regexp: /Component will get focus when mounted/g,
    testMethod: function (parameters) {
        var actualFocusZoneHorizontal = parameters.behavior({}).focusZone;
        expect(actualFocusZoneHorizontal.props.shouldFocusOnMount).toBe(true);
    },
});
// for e.g. When component's container element receives focus, focus will be set to the default focusable child element of the component.
exports.definitions.push({
    regexp: /.container element receives focus.*focus .*set .*default focusable child element/g,
    testMethod: function (parameters) {
        var actualFocusZoneHorizontal = parameters.behavior({}).focusZone;
        expect(actualFocusZoneHorizontal.props.shouldFocusInnerElementWhenReceivedFocus).toBe(true);
    },
});
// Triggers 'click' action with 'Enter' or 'Spacebar' on 'root'.
exports.definitions.push({
    regexp: /Triggers '(\w+)' action with '(\S+)' or '(\S+)' on '(\w+)'\./g,
    testMethod: function (parameters) {
        var _a = tslib_1.__spreadArrays(parameters.props), action = _a[0], firstKey = _a[1], secondKey = _a[2], elementToPerformAction = _a[3];
        var property = {};
        var expectedFirstKeyNumber = parameters.behavior(property).keyActions[elementToPerformAction][action]
            .keyCombinations[0].keyCode;
        var expectedSecondKeyNumber = parameters.behavior(property).keyActions[elementToPerformAction][action]
            .keyCombinations[1].keyCode;
        expect(expectedFirstKeyNumber).toBe(keysAndAliases[firstKey]);
        expect(expectedSecondKeyNumber).toBe(keysAndAliases[secondKey]);
    },
});
// Triggers 'closeAllMenus' action with 'Escape' on 'root'.
exports.definitions.push({
    regexp: /Triggers '(\w+)' action with '(\S+)' on '(\w+)'\./g,
    testMethod: function (parameters) {
        var _a = tslib_1.__spreadArrays(parameters.props), action = _a[0], key = _a[1], elementToPerformAction = _a[2];
        var property = {};
        var expectedKeyNumber = parameters.behavior(property).keyActions[elementToPerformAction][action]
            .keyCombinations[0].keyCode;
        expect(expectedKeyNumber).toBe(keysAndAliases[key]);
    },
});
// Triggers 'unsetRowTabbable' action using 'shiftKey' + 'Tab' key on 'root'.
exports.definitions.push({
    regexp: /Triggers '(\w+)' action using '(\w+)' \+ '(\w+)' key on '(\w+)'\./g,
    testMethod: function (parameters) {
        var _a = tslib_1.__spreadArrays(parameters.props), action = _a[0], keyModifier = _a[1], key = _a[2], elementToPerformAction = _a[3];
        var property = {};
        var keyCombinations = parameters.behavior(property).keyActions[elementToPerformAction][action].keyCombinations[0];
        expect(keyCombinations.keyCode).toBe(keysAndAliases[key]);
        expect(keyCombinations[keyModifier]).toBe(true);
    },
});
// Triggers 'openMenu' action with 'ArrowDown' on 'root', when orientaton is horizontal.
exports.definitions.push({
    regexp: /Triggers '(\w+)' action with '(\w+)' on '([\w-]+)', when orientation is horizontal\./g,
    testMethod: function (parameters) {
        var _a = tslib_1.__spreadArrays(parameters.props), action = _a[0], key = _a[1], elementToPerformAction = _a[2];
        var property = {};
        var expectedKeyNumber = parameters.behavior(property).keyActions[elementToPerformAction][action]
            .keyCombinations[0].keyCode;
        expect(expectedKeyNumber).toBe(keysAndAliases[key]);
    },
});
// Triggers 'openMenu' action with 'ArrowRight' on 'root', when orientation is vertical.
exports.definitions.push({
    regexp: /Triggers '(\w+)' action with '(\w+)' on '([\w-]+)', when orientation is vertical\./g,
    testMethod: function (parameters) {
        var _a = tslib_1.__spreadArrays(parameters.props), action = _a[0], key = _a[1], elementToPerformAction = _a[2];
        var propertyVertical = { vertical: true };
        var expectedKeyNumberVertical = parameters.behavior(propertyVertical).keyActions[elementToPerformAction][action]
            .keyCombinations[0].keyCode;
        expect(expectedKeyNumberVertical).toBe(keysAndAliases[key]);
    },
});
// Triggers the 'openMenu' action with 'ArrowDown' on 'root', when orientaton is horizontal.
exports.definitions.push({
    regexp: /Triggers the '(\w+)' action with '(\w+)' on '([\w-]+)', when orientation is horizontal\./g,
    testMethod: function (parameters) {
        var _a = tslib_1.__spreadArrays(parameters.props), action = _a[0], key = _a[1], elementToPerformAction = _a[2];
        var propertyHorizontal = { horizontal: true };
        var expectedKeyNumber = parameters.behavior(propertyHorizontal).keyActions[elementToPerformAction][action]
            .keyCombinations[0].keyCode;
        expect(expectedKeyNumber).toBe(keysAndAliases[key]);
    },
});
// Triggers the 'openMenu' action with 'ArrowRight' on 'root', when orientation is vertical.
exports.definitions.push({
    regexp: /Triggers the '(\w+)' action with '(\w+)' on '([\w-]+)', when orientation is vertical\./g,
    testMethod: function (parameters) {
        var _a = tslib_1.__spreadArrays(parameters.props), action = _a[0], key = _a[1], elementToPerformAction = _a[2];
        var propertyHorizontal = { horizontal: false };
        var expectedKeyNumberVertical = parameters.behavior(propertyHorizontal).keyActions[elementToPerformAction][action]
            .keyCombinations[0].keyCode;
        expect(expectedKeyNumberVertical).toBe(keysAndAliases[key]);
    },
});
// Triggers 'receiveFocus' action with 'ArrowLeft' on 'root', when has an opened subtree.
exports.definitions.push({
    regexp: /Triggers '(\w+)' action with '(\w+)' on '([\w-]+)', when has an opened subtree\./g,
    testMethod: function (parameters) {
        var _a = tslib_1.__spreadArrays(parameters.props), action = _a[0], key = _a[1], elementToPerformAction = _a[2];
        var propertyOpenedSubtree = {
            open: true,
            expanded: true,
            hasItems: true,
            siblings: [],
            hasSubtree: true,
        };
        var expectedKeyNumberVertical = parameters.behavior(propertyOpenedSubtree).keyActions[elementToPerformAction][action].keyCombinations[0].keyCode;
        expect(expectedKeyNumberVertical).toBe(keysAndAliases[key]);
    },
});
// Triggers 'focusParent' action with 'ArrowLeft' on 'root', when has no subtree.
exports.definitions.push({
    regexp: /Triggers '(\w+)' action with '(\w+)' on '([\w-]+)', when has no subtree\./g,
    testMethod: function (parameters) {
        var _a = tslib_1.__spreadArrays(parameters.props), action = _a[0], key = _a[1], elementToPerformAction = _a[2];
        var propertyNoSubtree = {
            hasItems: false,
            hasSubtree: false,
        };
        var expectedKeyNumberVertical = parameters.behavior(propertyNoSubtree).keyActions[elementToPerformAction][action]
            .keyCombinations[0].keyCode;
        expect(expectedKeyNumberVertical).toBe(keysAndAliases[key]);
    },
});
// Triggers 'expand' action with 'ArrowRight' on 'root', when has a closed subtree.
exports.definitions.push({
    regexp: /Triggers '(\w+)' action with '(\w+)' on '([\w-]+)', when has a closed subtree\./g,
    testMethod: function (parameters) {
        var _a = tslib_1.__spreadArrays(parameters.props), action = _a[0], key = _a[1], elementToPerformAction = _a[2];
        var propertyClosedSubtree = { open: false, expanded: false, hasSubtree: true };
        var expectedKeyNumberVertical = parameters.behavior(propertyClosedSubtree).keyActions[elementToPerformAction][action].keyCombinations[0].keyCode;
        expect(expectedKeyNumberVertical).toBe(keysAndAliases[key]);
    },
});
// Triggers 'closeMenuAndFocusTrigger' action with 'Escape' on 'wrapper', when toolbar button has submenu and it is opened.
exports.definitions.push({
    regexp: /Triggers '(\w+)' action with '(\w+)' on '([\w-]+)', when toolbar button has submenu and it is opened\./g,
    testMethod: function (parameters) {
        var _a = tslib_1.__spreadArrays(parameters.props), action = _a[0], key = _a[1], elementToPerformAction = _a[2];
        var propertySubmenuOpened = { menu: { items: [] }, hasMenu: true, menuOpen: true };
        var expectedKeyNumber = parameters.behavior(propertySubmenuOpened).keyActions[elementToPerformAction][action]
            .keyCombinations[0].keyCode;
        expect(expectedKeyNumber).toBe(keysAndAliases[key]);
        // when menuOpen == "false"
        propertySubmenuOpened.menuOpen = false;
        var expectedKeyCombinations = parameters.behavior(propertySubmenuOpened).keyActions[elementToPerformAction][action].keyCombinations;
        expect(expectedKeyCombinations).toBe(null);
    },
});
// Triggers 'doNotNavigateNextParentItem' action with 'ArrowLeft' or 'ArrowRight' on 'wrapper', when toolbar button has submenu and it is opened.
exports.definitions.push({
    regexp: /Triggers '(\w+)' action with '(\w+)' or '(\w+)' on '([\w-]+)', when toolbar button has submenu and it is opened\./g,
    testMethod: function (parameters) {
        var _a = tslib_1.__spreadArrays(parameters.props), action = _a[0], firstKey = _a[1], secondKey = _a[2], elementToPerformAction = _a[3];
        var propertySubmenuOpened = { menu: { items: [] }, hasMenu: true, menuOpen: true };
        var expectedFirstKeyNumber = parameters.behavior(propertySubmenuOpened).keyActions[elementToPerformAction][action]
            .keyCombinations[0].keyCode;
        var expectedSecondKeyNumber = parameters.behavior(propertySubmenuOpened).keyActions[elementToPerformAction][action].keyCombinations[1].keyCode;
        expect(expectedFirstKeyNumber).toBe(keysAndAliases[firstKey]);
        expect(expectedSecondKeyNumber).toBe(keysAndAliases[secondKey]);
        // when menuOpen == "false"
        propertySubmenuOpened.menuOpen = false;
        var expectedKeyCombinations = parameters.behavior(propertySubmenuOpened).keyActions[elementToPerformAction][action].keyCombinations;
        expect(expectedKeyCombinations).toBe(null);
    },
});
// Implements roving tabIndex
exports.definitions.push({
    regexp: /Implements roving tabIndex\./g,
    testMethod: function (parameters) {
        var propertyChecked = { checked: true };
        var propertyNotChecked = { checked: false };
        expect(parameters.behavior(propertyChecked).attributes.root.tabIndex).toBe(0);
        expect(parameters.behavior(propertyNotChecked).attributes.root.tabIndex).toBe(-1);
    },
});
