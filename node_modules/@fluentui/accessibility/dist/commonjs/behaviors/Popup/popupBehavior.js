"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.popupBehavior = void 0;

var _includes2 = _interopRequireDefault(require("lodash/includes"));

var _isArray2 = _interopRequireDefault(require("lodash/isArray"));

var _keyboardKey = require("../../keyboard-key");

var popupBehavior = function popupBehavior(props) {
  var onAsArray = (0, _isArray2.default)(props.on) ? props.on : [props.on];
  var tabbableTriggerProps = props.tabbableTrigger ? {
    tabIndex: getAriaAttributeFromProps('tabIndex', props, 0)
  } : undefined;

  if (tabbableTriggerProps) {
    tabbableTriggerProps['aria-haspopup'] = 'dialog';

    if (process.env.NODE_ENV !== 'production') {
      // Override the default trigger's accessibility schema class.
      tabbableTriggerProps['data-aa-class'] = 'PopupButton';
    }
  }

  return {
    attributes: {
      trigger: Object.assign({}, tabbableTriggerProps),
      popup: {
        role: props.trapFocus ? 'dialog' : props.inline ? undefined : 'complementary',
        'aria-modal': props.trapFocus ? true : undefined,
        'data-popup-trapfocus': props.trapFocus ? true : undefined
      }
    },
    keyActions: {
      popup: {
        closeAndFocusTrigger: {
          keyCombinations: [{
            keyCode: _keyboardKey.keyboardKey.Escape
          }]
        },
        preventScroll: {
          keyCombinations: props.isOpenedByRightClick && (0, _includes2.default)(onAsArray, 'context') && [{
            keyCode: _keyboardKey.keyboardKey.ArrowDown
          }, {
            keyCode: _keyboardKey.keyboardKey.ArrowUp
          }, {
            keyCode: _keyboardKey.keyboardKey.PageDown
          }, {
            keyCode: _keyboardKey.keyboardKey.PageUp
          }, {
            keyCode: _keyboardKey.keyboardKey.Home
          }, {
            keyCode: _keyboardKey.keyboardKey.End
          }]
        }
      },
      trigger: {
        close: {
          keyCombinations: [{
            keyCode: _keyboardKey.keyboardKey.Escape
          }]
        },
        toggle: {
          keyCombinations: (0, _includes2.default)(onAsArray, 'click') && [{
            keyCode: _keyboardKey.keyboardKey.Enter
          }, {
            keyCode: _keyboardKey.SpacebarKey
          }]
        },
        open: {
          keyCombinations: (0, _includes2.default)(onAsArray, 'hover') && !(0, _includes2.default)(onAsArray, 'context') && [{
            keyCode: _keyboardKey.keyboardKey.Enter
          }, {
            keyCode: _keyboardKey.SpacebarKey
          }]
        },
        click: {
          keyCombinations: (0, _includes2.default)(onAsArray, 'hover') && !(0, _includes2.default)(onAsArray, 'context') && [{
            keyCode: _keyboardKey.keyboardKey.Enter
          }, {
            keyCode: _keyboardKey.SpacebarKey
          }]
        }
      }
    }
  };
};

exports.popupBehavior = popupBehavior;

var isFocusable = function isFocusable(propsData) {
  try {
    var as = propsData.as,
        href = propsData.href,
        type = propsData.type;
    return type === 'button' || type === 'input' || type === 'a' && href !== undefined || as === 'button';
  } catch (_unused) {
    return false;
  }
};

var getAriaAttributeFromProps = function getAriaAttributeFromProps(attributeName, props, defaultValue) {
  if (!props.trigger) return undefined;

  if (props.trigger.props[attributeName]) {
    return props.trigger.props[attributeName];
  }

  var _props$trigger$props = props.trigger.props,
      as = _props$trigger$props.as,
      href = _props$trigger$props.href;
  var type = props.trigger.type;

  if (isFocusable({
    as: as,
    href: href,
    type: type
  })) {
    return undefined;
  }

  return defaultValue;
};
//# sourceMappingURL=popupBehavior.js.map
