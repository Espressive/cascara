"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.Carousel = exports.carouselSlotClassNames = exports.carouselClassName = void 0;

var _invoke2 = _interopRequireDefault(require("lodash/invoke"));

var _debounce2 = _interopRequireDefault(require("lodash/debounce"));

var customPropTypes = _interopRequireWildcard(require("@fluentui/react-proptypes"));

var _accessibility = require("@fluentui/accessibility");

var React = _interopRequireWildcard(require("react"));

var PropTypes = _interopRequireWildcard(require("prop-types"));

var _classnames = _interopRequireDefault(require("classnames"));

var _reactComponentRef = require("@fluentui/react-component-ref");

var _Animation = require("../Animation/Animation");

var _utils = require("../../utils");

var _CarouselItem = require("./CarouselItem");

var _Text = require("../Text/Text");

var _CarouselNavigation = require("./CarouselNavigation");

var _CarouselNavigationItem = require("./CarouselNavigationItem");

var _CarouselPaddle = require("./CarouselPaddle");

var _reactBindings = require("@fluentui/react-bindings");

var _state = require("@fluentui/state");

var _CarouselPaddlesContainer = require("./CarouselPaddlesContainer");

var carouselClassName = 'ui-carousel';
exports.carouselClassName = carouselClassName;
var carouselSlotClassNames = {
  itemsContainer: carouselClassName + "__itemscontainer",
  paddleNext: carouselClassName + "__paddlenext",
  paddlePrevious: carouselClassName + "__paddleprevious",
  pagination: carouselClassName + "__pagination",
  navigation: carouselClassName + "__navigation"
};
/**
 * A Carousel displays data organised as a gallery.
 *
 * @accessibility
 * Implements [ARIA Carousel](https://www.w3.org/WAI/tutorials/carousels/structure/) design pattern.
 * @accessibilityIssues
 * [VoiceOver doens't narrate label referenced by aria-labelledby attribute, when role is "tabpanel"](https://bugs.chromium.org/p/chromium/issues/detail?id=1040924)
 */

exports.carouselSlotClassNames = carouselSlotClassNames;

var Carousel = function Carousel(props) {
  var context = (0, _reactBindings.useFluentContext)();

  var _useTelemetry = (0, _reactBindings.useTelemetry)(Carousel.displayName, context.telemetry),
      setStart = _useTelemetry.setStart,
      setEnd = _useTelemetry.setEnd;

  setStart();
  var accessibility = props.accessibility,
      items = props.items,
      circular = props.circular,
      getItemPositionText = props.getItemPositionText,
      paddlePrevious = props.paddlePrevious,
      paddleNext = props.paddleNext,
      navigation = props.navigation,
      thumbnails = props.thumbnails,
      children = props.children,
      ariaRoleDescription = props.ariaRoleDescription,
      ariaLabel = props.ariaLabel,
      className = props.className,
      design = props.design,
      styles = props.styles,
      variables = props.variables;
  var ElementType = (0, _reactBindings.getElementType)(props);

  var _useStateManager = (0, _reactBindings.useStateManager)(_state.createCarouselManager, {
    mapPropsToInitialState: function mapPropsToInitialState() {
      return {
        activeIndex: props.defaultActiveIndex
      };
    },
    mapPropsToState: function mapPropsToState() {
      return {
        activeIndex: props.activeIndex
      };
    }
  }),
      state = _useStateManager.state,
      actions = _useStateManager.actions;

  var prevActiveIndex = state.prevActiveIndex,
      ariaLiveOn = state.ariaLiveOn,
      shouldFocusContainer = state.shouldFocusContainer,
      isFromKeyboard = state.isFromKeyboard,
      activeIndex = state.activeIndex;
  var itemRefs = React.useMemo(function () {
    return Array.from({
      length: items == null ? void 0 : items.length
    }, function () {
      return /*#__PURE__*/React.createRef();
    });
  }, // As we are using "panels.length" it's fine to have dependency on them
  // eslint-disable-next-line react-hooks/exhaustive-deps
  [items == null ? void 0 : items.length]);
  var unhandledProps = (0, _reactBindings.useUnhandledProps)(Carousel.handledProps, props);
  var getA11yProps = (0, _reactBindings.useAccessibility)(accessibility, {
    debugName: Carousel.displayName,
    actionHandlers: {
      showNextSlideByKeyboardNavigation: function showNextSlideByKeyboardNavigation(e) {
        e.preventDefault();
        showNextSlide(e, true);
      },
      showPreviousSlideByKeyboardNavigation: function showPreviousSlideByKeyboardNavigation(e) {
        e.preventDefault();
        showPreviousSlide(e, true);
      },
      showNextSlideByPaddlePress: function showNextSlideByPaddlePress(e) {
        e.preventDefault();
        showNextSlide(e, false);
        handleNextPaddleFocus();
      },
      showPreviousSlideByPaddlePress: function showPreviousSlideByPaddlePress(e) {
        e.preventDefault();
        showPreviousSlide(e, false);
        handlePreviousPaddleFocus();
      }
    },
    mapPropsToBehavior: function mapPropsToBehavior() {
      return {
        navigation: navigation,
        ariaLiveOn: ariaLiveOn,
        ariaRoleDescription: ariaRoleDescription,
        ariaLabel: ariaLabel
      };
    }
  });

  var _useStyles = (0, _reactBindings.useStyles)(Carousel.displayName, {
    className: carouselClassName,
    mapPropsToStyles: function mapPropsToStyles() {
      return {
        shouldFocusContainer: shouldFocusContainer,
        isFromKeyboard: isFromKeyboard
      };
    },
    mapPropsToInlineStyles: function mapPropsToInlineStyles() {
      return {
        className: className,
        design: design,
        styles: styles,
        variables: variables
      };
    },
    rtl: context.rtl
  }),
      classes = _useStyles.classes;

  var paddleNextRef = React.useRef();
  var paddlePreviousRef = React.useRef();
  var focusItemAtIndex = React.useMemo(function () {
    return (0, _debounce2.default)(function (index) {
      var _itemRefs$index$curre;

      (_itemRefs$index$curre = itemRefs[index].current) == null ? void 0 : _itemRefs$index$curre.focus();
    }, 400);
  }, [itemRefs]);
  React.useEffect(function () {
    return function () {
      focusItemAtIndex.cancel();
    };
  }, [focusItemAtIndex, items]);

  var setActiveIndex = function setActiveIndex(e, index, focusItem) {
    var lastItemIndex = items.length - 1;
    var nextActiveIndex = index;
    var lastActiveIndex = state.activeIndex;

    if (index < 0) {
      if (!circular) {
        return;
      }

      nextActiveIndex = lastItemIndex;
    }

    if (index > lastItemIndex) {
      if (!circular) {
        return;
      }

      nextActiveIndex = 0;
    }

    actions.setIndexes(nextActiveIndex, lastActiveIndex);
    (0, _invoke2.default)(props, 'onActiveIndexChange', e, Object.assign({}, props, {
      activeIndex: index
    }));

    if (focusItem) {
      focusItemAtIndex(nextActiveIndex);
    }
  };

  var overrideItemProps = function overrideItemProps(predefinedProps) {
    return {
      onFocus: function onFocus(e, itemProps) {
        actions.setShouldFocusContainer(e.currentTarget === e.target);
        actions.setIsFromKeyboard((0, _utils.isFromKeyboard)());
        (0, _invoke2.default)(predefinedProps, 'onFocus', e, itemProps);
      },
      onBlur: function onBlur(e, itemProps) {
        actions.setShouldFocusContainer(e.currentTarget.contains(e.relatedTarget));
        actions.setIsFromKeyboard(false);
        (0, _invoke2.default)(predefinedProps, 'onBlur', e, itemProps);
      }
    };
  };

  var renderContent = function renderContent() {
    return /*#__PURE__*/React.createElement("div", getA11yProps('itemsContainerWrapper', {
      className: classes.itemsContainerWrapper
    }), /*#__PURE__*/React.createElement("div", getA11yProps('itemsContainer', {
      className: (0, _classnames.default)(carouselSlotClassNames.itemsContainer, classes.itemsContainer)
    }), items && items.map(function (item, index) {
      var itemRef = itemRefs[index];
      var active = activeIndex === index;
      var slideToNext = prevActiveIndex < activeIndex;
      var initialMounting = prevActiveIndex === -1;

      if (circular && prevActiveIndex === items.length - 1 && activeIndex === 0) {
        slideToNext = true;
      } else if (circular && prevActiveIndex === 0 && activeIndex === items.length - 1) {
        slideToNext = false;
      }

      return /*#__PURE__*/React.createElement(_Animation.Animation, {
        key: item['key'] || index,
        mountOnEnter: true,
        unmountOnExit: true,
        visible: active,
        name: initialMounting || !active ? '' : slideToNext ? 'carousel-slide-to-next-enter' : 'carousel-slide-to-previous-enter'
      }, /*#__PURE__*/React.createElement(_reactComponentRef.Ref, {
        innerRef: itemRef
      }, _CarouselItem.CarouselItem.create(item, {
        defaultProps: function defaultProps() {
          return Object.assign({
            active: active,
            navigation: !!navigation
          }, getItemPositionText && {
            itemPositionText: getItemPositionText(index, items.length)
          });
        },
        overrideProps: overrideItemProps
      })));
    })));
  };

  var handleNextPaddleFocus = function handleNextPaddleFocus() {
    // if 'next' paddle will disappear, will focus 'previous' one.
    if (!navigation && activeIndex >= props.items.length - 2 && !circular) {
      paddlePreviousRef.current.focus();
    }
  };

  var handlePreviousPaddleFocus = function handlePreviousPaddleFocus() {
    // if 'previous' paddle will disappear, will focus 'next' one.
    if (!navigation && activeIndex <= 1 && !circular) {
      paddleNextRef.current.focus();
    }
  };

  var showPreviousSlide = function showPreviousSlide(e, focusItem) {
    setActiveIndex(e, +activeIndex - 1, focusItem);
  };

  var showNextSlide = function showNextSlide(e, focusItem) {
    setActiveIndex(e, +activeIndex + 1, focusItem);
  };

  var handlePaddleOverrides = function handlePaddleOverrides(predefinedProps, paddleName) {
    return {
      variables: (0, _reactBindings.mergeVariablesOverrides)(variables, predefinedProps.variables),
      onClick: function onClick(e, paddleProps) {
        (0, _invoke2.default)(predefinedProps, 'onClick', e, paddleProps);

        if (paddleName === 'paddleNext') {
          showNextSlide(e, false);
          handleNextPaddleFocus();
        } else if (paddleName === 'paddlePrevious') {
          showPreviousSlide(e, false);
          handlePreviousPaddleFocus();
        }
      },
      onBlur: function onBlur(e, paddleProps) {
        if (e.relatedTarget !== paddleNextRef.current) {
          actions.setAriaLiveOn(false);
        }
      },
      onFocus: function onFocus(e, paddleProps) {
        (0, _invoke2.default)(predefinedProps, 'onFocus', e, paddleProps);
        actions.setAriaLiveOn(true);
      }
    };
  };

  var paddles = /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(_reactComponentRef.Ref, {
    innerRef: paddlePreviousRef
  }, _CarouselPaddle.CarouselPaddle.create(paddlePrevious, {
    defaultProps: function defaultProps() {
      return getA11yProps('paddlePrevious', {
        className: carouselSlotClassNames.paddlePrevious,
        previous: true,
        hidden: items !== undefined && !circular && activeIndex === 0
      });
    },
    overrideProps: function overrideProps(predefinedProps) {
      return handlePaddleOverrides(predefinedProps, 'paddlePrevious');
    }
  })), /*#__PURE__*/React.createElement(_reactComponentRef.Ref, {
    innerRef: paddleNextRef
  }, _CarouselPaddle.CarouselPaddle.create(paddleNext, {
    defaultProps: function defaultProps() {
      return getA11yProps('paddleNext', {
        className: carouselSlotClassNames.paddleNext,
        next: true,
        hidden: items !== undefined && !circular && activeIndex === items.length - 1
      });
    },
    overrideProps: function overrideProps(predefinedProps) {
      return handlePaddleOverrides(predefinedProps, 'paddleNext');
    }
  })));

  var renderPaddles = function renderPaddles() {
    return (0, _utils.createShorthand)(_CarouselPaddlesContainer.CarouselPaddlesContainer, {}, {
      overrideProps: function overrideProps() {
        return {
          children: paddles
        };
      }
    });
  };

  var renderNavigation = function renderNavigation() {
    if (!items || !items.length) {
      return null;
    }

    return navigation ? _CarouselNavigation.CarouselNavigation.create(navigation, {
      defaultProps: function defaultProps() {
        return {
          className: carouselSlotClassNames.navigation,
          iconOnly: true,
          activeIndex: activeIndex,
          thumbnails: thumbnails
        };
      },
      overrideProps: function overrideProps(predefinedProps) {
        return {
          onItemClick: function onItemClick(e, itemProps) {
            var index = itemProps.index;
            setActiveIndex(e, index, true);
            (0, _invoke2.default)(predefinedProps, 'onClick', e, itemProps);
          }
        };
      }
    }) : getItemPositionText ? /*#__PURE__*/React.createElement(_Text.Text, {
      "aria-hidden": "true",
      align: "center",
      as: "div",
      className: carouselSlotClassNames.pagination,
      content: getItemPositionText(+activeIndex, items.length)
    }) : null;
  };

  var element = /*#__PURE__*/React.createElement(ElementType, getA11yProps('root', Object.assign({
    className: classes.root
  }, unhandledProps)), (0, _utils.childrenExist)(children) ? children : /*#__PURE__*/React.createElement(React.Fragment, null, renderPaddles(), renderContent(), renderNavigation()));
  setEnd();
  return element;
};

exports.Carousel = Carousel;
Carousel.displayName = 'Carousel';
Carousel.propTypes = Object.assign({}, _utils.commonPropTypes.createCommon({
  content: false
}), {
  activeIndex: PropTypes.number,
  ariaRoleDescription: PropTypes.string,
  ariaLabel: PropTypes.string,
  circular: PropTypes.bool,
  defaultActiveIndex: PropTypes.number,
  getItemPositionText: PropTypes.func,
  items: customPropTypes.collectionShorthand,
  navigation: PropTypes.oneOfType([customPropTypes.collectionShorthand, customPropTypes.itemShorthand]),
  navigationPosition: PropTypes.oneOf(['below', 'above', 'start', 'end']),
  onActiveIndexChange: PropTypes.func,
  paddleNext: customPropTypes.itemShorthand,
  paddlesPosition: PropTypes.oneOf(['inside', 'outside', 'inline']),
  paddlePrevious: customPropTypes.itemShorthand,
  thumbnails: PropTypes.bool
});
Carousel.defaultProps = {
  accessibility: _accessibility.carouselBehavior,
  paddlePrevious: {},
  paddleNext: {}
};
Carousel.Item = _CarouselItem.CarouselItem;
Carousel.Navigation = _CarouselNavigation.CarouselNavigation;
Carousel.NavigationItem = _CarouselNavigationItem.CarouselNavigationItem;
Carousel.Paddle = _CarouselPaddle.CarouselPaddle;
Carousel.PaddlesContainer = _CarouselPaddlesContainer.CarouselPaddlesContainer;
Carousel.handledProps = Object.keys(Carousel.propTypes);
Carousel.create = (0, _utils.createShorthandFactory)({
  Component: Carousel,
  mappedArrayProp: 'items'
});
//# sourceMappingURL=Carousel.js.map
