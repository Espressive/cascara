"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.Input = exports.inputSlotClassNames = exports.inputClassName = void 0;

var _get2 = _interopRequireDefault(require("lodash/get"));

var _invoke2 = _interopRequireDefault(require("lodash/invoke"));

var _isNil2 = _interopRequireDefault(require("lodash/isNil"));

var _accessibility = require("@fluentui/accessibility");

var _reactComponentRef = require("@fluentui/react-component-ref");

var customPropTypes = _interopRequireWildcard(require("@fluentui/react-proptypes"));

var React = _interopRequireWildcard(require("react"));

var PropTypes = _interopRequireWildcard(require("prop-types"));

var _utils = require("../../utils");

var _Box = require("../Box/Box");

var _reactBindings = require("@fluentui/react-bindings");

var _reactIconsNorthstar = require("@fluentui/react-icons-northstar");

var _InputLabel = require("./InputLabel");

var _formFieldBaseContext = require("../Form/utils/formFieldBaseContext");

var inputClassName = 'ui-input';
exports.inputClassName = inputClassName;
var inputSlotClassNames = {
  input: inputClassName + "__input",
  icon: inputClassName + "__icon"
};
/**
 * An Input is a field used to elicit an input from a user.
 *
 * @accessibility
 * For good screen reader experience set `aria-label` or `aria-labelledby` attribute for input.
 */

exports.inputSlotClassNames = inputSlotClassNames;
var Input = (0, _reactBindings.compose)(function (props, ref, composeOptions) {
  var context = (0, _reactBindings.useFluentContext)();

  var _useTelemetry = (0, _reactBindings.useTelemetry)(composeOptions.displayName, context.telemetry),
      setStart = _useTelemetry.setStart,
      setEnd = _useTelemetry.setEnd;

  setStart();
  var className = props.className,
      input = props.input,
      type = props.type,
      wrapper = props.wrapper,
      disabled = props.disabled,
      fluid = props.fluid,
      inverted = props.inverted,
      inline = props.inline,
      clearable = props.clearable,
      icon = props.icon,
      iconPosition = props.iconPosition,
      design = props.design,
      styles = props.styles,
      variables = props.variables,
      required = props.required,
      successIndicator = props.successIndicator,
      error = props.error,
      errorIndicator = props.errorIndicator,
      showSuccessIndicator = props.showSuccessIndicator,
      label = props.label,
      labelPosition = props.labelPosition;
  var inputRef = React.useRef();

  var _React$useContext = React.useContext(_formFieldBaseContext.FormFieldBaseContext),
      labelId = _React$useContext.labelId;

  var inputId = React.useRef();
  inputId.current = props.id || (0, _utils.getOrGenerateIdFromShorthand)('ui-input-', '', inputId.current);
  var ElementType = (0, _reactBindings.getElementType)(props);
  var unhandledProps = (0, _reactBindings.useUnhandledProps)(composeOptions.handledProps, props);

  var _partitionHTMLProps = (0, _utils.partitionHTMLProps)(unhandledProps),
      htmlInputProps = _partitionHTMLProps[0],
      restProps = _partitionHTMLProps[1];

  var _useAutoControlled = (0, _reactBindings.useAutoControlled)({
    defaultValue: props.defaultValue,
    value: props.value,
    initialValue: ''
  }),
      value = _useAutoControlled[0],
      setValue = _useAutoControlled[1];

  var hasValue = !!value && (value == null ? void 0 : value.length) !== 0;
  var isShowSuccessIndicatorUndefined = typeof showSuccessIndicator === 'undefined';
  var requiredAndSuccessful = isShowSuccessIndicatorUndefined ? (required && hasValue || showSuccessIndicator) && !error : showSuccessIndicator;
  var hasIcon = !!icon || showSuccessIndicator || required && isShowSuccessIndicatorUndefined || !(0, _isNil2.default)(error);

  var _useStyles = (0, _reactBindings.useStyles)(composeOptions.displayName, {
    className: inputClassName,
    mapPropsToStyles: function mapPropsToStyles() {
      return {
        fluid: fluid,
        inverted: inverted,
        inline: inline,
        disabled: disabled,
        clearable: clearable,
        hasIcon: hasIcon,
        requiredAndSuccessful: requiredAndSuccessful,
        iconPosition: iconPosition,
        hasValue: hasValue,
        labelPosition: labelPosition,
        error: error
      };
    },
    mapPropsToInlineStyles: function mapPropsToInlineStyles() {
      return {
        className: className,
        design: design,
        styles: styles,
        variables: variables
      };
    },
    rtl: context.rtl,
    composeOptions: composeOptions,
    unstable_props: props
  }),
      classes = _useStyles.classes,
      resolvedStyles = _useStyles.styles;

  var getA11yProps = (0, _reactBindings.useAccessibility)(props.accessibility, {
    debugName: composeOptions.displayName,
    actionHandlers: {
      clear: function clear(e) {
        if (clearable && value !== '') {
          e.stopPropagation();
          e.nativeEvent && e.nativeEvent.stopPropagation();
          handleOnClear(e);
        }
      }
    },
    mapPropsToBehavior: function mapPropsToBehavior() {
      return {
        disabled: disabled,
        required: required,
        error: error
      };
    },
    rtl: context.rtl
  });

  var handleIconOverrides = function handleIconOverrides(predefinedProps) {
    return {
      onClick: function onClick(e) {
        if (!disabled) {
          handleOnClear(e);
          inputRef.current.focus();
        }

        (0, _invoke2.default)(predefinedProps, 'onClick', e, props);
      }
    };
  };

  var handleChange = function handleChange(e) {
    if (disabled) {
      return;
    }

    var newValue = (0, _get2.default)(e, 'target.value');
    (0, _invoke2.default)(props, 'onChange', e, Object.assign({}, props, {
      value: newValue
    }));
    setValue(newValue);
  };

  var handleOnClear = function handleOnClear(e) {
    if (clearable) {
      (0, _invoke2.default)(props, 'onChange', e, Object.assign({}, props, {
        value: ''
      }));
      setValue('');
    }
  };

  var computeIcon = function computeIcon() {
    if (clearable && (value == null ? void 0 : value.length) !== 0) {
      return /*#__PURE__*/React.createElement(_reactIconsNorthstar.CloseIcon, {
        outline: true
      });
    }

    if (requiredAndSuccessful) {
      return successIndicator;
    }

    if (error) {
      return errorIndicator;
    }

    return icon || null;
  };

  var labelElement = (0, _utils.createShorthand)(composeOptions.slots.label, label, {
    defaultProps: function defaultProps() {
      return {
        labelPosition: labelPosition,
        label: label,
        required: required,
        htmlFor: inputId.current,
        hasValue: hasValue,
        id: labelId
      };
    }
  });

  var inputElement = _Box.Box.create({}, {
    defaultProps: function defaultProps() {
      return {
        children: /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(_reactComponentRef.Ref, {
          innerRef: function innerRef(inputElement) {
            (0, _reactComponentRef.handleRef)(inputRef, inputElement);
            (0, _reactComponentRef.handleRef)(props.inputRef, inputElement);
            (0, _reactComponentRef.handleRef)(ref, inputElement);
          }
        }, (0, _utils.createShorthand)(composeOptions.slots.control, input || type, {
          defaultProps: function defaultProps() {
            return getA11yProps('input', Object.assign({}, htmlInputProps, {
              as: 'input',
              disabled: disabled,
              type: type,
              required: required,
              value: value || '',
              id: inputId.current,
              className: inputSlotClassNames.input,
              styles: resolvedStyles.input,
              onChange: handleChange
            }));
          }
        })), (0, _utils.createShorthand)(composeOptions.slots.icon, computeIcon(), {
          defaultProps: function defaultProps() {
            return getA11yProps('icon', {
              className: inputSlotClassNames.icon,
              styles: resolvedStyles.icon
            });
          },
          overrideProps: handleIconOverrides
        })),
        styles: resolvedStyles.inputContainer
      };
    }
  });

  var element = _Box.Box.create(wrapper, {
    defaultProps: function defaultProps() {
      return getA11yProps('root', Object.assign({
        className: classes.root,
        children: /*#__PURE__*/React.createElement(React.Fragment, null, labelElement, inputElement),
        styles: resolvedStyles.root
      }, restProps));
    },
    overrideProps: {
      as: wrapper && wrapper.as || ElementType
    }
  });

  setEnd();
  return element;
}, {
  className: inputClassName,
  displayName: 'Input',
  slots: {
    control: _Box.Box,
    icon: _Box.Box,
    label: _InputLabel.InputLabel
  },
  handledProps: ['accessibility', 'as', 'children', 'className', 'design', 'styles', 'variables', 'clearable', 'defaultValue', 'disabled', 'fluid', 'icon', 'iconPosition', 'input', 'inputRef', 'inline', 'inverted', 'onChange', 'type', 'value', 'wrapper', 'required', 'successIndicator', 'error', 'errorIndicator', 'showSuccessIndicator', 'label', 'labelPosition']
});
exports.Input = Input;
Input.propTypes = Object.assign({}, _utils.commonPropTypes.createCommon({
  content: false
}), {
  clearable: PropTypes.bool,
  defaultValue: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),
  disabled: PropTypes.bool,
  fluid: PropTypes.bool,
  label: customPropTypes.itemShorthand,
  labelPosition: PropTypes.oneOf(['inline', 'above', 'inside']),
  icon: customPropTypes.shorthandAllowingChildren,
  iconPosition: PropTypes.oneOf(['start', 'end']),
  input: customPropTypes.itemShorthand,
  inputRef: customPropTypes.ref,
  inline: PropTypes.bool,
  inverted: PropTypes.bool,
  onChange: PropTypes.func,
  type: PropTypes.string,
  value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  wrapper: customPropTypes.wrapperShorthand,
  required: PropTypes.bool,
  successIndicator: customPropTypes.shorthandAllowingChildren,
  error: PropTypes.bool,
  errorIndicator: customPropTypes.shorthandAllowingChildren,
  showSuccessIndicator: PropTypes.bool
});
Input.defaultProps = {
  accessibility: _accessibility.inputBehavior,
  type: 'text',
  wrapper: {},
  iconPosition: 'end',
  errorIndicator: /*#__PURE__*/React.createElement(_reactIconsNorthstar.ExclamationCircleIcon, null),
  successIndicator: /*#__PURE__*/React.createElement(_reactIconsNorthstar.CheckmarkCircleIcon, {
    outline: true
  })
};
Input.Label = _InputLabel.InputLabel;
Input.create = (0, _utils.createShorthandFactory)({
  Component: Input
});
//# sourceMappingURL=Input.js.map
