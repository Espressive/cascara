"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Animation = void 0;
var tslib_1 = require("tslib");
var react_bindings_1 = require("@fluentui/react-bindings");
var classnames_1 = require("classnames");
var _ = require("lodash");
var PropTypes = require("prop-types");
var React = require("react");
var react_transition_group_1 = require("react-transition-group");
var utils_1 = require("../../utils");
var useAnimationStyles_1 = require("./useAnimationStyles");
/**
 * An Animation provides animation effects to rendered elements.
 */
var Animation = function (props) {
    var _a, _b;
    var context = react_bindings_1.useFluentContext();
    var _c = react_bindings_1.useTelemetry(exports.Animation.displayName, context.telemetry), setStart = _c.setStart, setEnd = _c.setEnd;
    setStart();
    var appear = props.appear, children = props.children, className = props.className, mountOnEnter = props.mountOnEnter, timeout = props.timeout, visible = props.visible, unmountOnExit = props.unmountOnExit;
    var handleAnimationEvent = function (event) { return function () {
        _.invoke(props, event, null, props);
    }; };
    var _d = useAnimationStyles_1.useAnimationStyles(exports.Animation.displayName, props), animationClasses = _d.className, animationDuration = _d.animationDuration, animationDelay = _d.animationDelay;
    var timeoutResult = timeout || react_bindings_1.unstable_calculateAnimationTimeout(animationDuration, animationDelay) || 0;
    var unhandledProps = react_bindings_1.useUnhandledProps(exports.Animation.handledProps, props);
    if (_.isNil(children)) {
        setEnd();
        return null;
    }
    var isChildrenFunction = typeof children === 'function';
    var child = utils_1.childrenExist(children) && !isChildrenFunction && React.Children.only(children);
    var element = (React.createElement(react_transition_group_1.Transition, tslib_1.__assign({ in: visible, appear: appear, mountOnEnter: mountOnEnter, unmountOnExit: unmountOnExit, timeout: timeoutResult, onEnter: handleAnimationEvent('onEnter'), onEntering: handleAnimationEvent('onEntering'), onEntered: handleAnimationEvent('onEntered'), onExit: handleAnimationEvent('onExit'), onExiting: handleAnimationEvent('onExiting'), onExited: handleAnimationEvent('onExited') }, unhandledProps, { className: !isChildrenFunction ? classnames_1.default(animationClasses, className, (_b = (_a = child) === null || _a === void 0 ? void 0 : _a.props) === null || _b === void 0 ? void 0 : _b.className) : '' }), isChildrenFunction
        ? function () { return children({ classes: classnames_1.default(animationClasses, className) }); }
        : child));
    setEnd();
    return element;
};
exports.Animation = Animation;
exports.Animation.displayName = 'Animation';
exports.Animation.propTypes = tslib_1.__assign(tslib_1.__assign({}, utils_1.commonPropTypes.createCommon({
    accessibility: false,
    as: false,
    content: false,
    children: false,
})), { children: PropTypes.oneOfType([PropTypes.func, PropTypes.element]), name: PropTypes.string, delay: PropTypes.string, direction: PropTypes.string, duration: PropTypes.string, fillMode: PropTypes.string, iterationCount: PropTypes.string, keyframeParams: PropTypes.object, playState: PropTypes.string, timingFunction: PropTypes.string, visible: PropTypes.bool, appear: PropTypes.bool, mountOnEnter: PropTypes.bool, unmountOnExit: PropTypes.bool, timeout: PropTypes.oneOfType([
        PropTypes.number,
        PropTypes.shape({
            appear: PropTypes.number,
            enter: PropTypes.number,
            exit: PropTypes.number,
        }),
    ]), onEnter: PropTypes.func, onEntering: PropTypes.func, onEntered: PropTypes.func, onExit: PropTypes.func, onExiting: PropTypes.func, onExited: PropTypes.func });
exports.Animation.handledProps = Object.keys(exports.Animation.propTypes);
