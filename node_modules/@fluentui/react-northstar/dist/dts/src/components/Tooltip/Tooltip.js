"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tooltip = exports.tooltipClassName = void 0;
var tslib_1 = require("tslib");
var accessibility_1 = require("@fluentui/accessibility");
var react_bindings_1 = require("@fluentui/react-bindings");
var react_component_ref_1 = require("@fluentui/react-component-ref");
var customPropTypes = require("@fluentui/react-proptypes");
var _ = require("lodash");
var PropTypes = require("prop-types");
var React = require("react");
var utils_1 = require("../../utils");
var positioner_1 = require("../../utils/positioner");
var PortalInner_1 = require("../Portal/PortalInner");
var TooltipContent_1 = require("./TooltipContent");
exports.tooltipClassName = 'ui-tooltip';
/**
 * A Tooltip displays additional non-modal information on top of its target element.
 * Tooltip doesn't receive focus and cannot contain focusable elements.
 *
 * @accessibility
 * Implements [ARIA Tooltip](https://www.w3.org/TR/wai-aria-practices-1.1/#tooltip) design pattern.
 */
var Tooltip = function (props) {
    var context = react_bindings_1.useFluentContext();
    var _a = react_bindings_1.useTelemetry(exports.Tooltip.displayName, context.telemetry), setStart = _a.setStart, setEnd = _a.setEnd;
    setStart();
    var accessibility = props.accessibility, align = props.align, content = props.content, flipBoundary = props.flipBoundary, mountNode = props.mountNode, mouseLeaveDelay = props.mouseLeaveDelay, offset = props.offset, overflowBoundary = props.overflowBoundary, pointing = props.pointing, popperRef = props.popperRef, position = props.position, positionFixed = props.positionFixed, target = props.target, trigger = props.trigger, unstable_disableTether = props.unstable_disableTether, unstable_pinned = props.unstable_pinned, autoSize = props.autoSize;
    var _b = react_bindings_1.useAutoControlled({
        defaultValue: props.defaultOpen,
        value: props.open,
        initialValue: false,
    }), open = _b[0], setOpen = _b[1];
    var triggerElement = react_bindings_1.useTriggerElement(props);
    var unhandledProps = react_bindings_1.useUnhandledProps(exports.Tooltip.handledProps, props);
    var contentRef = React.useRef();
    var pointerTargetRef = React.useRef();
    var triggerRef = React.useRef();
    var closeTimeoutId = React.useRef();
    // TODO: Consider `getOrGenerateIdFromShorthand()` as hook and make it SSR safe
    var contentId = React.useRef();
    contentId.current = utils_1.getOrGenerateIdFromShorthand('tooltip-content-', content, contentId.current);
    var getA11Props = react_bindings_1.useAccessibility(accessibility, {
        actionHandlers: {
            close: function (e) {
                setTooltipOpen(false, e);
                e.stopPropagation();
                e.preventDefault();
            },
        },
        mapPropsToBehavior: function () { return ({
            'aria-describedby': props['aria-describedby'],
            'aria-label': props['aria-label'],
            'aria-labelledby': props['aria-labelledby'],
            contentId: contentId.current,
            triggerAriaLabel: trigger && trigger.props['aria-label'],
            open: open,
        }); },
    });
    var getContentOverrideProps = function (predefinedProps) { return ({
        onMouseEnter: function (e) {
            setTooltipOpen(true, e);
            _.invoke(predefinedProps, 'onMouseEnter', e);
        },
        onMouseLeave: function (e) {
            setTooltipOpen(false, e);
            _.invoke(predefinedProps, 'onMouseLeave', e);
        },
    }); };
    var renderPopperChildren = function (popperProps) {
        var tooltipContent = TooltipContent_1.TooltipContent.create(content, {
            defaultProps: function () {
                return getA11Props('tooltip', {
                    open: open,
                    placement: popperProps.placement,
                    pointing: pointing,
                    pointerRef: pointerTargetRef,
                });
            },
            generateKey: false,
            overrideProps: getContentOverrideProps,
        });
        return tooltipContent ? React.createElement(react_component_ref_1.Ref, { innerRef: contentRef }, tooltipContent) : null;
    };
    var shouldStayOpen = function (e) {
        return _.invoke(e, 'currentTarget.contains', e.relatedTarget) || _.invoke(contentRef.current, 'contains', e.relatedTarget);
    };
    var trySetOpen = function (newValue, e) {
        setOpen(newValue);
        _.invoke(props, 'onOpenChange', e, tslib_1.__assign(tslib_1.__assign({}, props), { open: newValue }));
    };
    var setTooltipOpen = function (newOpen, e) {
        clearTimeout(closeTimeoutId.current);
        if (newOpen) {
            trySetOpen(true, e);
        }
        else {
            closeTimeoutId.current = context.target.defaultView.setTimeout(function () {
                trySetOpen(false, e);
            }, mouseLeaveDelay);
        }
    };
    var triggerProps = {
        onFocus: function (e) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (utils_1.isFromKeyboard()) {
                trySetOpen(true, e);
            }
            _.invoke.apply(_, tslib_1.__spreadArrays([triggerElement, 'props.onFocus', e], args));
        },
        onBlur: function (e) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (!shouldStayOpen(e)) {
                trySetOpen(false, e);
            }
            _.invoke.apply(_, tslib_1.__spreadArrays([triggerElement, 'props.onBlur', e], args));
        },
        onMouseEnter: function (e) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            setTooltipOpen(true, e);
            utils_1.setWhatInputSource(context.target, 'mouse');
            _.invoke.apply(_, tslib_1.__spreadArrays([triggerElement, 'props.onMouseEnter', e], args));
        },
        onMouseLeave: function (e) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            setTooltipOpen(false, e);
            _.invoke.apply(_, tslib_1.__spreadArrays([triggerElement, 'props.onMouseLeave', e], args));
        },
    };
    var element = (React.createElement(React.Fragment, null,
        triggerElement && (React.createElement(react_component_ref_1.Ref, { innerRef: triggerRef }, React.cloneElement(triggerElement, getA11Props('trigger', tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, triggerElement.props), triggerProps), unhandledProps))))),
        React.createElement(PortalInner_1.PortalInner, { mountNode: mountNode },
            React.createElement(positioner_1.Popper, { align: align, flipBoundary: flipBoundary, offset: offset, overflowBoundary: overflowBoundary, pointerTargetRef: pointerTargetRef, popperRef: popperRef, position: position, positionFixed: positionFixed, enabled: open, rtl: context.rtl, targetRef: target || triggerRef, children: renderPopperChildren, unstable_disableTether: unstable_disableTether, autoSize: autoSize, unstable_pinned: unstable_pinned }))));
    setEnd();
    return element;
};
exports.Tooltip = Tooltip;
exports.Tooltip.displayName = 'Tooltip';
exports.Tooltip.defaultProps = {
    align: 'center',
    position: 'above',
    mouseLeaveDelay: 10,
    pointing: true,
    accessibility: accessibility_1.tooltipAsLabelBehavior,
};
exports.Tooltip.propTypes = tslib_1.__assign(tslib_1.__assign({}, utils_1.commonPropTypes.createCommon({
    as: false,
    content: false,
})), { align: PropTypes.oneOf(positioner_1.ALIGNMENTS), children: PropTypes.element, defaultOpen: PropTypes.bool, mountNode: customPropTypes.domNode, mouseLeaveDelay: PropTypes.number, offset: PropTypes.oneOfType([
        PropTypes.func,
        PropTypes.arrayOf(PropTypes.number),
    ]), open: PropTypes.bool, onOpenChange: PropTypes.func, pointing: PropTypes.bool, position: PropTypes.oneOf(positioner_1.POSITIONS), positionFixed: PropTypes.bool, target: customPropTypes.domNode, trigger: customPropTypes.every([customPropTypes.disallow(['children']), PropTypes.element]), content: customPropTypes.shorthandAllowingChildren, unstable_disableTether: PropTypes.oneOf([true, false, 'all']), unstable_pinned: PropTypes.bool, autoSize: PropTypes.oneOf(positioner_1.AUTOSIZES), popperRef: customPropTypes.ref, flipBoundary: PropTypes.oneOfType([
        PropTypes.object,
        PropTypes.arrayOf(PropTypes.object),
        PropTypes.oneOf(['clippingParents', 'window', 'scrollParent']),
    ]), overflowBoundary: PropTypes.oneOfType([
        PropTypes.object,
        PropTypes.arrayOf(PropTypes.object),
        PropTypes.oneOf(['clippingParents', 'window', 'scrollParent']),
    ]) });
exports.Tooltip.handledProps = Object.keys(exports.Tooltip.propTypes);
exports.Tooltip.Content = TooltipContent_1.TooltipContent;
exports.Tooltip.create = utils_1.createShorthandFactory({ Component: exports.Tooltip, mappedProp: 'content' });
