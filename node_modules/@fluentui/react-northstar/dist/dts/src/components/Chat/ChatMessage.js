"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChatMessage = exports.chatMessageSlotClassNames = exports.chatMessageClassName = void 0;
var tslib_1 = require("tslib");
var accessibility_1 = require("@fluentui/accessibility");
var react_bindings_1 = require("@fluentui/react-bindings");
var react_component_ref_1 = require("@fluentui/react-component-ref");
var customPropTypes = require("@fluentui/react-proptypes");
var classnames_1 = require("classnames");
var _ = require("lodash");
var PropTypes = require("prop-types");
var React = require("react");
var utils_1 = require("../../utils");
var positioner_1 = require("../../utils/positioner");
var Box_1 = require("../Box/Box");
var Flex_1 = require("../Flex/Flex");
var Label_1 = require("../Label/Label");
var Menu_1 = require("../Menu/Menu");
var PortalInner_1 = require("../Portal/PortalInner");
var Reaction_1 = require("../Reaction/Reaction");
var Text_1 = require("../Text/Text");
var chatDensityContext_1 = require("./chatDensityContext");
var chatItemContext_1 = require("./chatItemContext");
var ChatMessageDetails_1 = require("./ChatMessageDetails");
var ChatMessageHeader_1 = require("./ChatMessageHeader");
var ChatMessageReadStatus_1 = require("./ChatMessageReadStatus");
exports.chatMessageClassName = 'ui-chat__message';
exports.chatMessageSlotClassNames = {
    actionMenu: exports.chatMessageClassName + "__actions",
    author: exports.chatMessageClassName + "__author",
    badge: exports.chatMessageClassName + "__badge",
    bar: exports.chatMessageClassName + "__bar",
    compactBody: exports.chatMessageClassName + "__compact-body",
    content: exports.chatMessageClassName + "__content",
    reactionGroup: exports.chatMessageClassName + "__reactions",
    timestamp: exports.chatMessageClassName + "__timestamp",
};
function partitionActionMenuPropsFromShorthand(value) {
    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
        var _a = value, inline = _a.inline, showActionMenu = _a.showActionMenu, props = tslib_1.__rest(_a, ["inline", "showActionMenu"]);
        return [props, inline !== null && inline !== void 0 ? inline : true, showActionMenu];
    }
    return [value, true, false];
}
/**
 * A ChatMessage represents a single message in chat.
 */
var ChatMessage = function (props) {
    var context = react_bindings_1.useFluentContext();
    var _a = react_bindings_1.useTelemetry(exports.ChatMessage.displayName, context.telemetry), setStart = _a.setStart, setEnd = _a.setEnd;
    setStart();
    var parentAttached = react_bindings_1.useContextSelector(chatItemContext_1.ChatItemContext, function (v) { return v.attached; });
    var chatDensity = chatDensityContext_1.useChatDensityContext();
    var accessibility = props.accessibility, _b = props.attached, attached = _b === void 0 ? parentAttached : _b, author = props.author, badge = props.badge, badgePosition = props.badgePosition, children = props.children, className = props.className, compactBody = props.compactBody, content = props.content, _c = props.density, density = _c === void 0 ? chatDensity : _c, design = props.design, details = props.details, header = props.header, mine = props.mine, positionActionMenu = props.positionActionMenu, reactionGroup = props.reactionGroup, reactionGroupPosition = props.reactionGroupPosition, readStatus = props.readStatus, styles = props.styles, timestamp = props.timestamp, overflow = props.unstable_overflow, variables = props.variables;
    var _d = positioner_1.partitionPopperPropsFromShorthand(props.actionMenu), actionMenuOptions = _d[0], positioningProps = _d[1];
    var _e = partitionActionMenuPropsFromShorthand(actionMenuOptions), actionMenu = _e[0], inlineActionMenu = _e[1], controlledShowActionMenu = _e[2];
    var _f = react_bindings_1.useAutoControlled({
        defaultValue: false,
        value: controlledShowActionMenu,
    }), showActionMenu = _f[0], setShowActionMenu = _f[1];
    var hasActionMenu = !_.isNil(actionMenu);
    var actionMenuId = React.useRef();
    actionMenuId.current = utils_1.getOrGenerateIdFromShorthand(exports.chatMessageClassName + "-", actionMenu, actionMenuId.current);
    var modifiers = React.useCallback(function (target, container) {
        return (positionActionMenu && [
            // https://popper.js.org/docs/v2/modifiers/flip/
            // Forces to flip only in "top-*" positions
            { name: 'flip', options: { fallbackPlacements: ['top'] } },
            overflow && {
                name: 'preventOverflow',
                options: { boundary: positioner_1.getScrollParent(container) },
            },
        ]);
    }, [positionActionMenu, overflow]);
    var popperRef = React.useRef();
    var _g = positioner_1.usePopper(tslib_1.__assign({ align: 'end', position: 'above', positionFixed: overflow, enabled: hasActionMenu && positionActionMenu, modifiers: modifiers,
        popperRef: popperRef }, positioningProps)), messageRef = _g.targetRef, actionsMenuRef = _g.containerRef;
    // `focused` state is used for show/hide actionMenu
    var _h = React.useState(false), focused = _h[0], setFocused = _h[1];
    var getA11Props = react_bindings_1.useAccessibility(accessibility, {
        actionHandlers: {
            // prevents default FocusZone behavior, e.g., in ChatMessageBehavior, it prevents FocusZone from using arrow keys
            // as navigation (only Tab key should work)
            preventDefault: function (event) {
                // preventDefault only if event coming from inside the message
                if (event.currentTarget !== event.target) {
                    event.preventDefault();
                }
            },
            focus: function (event) {
                if (messageRef.current) {
                    messageRef.current.focus();
                    event.stopPropagation();
                }
            },
        },
        debugName: exports.ChatMessage.displayName,
        mapPropsToBehavior: function () { return ({
            hasActionMenu: hasActionMenu,
            inlineActionMenu: inlineActionMenu,
            actionMenuId: actionMenuId.current,
        }); },
        rtl: context.rtl,
    });
    var _j = react_bindings_1.useStyles(exports.ChatMessage.displayName, {
        className: exports.chatMessageClassName,
        mapPropsToStyles: function () { return ({
            attached: attached,
            badgePosition: badgePosition,
            density: density,
            focused: focused,
            hasActionMenu: hasActionMenu,
            hasBadge: !!badge,
            hasReactionGroup: !!reactionGroup,
            mine: mine,
            showActionMenu: showActionMenu,
        }); },
        mapPropsToInlineStyles: function () { return ({
            className: className,
            design: design,
            styles: styles,
            variables: variables,
        }); },
        rtl: context.rtl,
    }), classes = _j.classes, resolvedStyles = _j.styles;
    var handleFocus = function (e) {
        var _a;
        (_a = popperRef.current) === null || _a === void 0 ? void 0 : _a.updatePosition();
        // react onFocus is called even when nested component receives focus (i.e. it bubbles)
        // so when focus moves within actionMenu, the `focus` state in chatMessage remains true, and keeps actionMenu visible
        setFocused(true);
        _.invoke(props, 'onFocus', e, props);
    };
    var handleBlur = function (e) {
        // `focused` controls is focused the whole `ChatMessage` or any of its children. When we're navigating
        // with keyboard the focused element will be changed and there is no way to use `:focus` selector
        var shouldPreserveFocusState = _.invoke(e, 'currentTarget.contains', e.relatedTarget);
        setFocused(shouldPreserveFocusState);
        setShowActionMenu(false);
        _.invoke(props, 'onBlur', e, props);
    };
    var handleMouseEnter = function (e) {
        var _a;
        (_a = popperRef.current) === null || _a === void 0 ? void 0 : _a.updatePosition();
        if (hasActionMenu && !inlineActionMenu) {
            setShowActionMenu(true);
        }
        _.invoke(props, 'onMouseEnter', e, props);
    };
    var handleMouseLeave = function (e) {
        if (!focused && hasActionMenu && !inlineActionMenu) {
            setShowActionMenu(false);
        }
        _.invoke(props, 'onMouseLeave', e, props);
    };
    var renderActionMenu = function () {
        var actionMenuElement = Menu_1.Menu.create(actionMenu, {
            defaultProps: function () {
                var _a;
                return (_a = {},
                    _a[accessibility_1.IS_FOCUSABLE_ATTRIBUTE] = true,
                    _a.accessibility = accessibility_1.menuAsToolbarBehavior,
                    _a.className = exports.chatMessageSlotClassNames.actionMenu,
                    _a.styles = resolvedStyles.actionMenu,
                    _a);
            },
            overrideProps: {
                id: actionMenuId.current,
            },
        });
        var content = actionMenuElement ? React.createElement(react_component_ref_1.Ref, { innerRef: actionsMenuRef }, actionMenuElement) : actionMenuElement;
        return inlineActionMenu || !content ? content : React.createElement(PortalInner_1.PortalInner, null, content);
    };
    var handleKeyDown = function (e) {
        var _a, _b, _c;
        if (hasActionMenu && !inlineActionMenu) {
            // reference: https://github.com/microsoft/fluentui/pull/17329
            var toFocusItemInActionMenu = (_b = (_a = actionsMenuRef.current) === null || _a === void 0 ? void 0 : _a.querySelector('[tabindex="0"]')) !== null && _b !== void 0 ? _b : (_c = actionsMenuRef.current) === null || _c === void 0 ? void 0 : _c.querySelectorAll('[tabindex="-1"]:not([data-is-focusable="false"])')[0];
            if (e.keyCode === accessibility_1.keyboardKey.Enter) {
                toFocusItemInActionMenu === null || toFocusItemInActionMenu === void 0 ? void 0 : toFocusItemInActionMenu.focus();
                e.stopPropagation();
                e.preventDefault();
            }
            if (e.keyCode === accessibility_1.keyboardKey.Tab) {
                // TAB/SHIFT+TAB cycles focus among actionMenu and focusable elements within chat message
                var isShift = !!e.shiftKey;
                var focusableElementsInsideMessage = e.currentTarget.querySelectorAll('[tabindex="-1"]:not([data-is-focusable="false"])');
                var firstFocusableInsideMessage = focusableElementsInsideMessage[0];
                var lastFocusableInsideMessage = focusableElementsInsideMessage[focusableElementsInsideMessage.length - 1];
                if (e.target === toFocusItemInActionMenu) {
                    // focus is now inside action menu
                    // cycle focus into the first/last focusable element inside chat message
                    if (isShift) {
                        lastFocusableInsideMessage === null || lastFocusableInsideMessage === void 0 ? void 0 : lastFocusableInsideMessage.focus();
                    }
                    else {
                        firstFocusableInsideMessage === null || firstFocusableInsideMessage === void 0 ? void 0 : firstFocusableInsideMessage.focus();
                    }
                    e.stopPropagation();
                    e.preventDefault();
                }
                else {
                    var boundaryElementInsideMessage = isShift ? firstFocusableInsideMessage : lastFocusableInsideMessage;
                    if (e.target === boundaryElementInsideMessage) {
                        // focus is now on the first/last focusable element inside chat message
                        toFocusItemInActionMenu.focus(); // cycle focus back into action Menu
                        e.stopPropagation();
                        e.preventDefault();
                    }
                }
            }
        }
        _.invoke(props, 'onKeyDown', e, props);
    };
    var childrenPropExists = utils_1.childrenExist(children);
    var rootClasses = childrenPropExists ? classnames_1.default(classes.root, classes.content) : classes.root;
    var ElementType = react_bindings_1.getElementType(props);
    var unhandledProps = react_bindings_1.useUnhandledProps(exports.ChatMessage.handledProps, props);
    var badgeElement = Label_1.Label.create(badge, {
        defaultProps: function () { return ({
            className: exports.chatMessageSlotClassNames.badge,
            styles: resolvedStyles.badge,
        }); },
    });
    var reactionGroupElement = Reaction_1.Reaction.Group.create(reactionGroup, {
        defaultProps: function () { return ({
            className: exports.chatMessageSlotClassNames.reactionGroup,
            styles: resolvedStyles.reactionGroup,
        }); },
    });
    var actionMenuElement = renderActionMenu();
    var authorElement = Text_1.Text.create(author, {
        defaultProps: function () { return ({
            size: density === 'comfy' ? 'small' : undefined,
            styles: resolvedStyles.author,
            className: exports.chatMessageSlotClassNames.author,
        }); },
    });
    var timestampElement = Text_1.Text.create(timestamp, {
        defaultProps: function () { return ({
            size: 'small',
            styles: resolvedStyles.timestamp,
            timestamp: true,
            className: exports.chatMessageSlotClassNames.timestamp,
        }); },
    });
    var messageContent = Box_1.Box.create(content, {
        defaultProps: function () { return ({
            className: exports.chatMessageSlotClassNames.content,
            styles: resolvedStyles.content,
        }); },
    });
    var detailsElement = utils_1.createShorthand(ChatMessageDetails_1.ChatMessageDetails, details, {
        defaultProps: function () { return ({ attached: attached, density: density, mine: mine }); },
    });
    var readStatusElement = utils_1.createShorthand(ChatMessageReadStatus_1.ChatMessageReadStatus, readStatus, {
        defaultProps: function () { return ({ density: density }); },
    });
    var elements = React.createElement(React.Fragment, null);
    if (density === 'compact') {
        var headerElement = utils_1.createShorthand(ChatMessageHeader_1.ChatMessageHeader, header);
        var bodyElement = Box_1.Box.create(compactBody, {
            defaultProps: function () {
                return getA11Props('compactBody', {
                    className: exports.chatMessageSlotClassNames.compactBody,
                    styles: resolvedStyles.compactBody,
                });
            },
            overrideProps: function () { return ({
                content: (React.createElement(React.Fragment, null,
                    React.createElement(Flex_1.Flex.Item, { grow: 1 },
                        React.createElement("div", null,
                            authorElement,
                            messageContent)),
                    timestampElement,
                    detailsElement,
                    badgeElement)),
            }); },
        });
        elements = (React.createElement(React.Fragment, null,
            actionMenuElement,
            React.createElement("div", { className: exports.chatMessageSlotClassNames.bar }),
            headerElement,
            bodyElement,
            reactionGroupElement,
            readStatusElement));
    }
    else {
        var headerElement = utils_1.createShorthand(ChatMessageHeader_1.ChatMessageHeader, header || {}, {
            overrideProps: function () { return ({
                content: (React.createElement(React.Fragment, null,
                    authorElement,
                    timestampElement,
                    detailsElement,
                    reactionGroupPosition === 'start' && reactionGroupElement)),
            }); },
        });
        elements = (React.createElement(React.Fragment, null,
            actionMenuElement,
            React.createElement("div", { className: exports.chatMessageSlotClassNames.bar }),
            badgePosition === 'start' && badgeElement,
            headerElement,
            messageContent,
            reactionGroupPosition === 'end' && reactionGroupElement,
            badgePosition === 'end' && badgeElement,
            readStatusElement));
    }
    var element = (React.createElement(react_component_ref_1.Ref, { innerRef: messageRef }, getA11Props.unstable_wrapWithFocusZone(React.createElement(ElementType, tslib_1.__assign({}, getA11Props('root', tslib_1.__assign(tslib_1.__assign({ className: rootClasses, onBlur: handleBlur, onFocus: handleFocus, onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave, onKeyDown: handleKeyDown }, utils_1.rtlTextContainer.getAttributes({ forElements: [children] })), unhandledProps))), childrenPropExists ? children : elements))));
    setEnd();
    return element;
};
exports.ChatMessage = ChatMessage;
exports.ChatMessage.displayName = 'ChatMessage';
exports.ChatMessage.defaultProps = {
    accessibility: accessibility_1.chatMessageBehavior,
    badgePosition: 'end',
    compactBody: {},
    positionActionMenu: true,
    reactionGroupPosition: 'start',
};
exports.ChatMessage.propTypes = tslib_1.__assign(tslib_1.__assign({}, utils_1.commonPropTypes.createCommon({ content: 'shorthand' })), { actionMenu: PropTypes.oneOfType([customPropTypes.itemShorthand, customPropTypes.collectionShorthand]), attached: PropTypes.oneOfType([PropTypes.bool, PropTypes.oneOf(['top', 'bottom'])]), author: customPropTypes.itemShorthand, badge: customPropTypes.itemShorthand, badgePosition: PropTypes.oneOf(['start', 'end']), compactBody: customPropTypes.itemShorthand, density: PropTypes.oneOf(['comfy', 'compact']), details: customPropTypes.itemShorthand, header: customPropTypes.itemShorthand, mine: PropTypes.bool, onBlur: PropTypes.func, onFocus: PropTypes.func, onKeyDown: PropTypes.func, onMouseEnter: PropTypes.func, onMouseLeave: PropTypes.func, positionActionMenu: PropTypes.bool, reactionGroup: PropTypes.oneOfType([customPropTypes.collectionShorthand, customPropTypes.itemShorthand]), reactionGroupPosition: PropTypes.oneOf(['start', 'end']), readStatus: customPropTypes.itemShorthand, timestamp: customPropTypes.itemShorthand, unstable_overflow: PropTypes.bool });
exports.ChatMessage.handledProps = Object.keys(exports.ChatMessage.propTypes);
exports.ChatMessage.create = utils_1.createShorthandFactory({ Component: exports.ChatMessage, mappedProp: 'content' });
