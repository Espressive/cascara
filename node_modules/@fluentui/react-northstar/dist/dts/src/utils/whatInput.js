"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isFromKeyboard = exports.ask = exports.setWhatInputSource = exports.tryCleanupWhatInput = exports.setUpWhatInput = void 0;
var isBrowser_1 = require("./isBrowser");
// Taken from https://github.com/ten1seven/what-input/blob/master/src/scripts/what-input.js
/* eslint-disable */
/*
 * variables
 */
// last used input type
var currentInput = 'initial';
// event buffer timer
var eventTimer = null;
// list of modifier keys commonly used with the mouse and
// can be safely ignored to prevent false keyboard detection
var ignoreMap = [
    16,
    17,
    18,
    91,
    93,
];
// used to count how many Providers needed to initialize whatinput.
var whatInputInitialized = 'whatInputInitialized';
// mapping of events to input types
var inputMap = {
    keydown: 'keyboard',
    keyup: 'keyboard',
    mousedown: 'mouse',
    mousemove: 'mouse',
    MSPointerDown: 'pointer',
    MSPointerMove: 'pointer',
    pointerdown: 'pointer',
    pointermove: 'pointer',
    touchstart: 'touch',
};
// boolean: true if touch buffer is active
var isBuffering = false;
// map of IE 10 pointer events
var pointerMap = {
    2: 'touch',
    3: 'touch',
    4: 'mouse',
};
// check support for passive event listeners
var supportsPassive = false;
try {
    var opts = Object.defineProperty({}, 'passive', {
        get: function () {
            supportsPassive = true;
        },
    });
    window.addEventListener('test', null, opts);
}
catch (e) { }
/*
 * set up
 */
var setUp = function () {
    // add correct mouse wheel event mapping to `inputMap`
    inputMap[detectWheel()] = 'mouse';
    addListeners(window);
    doUpdate(window.document);
};
/*
 * events
 */
var addListeners = function (eventTarget) {
    // `pointermove`, `MSPointerMove`, `mousemove` and mouse wheel event binding
    // can only demonstrate potential, but not actual, interaction
    // and are treated separately
    var options = supportsPassive ? { passive: true, capture: true } : true;
    // pointer events (mouse, pen, touch)
    // @ts-ignore
    if (eventTarget.PointerEvent) {
        eventTarget.addEventListener('pointerdown', setInput);
        // @ts-ignore
    }
    else if (window.MSPointerEvent) {
        eventTarget.addEventListener('MSPointerDown', setInput);
    }
    else {
        // mouse events
        eventTarget.addEventListener('mousedown', setInput, true);
        // touch events
        if ('ontouchstart' in eventTarget) {
            eventTarget.addEventListener('touchstart', eventBuffer, options);
            eventTarget.addEventListener('touchend', setInput, true);
        }
    }
    // keyboard events
    eventTarget.addEventListener('keydown', eventBuffer, true);
    eventTarget.addEventListener('keyup', eventBuffer, true);
};
// checks conditions before updating new input
var setInput = function (event) {
    // only execute if the event buffer timer isn't running
    if (!isBuffering) {
        var eventKey = event.which;
        var value = inputMap[event.type];
        if (value === 'pointer') {
            value = pointerType(event);
        }
        var ignoreMatch = ignoreMap.indexOf(eventKey) === -1;
        var shouldUpdate = (value === 'keyboard' && eventKey && ignoreMatch) || value === 'mouse' || value === 'touch';
        if (currentInput !== value && shouldUpdate) {
            currentInput = value;
            doUpdate(event.view.document);
        }
    }
};
// updates the doc and `inputTypes` array with new input
var doUpdate = function (target) {
    target.documentElement.setAttribute("data-whatinput", currentInput);
};
// buffers events that frequently also fire mouse events
var eventBuffer = function (event) {
    // set the current input
    setInput(event);
    // clear the timer if it happens to be running
    window.clearTimeout(eventTimer);
    // set the isBuffering to `true`
    isBuffering = true;
    // run the timer
    eventTimer = window.setTimeout(function () {
        // if the timer runs out, set isBuffering back to `false`
        isBuffering = false;
    }, 100);
};
/*
 * utilities
 */
var pointerType = function (event) {
    if (typeof event.pointerType === 'number') {
        return pointerMap[event.pointerType];
    }
    // treat pen like touch
    return event.pointerType === 'pen' ? 'touch' : event.pointerType;
};
// detect version of mouse wheel event to use
// via https://developer.mozilla.org/en-US/docs/Web/Events/wheel
var detectWheel = function () {
    var wheelType;
    // Modern browsers support "wheel"
    if ('onwheel' in document.createElement('div')) {
        wheelType = 'wheel';
    }
    else {
        // Webkit and IE support at least "mousewheel"
        // or assume that remaining browsers are older Firefox
        wheelType =
            // @ts-ignore
            document.onmousewheel !== undefined ? 'mousewheel' : 'DOMMouseScroll';
    }
    return wheelType;
};
// don't start script unless browser cuts the mustard
// (also passes if polyfills are used)
if (isBrowser_1.isBrowser() && 'addEventListener' in window && Array.prototype.indexOf) {
    setUp();
}
/*
 * set up for document
 */
var setUpWhatInput = function (target) {
    var targetWindow = target.defaultView;
    if (isBrowser_1.isBrowser() && targetWindow && 'addEventListener' in targetWindow && Array.prototype.indexOf) {
        var initializedTimes = target[whatInputInitialized];
        if (typeof initializedTimes === 'number' && initializedTimes > 0) {
            target[whatInputInitialized] = initializedTimes + 1;
            return;
        }
        target[whatInputInitialized] = 1;
        addListeners(targetWindow);
        doUpdate(target);
    }
};
exports.setUpWhatInput = setUpWhatInput;
function cleanupWhatInput(eventTarget) {
    var options = supportsPassive ? { capture: true } : true;
    // @ts-ignore
    if (eventTarget.PointerEvent) {
        eventTarget.removeEventListener('pointerdown', setInput);
        // @ts-ignore
    }
    else if (window.MSPointerEvent) {
        eventTarget.removeEventListener('MSPointerDown', setInput);
    }
    else {
        // mouse events
        eventTarget.removeEventListener('mousedown', setInput, true);
        // touch events
        if ('ontouchstart' in eventTarget) {
            eventTarget.removeEventListener('touchstart', eventBuffer, options);
            eventTarget.removeEventListener('touchend', setInput, true);
        }
    }
    // keyboard events
    eventTarget.removeEventListener('keydown', eventBuffer, true);
    eventTarget.removeEventListener('keyup', eventBuffer, true);
}
var tryCleanupWhatInput = function (target) {
    var targetWindow = target.defaultView;
    if (isBrowser_1.isBrowser() && targetWindow && 'removeEventListener' in targetWindow) {
        if (target[whatInputInitialized] === 1) {
            delete target[whatInputInitialized];
            cleanupWhatInput(targetWindow);
        }
        else {
            target[whatInputInitialized] = target[whatInputInitialized] - 1;
        }
    }
};
exports.tryCleanupWhatInput = tryCleanupWhatInput;
var setWhatInputSource = function (target, newInput) {
    currentInput = newInput;
    doUpdate(target);
};
exports.setWhatInputSource = setWhatInputSource;
// returns string: the current input type
// returns the same value as the `data-whatinput` attribute
var ask = function () { return currentInput; };
exports.ask = ask;
var isFromKeyboard = function () { return exports.ask() === 'keyboard'; };
exports.isFromKeyboard = isFromKeyboard;
