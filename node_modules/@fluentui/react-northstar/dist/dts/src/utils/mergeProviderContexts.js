"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeProviderContexts = exports.mergeBooleanValues = exports.mergePerformanceOptions = exports.getRenderer = void 0;
var tslib_1 = require("tslib");
var styles_1 = require("@fluentui/styles");
var isBrowser_1 = require("./isBrowser");
var defaultDocument = { document: 'document' };
var registeredRenderers = new WeakMap();
var getRenderer = function (createRenderer, target) {
    var actualTarget = target || defaultDocument;
    // A valid comparisons, default renderer will be used
    if (!isBrowser_1.isBrowser() || typeof target === 'undefined') {
        actualTarget = defaultDocument;
    }
    // SSR logic will be handled by condition above
    // eslint-disable-next-line no-undef
    if (isBrowser_1.isBrowser() && target === document) {
        actualTarget = defaultDocument;
    }
    if (registeredRenderers.has(actualTarget)) {
        return registeredRenderers.get(actualTarget);
    }
    // To avoid errors related to SSR as `document` may not exist we are using a fake object `defaultDocument`.
    // When a value matches `defaultDocument` we will pass `undefined` to `createRenderer()` and it should handle it
    // properly.
    var createdRenderer = createRenderer(actualTarget === defaultDocument ? undefined : actualTarget);
    registeredRenderers.set(actualTarget, createdRenderer);
    return createdRenderer;
};
exports.getRenderer = getRenderer;
var mergePerformanceOptions = function (target) {
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    return Object.assign.apply(Object, tslib_1.__spreadArrays([target], sources));
};
exports.mergePerformanceOptions = mergePerformanceOptions;
var mergeBooleanValues = function (target) {
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    return sources.reduce(function (acc, next) {
        return typeof next === 'boolean' ? next : acc;
    }, target);
};
exports.mergeBooleanValues = mergeBooleanValues;
var mergeProviderContexts = function (createRenderer) {
    var contexts = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        contexts[_i - 1] = arguments[_i];
    }
    var emptyContext = {
        theme: {
            siteVariables: {
                fontSizes: {},
            },
            componentVariables: {},
            componentStyles: {},
            fontFaces: [],
            staticStyles: [],
            animations: {},
        },
        rtl: false,
        disableAnimations: false,
        target: isBrowser_1.isBrowser() ? document : undefined,
        performance: {
            enableSanitizeCssPlugin: process.env.NODE_ENV !== 'production',
            enableStylesCaching: true,
            enableVariablesCaching: true,
            enableBooleanVariablesCaching: false,
        },
        telemetry: undefined,
        renderer: undefined,
    };
    return contexts.reduce(function (acc, next) {
        if (!next)
            return acc;
        acc.theme = styles_1.mergeThemes(acc.theme, next.theme);
        // Latest RTL value wins
        var mergedRTL = exports.mergeBooleanValues(acc.rtl, next.rtl);
        if (typeof mergedRTL === 'boolean') {
            acc.rtl = mergedRTL;
        }
        // Use provided renderer if it is defined
        acc.target = next.target || acc.target;
        acc.renderer = exports.getRenderer(createRenderer, acc.target);
        // Latest disableAnimations value wins
        var mergedDisableAnimations = exports.mergeBooleanValues(acc.disableAnimations, next.disableAnimations);
        if (typeof mergedDisableAnimations === 'boolean') {
            acc.disableAnimations = mergedDisableAnimations;
        }
        acc.performance = exports.mergePerformanceOptions(acc.performance, next.performance || {});
        acc.telemetry = next.telemetry || acc.telemetry;
        return acc;
    }, emptyContext);
};
exports.mergeProviderContexts = mergeProviderContexts;
