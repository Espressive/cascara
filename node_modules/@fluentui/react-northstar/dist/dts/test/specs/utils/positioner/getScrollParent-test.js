"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require("lodash");
var getScrollParent_1 = require("src/utils/positioner/getScrollParent");
var overflowStyles = [
    { overflow: 'scroll' },
    { overflowX: 'auto' },
    { overflowY: 'overlay' },
    { overflowX: 'scroll', overflowY: 'auto' },
    { overflowX: 'scroll', overflowY: 'auto', overflow: 'overlay' },
];
var setStylesForElement = function (element, style) {
    Object.keys(style).forEach(function (prop) {
        element.style[prop] = style[prop];
    });
};
var setStylesForElements = function (elements, style) {
    return elements.forEach(function (element) { return setStylesForElement(element, style); });
};
var resetOverflowStyles = function (element) {
    return ['overflow', 'overflowX', 'overflowY'].map(function (prop) { return (element.style[prop] = ''); });
};
var testsSetupFactory = function () {
    var treeElements = _.range(4).map(function () { return document.createElement('div'); });
    var element = treeElements[0], nonScrollableParent = treeElements[1], scrollableParent = treeElements[2], scrollableGrandparent = treeElements[3];
    return {
        element: element,
        scrollableParent: scrollableParent,
        scrollableGrandparent: scrollableGrandparent,
        init: function () {
            nonScrollableParent.appendChild(element); // first parent is non scrollable
            scrollableParent.appendChild(nonScrollableParent); // 2nd parent is scrollable; this is the result of the getScrollParent function
            scrollableGrandparent.appendChild(scrollableParent); // 3nd parent is not scrollable; this is the result of the getScrollParent function
            document.body.appendChild(scrollableGrandparent);
        },
        resetStyles: function () {
            treeElements.forEach(function (treeElement) { return resetOverflowStyles(treeElement); });
        },
        destroy: function () {
            document.body.removeChild(scrollableGrandparent);
        },
    };
};
describe('getScrollParent', function () {
    var testsSetup = testsSetupFactory();
    beforeAll(function () { return testsSetup.init(); });
    beforeEach(function () { return testsSetup.resetStyles(); });
    describe('when argument is <body />', function () {
        test('returns <body />', function () {
            expect(getScrollParent_1.getScrollParent(document.body)).toBe(document.body);
        });
    });
    describe('when argument is <html />', function () {
        test('returns <body />', function () {
            expect(getScrollParent_1.getScrollParent(document.documentElement)).toBe(document.body);
        });
    });
    describe('when argument is <document />', function () {
        test('returns <body />', function () {
            expect(getScrollParent_1.getScrollParent(document)).toBe(document.body);
        });
    });
    describe('when there is no scrollable parent for the node argument', function () {
        test('returns <body />', function () {
            expect(getScrollParent_1.getScrollParent(testsSetup.element)).toBe(document.body);
        });
    });
    describe('when there are scrollable parents for the node argument', function () {
        test('returns the first scrollable parent node', function () {
            overflowStyles.forEach(function (styles) {
                setStylesForElements([testsSetup.scrollableParent, testsSetup.scrollableGrandparent], styles);
                expect(getScrollParent_1.getScrollParent(testsSetup.element)).toBe(testsSetup.scrollableParent);
            });
        });
    });
    describe('when there are scrollable parents for the node argument and the node argument is scrollable', function () {
        test('returns the first scrollable parent node', function () {
            overflowStyles.forEach(function (styles) {
                setStylesForElements([testsSetup.element, testsSetup.scrollableParent, testsSetup.scrollableGrandparent], styles);
                expect(getScrollParent_1.getScrollParent(testsSetup.element)).toBe(testsSetup.scrollableParent);
            });
        });
    });
    afterAll(function () { return testsSetup.destroy(); });
});
