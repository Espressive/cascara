import { Ref } from '@fluentui/react-component-ref';
import * as PropTypes from 'prop-types';
import * as React from 'react';
import { videoBehavior } from '@fluentui/accessibility';
import { createShorthandFactory, commonPropTypes } from '../../utils';
import { getElementType, useStyles, useFluentContext, useUnhandledProps, useTelemetry, useAccessibility } from '@fluentui/react-bindings';
export var videoClassName = 'ui-video';

/**
 * A Video provides ability to embed video content.
 */
export var Video = /*#__PURE__*/function () {
  var Video = function Video(props) {
    var context = useFluentContext();

    var _useTelemetry = useTelemetry(Video.displayName, context.telemetry),
        setStart = _useTelemetry.setStart,
        setEnd = _useTelemetry.setEnd;

    setStart();
    var controls = props.controls,
        autoPlay = props.autoPlay,
        loop = props.loop,
        poster = props.poster,
        src = props.src,
        muted = props.muted,
        variables = props.variables,
        className = props.className,
        design = props.design,
        styles = props.styles;
    var videoRef = React.useRef();
    var ElementType = getElementType(props);
    var unhandledProps = useUnhandledProps(Video.handledProps, props);
    var getA11yProps = useAccessibility(props.accessibility, {
      debugName: Video.displayName
    });
    React.useEffect(function () {
      // this is a workaround for a potential memory leak in Chromium which retains a Detached HTMLVideoElement when <video autoplay> is unmounted
      // https://bugs.chromium.org/p/chromium/issues/detail?id=969049
      return function () {
        if (videoRef.current) {
          // we want to perform the cleanup on the latest element rendered
          // eslint-disable-next-line react-hooks/exhaustive-deps
          videoRef.current.src = '';
        }
      };
    }, []);
    React.useEffect(function () {
      // React doesn't guaranty that props will be set:
      // https://github.com/facebook/react/issues/10389
      if (videoRef.current) {
        videoRef.current.muted = !!muted;
      }
    }, [muted]);

    var _useStyles = useStyles(Video.displayName, {
      className: videoClassName,
      mapPropsToInlineStyles: function mapPropsToInlineStyles() {
        return {
          className: className,
          variables: variables,
          design: design,
          styles: styles
        };
      }
    }),
        classes = _useStyles.classes;

    var element = /*#__PURE__*/React.createElement(Ref, {
      innerRef: videoRef
    }, /*#__PURE__*/React.createElement(ElementType, getA11yProps('root', Object.assign({
      className: classes.root,
      autoPlay: autoPlay,
      controls: controls,
      loop: loop,
      poster: poster,
      src: src
    }, unhandledProps))));
    setEnd();
    return element;
  };

  Video.create = createShorthandFactory({
    Component: Video,
    mappedProp: 'src'
  });
  Video.displayName = 'Video';
  Video.propTypes = Object.assign({}, commonPropTypes.createCommon({
    children: false,
    content: false
  }), {
    autoPlay: PropTypes.bool,
    controls: PropTypes.bool,
    loop: PropTypes.bool,
    muted: PropTypes.bool,
    poster: PropTypes.string,
    src: PropTypes.string
  });
  Video.defaultProps = {
    as: 'video',
    accessibility: videoBehavior,
    controls: true,
    autoPlay: false,
    muted: false
  };
  Video.handledProps = Object.keys(Video.propTypes);
  return Video;
}();
//# sourceMappingURL=Video.js.map
