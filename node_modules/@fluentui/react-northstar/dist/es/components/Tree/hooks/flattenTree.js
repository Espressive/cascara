// Fluent UI Tree component does not have a root item.
// Adding a 'secret' root (level=0) helps traversing among the top level (level=1) tree items.
// This 'secret' root should NOT be returned as part of orderedItemIds, because it is not an item from user props
var SECRET_ROOT_ID = 'FLUENT_UI_SECRET_ROOT_ID';
/**
 * @returns returns the flattened tree, and an array of all visible tree item ids in a Depth First order.
 */

export function flattenTree(items, activeItemIds, selectedItemIds) {
  var _flatTree;

  var flatTree = (_flatTree = {}, _flatTree[SECRET_ROOT_ID] = {
    index: 1,
    level: 0,
    expanded: true,
    treeSize: 1,
    hasSubtree: true
  }, _flatTree); // returns an extra array of orderedItemIds because flattened tree object does not keep the order of insertion

  return flattenSubTree(items, 1, SECRET_ROOT_ID, flatTree, true, activeItemIds, [], selectedItemIds);
}

function flattenSubTree(items, level, parent, flatTree, isParentVisible, activeItemIds, visibleItemIds, selectedItemIds) {
  if (level === void 0) {
    level = 1;
  }

  if (isParentVisible === void 0) {
    isParentVisible = true;
  }

  if (!items) {
    return {
      flatTree: flatTree,
      visibleItemIds: visibleItemIds,
      selectedChildrenNum: 0,
      selectableChildrenNum: 0
    };
  }

  var itemsInLeaf = items.length;
  var selectedNum = 0;
  var selectableNum = 0;
  items.forEach(function (item, indexAmongSiblings) {
    var id = item.id,
        childrenItems = item.items;
    var selectable = item.selectable !== false; // by default item is selectable, unless selectable=false specified

    var hasSubtree = childrenItems ? !!childrenItems.length : false;
    var expanded = hasSubtree && activeItemIds.indexOf(id) !== -1;
    flatTree[id] = {
      item: item,
      index: indexAmongSiblings + 1,
      // Used for aria-posinset and it's 1-based.
      level: level,
      expanded: expanded,
      parent: parent == null ? undefined : parent,
      treeSize: itemsInLeaf,
      hasSubtree: hasSubtree,
      selected: false
    };

    if (isParentVisible) {
      visibleItemIds.push(id);
    }

    var _flattenSubTree = flattenSubTree(childrenItems, level + 1, id, flatTree, isParentVisible && expanded, // parent being visible and expanded means subtree is visible
    activeItemIds, visibleItemIds, selectedItemIds),
        selectedChildrenNum = _flattenSubTree.selectedChildrenNum,
        selectableChildrenNum = _flattenSubTree.selectableChildrenNum;

    if (selectable) {
      selectableNum++;

      if (hasSubtree && selectedChildrenNum === selectableChildrenNum || !hasSubtree && selectedItemIds.indexOf(id) >= 0 // selectedItemIds only make sense for leaf nodes
      ) {
          flatTree[id].selected = true;
          selectedNum++;
        } else if (selectedChildrenNum > 0) {
        flatTree[id].selected = 'indeterminate';
        selectedNum += 0.5; // trick to propagate indeterminate state to ancestors
      }
    }

    if (flatTree[parent].childrenIds) {
      flatTree[parent].childrenIds.push(id);
    } else {
      flatTree[parent].childrenIds = [id];
    }
  });
  return {
    flatTree: flatTree,
    visibleItemIds: visibleItemIds,
    selectedChildrenNum: selectedNum,
    selectableChildrenNum: selectableNum
  };
}
//# sourceMappingURL=flattenTree.js.map
