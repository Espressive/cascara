"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createHttpServer = createHttpServer;

var _fs = _interopRequireDefault(require("fs"));

var _http = _interopRequireDefault(require("http"));

var _https = _interopRequireDefault(require("https"));

var _pem = _interopRequireDefault(require("pem"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function createHttpServer(_x, _x2) {
  return _createHttpServer.apply(this, arguments);
}

function _createHttpServer() {
  _createHttpServer = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(cosmosConfig, requestListener) {
    var port, hostname, httpsEnabled, server, start, _start, stop, _stop;

    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _stop = function _stop3() {
              _stop = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
                return regeneratorRuntime.wrap(function _callee2$(_context2) {
                  while (1) {
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        _context2.next = 2;
                        return new Promise(function (resolve) {
                          return server.close(resolve);
                        });

                      case 2:
                      case "end":
                        return _context2.stop();
                    }
                  }
                }, _callee2);
              }));
              return _stop.apply(this, arguments);
            };

            stop = function _stop2() {
              return _stop.apply(this, arguments);
            };

            _start = function _start3() {
              _start = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
                var hostnameDisplay, protocol;
                return regeneratorRuntime.wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        _context.next = 2;
                        return new Promise(function (resolve) {
                          if (hostname === null) {
                            server.listen(port, resolve);
                          } else {
                            server.listen(port, hostname, resolve);
                          }
                        });

                      case 2:
                        hostnameDisplay = hostname || 'localhost';
                        protocol = httpsEnabled ? 'https' : 'http';
                        console.log("[Cosmos] See you at ".concat(protocol, "://").concat(hostnameDisplay, ":").concat(port));

                      case 5:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee);
              }));
              return _start.apply(this, arguments);
            };

            start = function _start2() {
              return _start.apply(this, arguments);
            };

            port = cosmosConfig.port, hostname = cosmosConfig.hostname, httpsEnabled = cosmosConfig.https;

            if (!httpsEnabled) {
              _context3.next = 14;
              break;
            }

            _context3.t1 = _https.default;
            _context3.next = 9;
            return getHttpsOpts(cosmosConfig);

          case 9:
            _context3.t2 = _context3.sent;
            _context3.t3 = requestListener;
            _context3.t0 = _context3.t1.createServer.call(_context3.t1, _context3.t2, _context3.t3);
            _context3.next = 15;
            break;

          case 14:
            _context3.t0 = _http.default.createServer(requestListener);

          case 15:
            server = _context3.t0;
            return _context3.abrupt("return", {
              server: server,
              start: start,
              stop: stop
            });

          case 17:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _createHttpServer.apply(this, arguments);
}

function getHttpsOpts(_x3) {
  return _getHttpsOpts.apply(this, arguments);
}

function _getHttpsOpts() {
  _getHttpsOpts = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(cosmosConfig) {
    var httpsOptions;
    return regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            httpsOptions = cosmosConfig.httpsOptions;

            if (!httpsOptions) {
              _context4.next = 3;
              break;
            }

            return _context4.abrupt("return", {
              key: _fs.default.readFileSync(httpsOptions.keyPath, 'utf8'),
              cert: _fs.default.readFileSync(httpsOptions.certPath, 'utf8')
            });

          case 3:
            console.log('[Cosmos] Generating HTTPS certificate');
            _context4.next = 6;
            return new Promise(function (resolve, reject) {
              _pem.default.createCertificate({
                days: 1000,
                selfSigned: true
              }, function (err, keys) {
                if (err) return reject(err);
                return resolve({
                  key: keys.serviceKey,
                  cert: keys.certificate
                });
              });
            });

          case 6:
            return _context4.abrupt("return", _context4.sent);

          case 7:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _getHttpsOpts.apply(this, arguments);
}