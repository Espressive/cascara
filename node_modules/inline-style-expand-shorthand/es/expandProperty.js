function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var LENGTH_UNIT = /(em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|q|in|pt|pc|px|dpi|dpcm|dppx|%|auto)$/i;
var CALC = /^(calc\()/i;
var VAR = /^(var\()/i;
var BORDER_STYLE = /^(dashed|dotted|double|groove|hidden|inset|none|outset|ridge|solid)$/i;
var BORDER_WIDTH = /^(thick|medium|think)$/i;

function splitShorthand(value) {
  var values = [''];
  var openParensCount = 0;
  var trimmedValue = value.trim();

  for (var index = 0; index < trimmedValue.length; index += 1) {
    if (trimmedValue.charAt(index) === ' ' && openParensCount === 0) {
      // Add new value
      values.push('');
    } else {
      // Add the current character to the current value
      values[values.length - 1] = values[values.length - 1] + trimmedValue.charAt(index);
    } // Keep track of the number of parentheses that are yet to be closed.
    // This is done to avoid splitting at whitespaces within CSS functions.
    // E.g.: `calc(1px + 1em)`


    if (trimmedValue.charAt(index) === '(') {
      openParensCount++;
    } else if (trimmedValue.charAt(index) === ')') {
      openParensCount--;
    }
  }

  return values;
}

function parseBorder(value, resolve) {
  var values = splitShorthand(value);
  var longhands = {};
  values.forEach(function (val) {
    if (val.match(BORDER_STYLE) !== null) {
      longhands[resolve('Style')] = val;
    } else if (val.match(BORDER_WIDTH) !== null || val.match(LENGTH_UNIT) !== null || val.match(CALC) !== null || val === '0') {
      longhands[resolve('Width')] = val;
    } else {
      longhands[resolve('Color')] = val;
    }
  });
  return longhands;
}

function parseCircular(value, resolve) {
  var _ref;

  var _splitShorthand = splitShorthand(value),
      _splitShorthand2 = _slicedToArray(_splitShorthand, 4),
      Top = _splitShorthand2[0],
      _splitShorthand2$ = _splitShorthand2[1],
      Right = _splitShorthand2$ === void 0 ? Top : _splitShorthand2$,
      _splitShorthand2$2 = _splitShorthand2[2],
      Bottom = _splitShorthand2$2 === void 0 ? Top : _splitShorthand2$2,
      _splitShorthand2$3 = _splitShorthand2[3],
      Left = _splitShorthand2$3 === void 0 ? Right : _splitShorthand2$3;

  return _ref = {}, _defineProperty(_ref, resolve('Top'), Top), _defineProperty(_ref, resolve('Right'), Right), _defineProperty(_ref, resolve('Bottom'), Bottom), _defineProperty(_ref, resolve('Left'), Left), _ref;
}

var circularExpand = {
  borderWidth: function borderWidth(key) {
    return 'border' + key + 'Width';
  },
  borderColor: function borderColor(key) {
    return 'border' + key + 'Color';
  },
  borderStyle: function borderStyle(key) {
    return 'border' + key + 'Style';
  },
  padding: function padding(key) {
    return 'padding' + key;
  },
  margin: function margin(key) {
    return 'margin' + key;
  }
};
var borderExpand = {
  borderLeft: function borderLeft(key) {
    return 'borderLeft' + key;
  },
  borderTop: function borderTop(key) {
    return 'borderTop' + key;
  },
  borderRight: function borderRight(key) {
    return 'borderRight' + key;
  },
  borderBottom: function borderBottom(key) {
    return 'borderBottom' + key;
  },
  outline: function outline(key) {
    return 'outline' + key;
  }
};

function parseFlex(value) {
  var values = splitShorthand(value);
  var longhands = {};
  values.forEach(function (val) {
    if (val.match(LENGTH_UNIT) !== null || val.match(CALC) !== null || val.match(VAR) !== null) {
      longhands.flexBasis = val;
    } else {
      if (longhands.flexGrow) {
        longhands.flexShrink = val;
      } else {
        longhands.flexGrow = val;
      }
    }
  });
  return longhands;
}

function expandProperty(property, value) {
  // special expansion for the border property as its 2 levels deep
  if (property === 'border') {
    var longhands = parseBorder(value.toString(), function (key) {
      return 'border' + key;
    });
    var result = {};

    for (var _property in longhands) {
      Object.assign(result, expandProperty(_property, longhands[_property]));
    }

    return result;
  }

  if (property === 'flex') {
    return parseFlex(value.toString());
  }

  if (circularExpand[property]) {
    return parseCircular(value.toString(), circularExpand[property]);
  }

  if (borderExpand[property]) {
    return parseBorder(value.toString(), borderExpand[property]);
  }
}

export default function preExpand(property, value) {
  if (Array.isArray(value)) {
    var result = {};
    value.forEach(function (item) {
      var itemResult = expandProperty(property, item);

      if (itemResult) {
        Object.keys(itemResult).forEach(function (itemProperty) {
          result[itemProperty] = result[itemProperty] || [];
          result[itemProperty].push(itemResult[itemProperty]);
        });
      }
    });

    if (Object.keys(result).length) {
      return result;
    }

    return null;
  }

  return expandProperty(property, value);
}