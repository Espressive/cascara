import { useLayoutEffect, Ref, MutableRefObject, RefObject, ComponentType, EffectCallback } from "react";
import { AnyFunction, InitialState } from "./types";
/**
 * `React.useLayoutEffect` that fallbacks to `React.useEffect` on server side.
 */
export declare const useSafeLayoutEffect: typeof useLayoutEffect;
/**
 * Returns a value that never changes even if the argument is updated.
 *
 * @example
 * import { useInitialValue } from "reakit-utils";
 *
 * function Component({ prop }) {
 *   const initialProp = useInitialValue(prop);
 * }
 */
export declare function useInitialValue<T>(value: InitialState<T>): T;
/**
 * Returns a value that is lazily initiated and never changes.
 *
 * @example
 * import { useLazyRef } from "reakit-utils";
 *
 * function Component() {
 *   const set = useLazyRef(() => new Set());
 * }
 */
export declare function useLazyRef<T>(init: () => T): T;
/**
 * Creates a `React.RefObject` that is constantly updated with the incoming
 * value.
 *
 * @example
 * import { useLiveRef } from "reakit-utils";
 *
 * function Component({ prop }) {
 *   const propRef = useLiveRef(prop);
 * }
 */
export declare function useLiveRef<T>(value: T): MutableRefObject<T>;
/**
 * Creates a memoized callback function that is constantly updated with the
 * incoming callback.
 *
 * @example
 * import { useEffect } from "react";
 * import { useEventCallback } from "reakit-utils";
 *
 * function Component(props) {
 *   const onClick = useEventCallback(props.onClick);
 *   useEffect(() => {}, [onClick]);
 * }
 */
export declare function useEventCallback<T extends AnyFunction>(callback?: T): (...args: Parameters<T>) => ReturnType<T>;
/**
 * Merges React Refs into a single memoized function ref so you can pass it to
 * an element.
 *
 * @example
 * import { forwardRef, useRef } from "react";
 * import { useForkRef } from "reakit-utils";
 *
 * const Component = forwardRef((props, ref) => {
 *   const internalRef = useRef();
 *   return <div {...props} ref={useForkRef(internalRef, ref)} />;
 * });
 */
export declare function useForkRef(...refs: Array<Ref<any> | undefined>): ((value: any) => void) | null;
/**
 * Returns the native tag name of an element by parsing its ref object. If the
 * second argument `defaultType` is provided, it's going to be used by default
 * on the first render, before React runs the effects.
 *
 * @example
 * import * as React from "react";
 * import { useNativeElementType } from "reakit-utils";
 *
 * function Component(props) {
 *   const ref = React.useRef();
 *   // button on the first render, div on the second render
 *   const type = useNativeElementType(ref, "button");
 *   return <div ref={ref} {...props} />;
 * }
 */
export declare function useNativeElementType(ref: RefObject<Element>, defaultType?: string | ComponentType): string | undefined;
/**
 * A `React.useEffect` that will not run on the first render.
 */
export declare function useUpdateEffect(effect: EffectCallback, deps?: ReadonlyArray<any> | undefined): void;
