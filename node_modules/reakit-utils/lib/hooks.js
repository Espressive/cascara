'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var dom = require('./dom.js');
var react = require('react');

/**
 * `React.useLayoutEffect` that fallbacks to `React.useEffect` on server side.
 */
var useSafeLayoutEffect = dom.canUseDOM ? react.useLayoutEffect : react.useEffect;
/**
 * Returns a value that never changes even if the argument is updated.
 *
 * @example
 * import { useInitialValue } from "reakit-utils";
 *
 * function Component({ prop }) {
 *   const initialProp = useInitialValue(prop);
 * }
 */

function useInitialValue(value) {
  var _useState = react.useState(value),
      initialValue = _useState[0];

  return initialValue;
}
/**
 * Returns a value that is lazily initiated and never changes.
 *
 * @example
 * import { useLazyRef } from "reakit-utils";
 *
 * function Component() {
 *   const set = useLazyRef(() => new Set());
 * }
 */

function useLazyRef(init) {
  var ref = react.useRef();

  if (ref.current === undefined) {
    ref.current = init();
  }

  return ref.current;
}
/**
 * Creates a `React.RefObject` that is constantly updated with the incoming
 * value.
 *
 * @example
 * import { useLiveRef } from "reakit-utils";
 *
 * function Component({ prop }) {
 *   const propRef = useLiveRef(prop);
 * }
 */

function useLiveRef(value) {
  var ref = react.useRef(value);
  useSafeLayoutEffect(function () {
    ref.current = value;
  });
  return ref;
}
/**
 * Creates a memoized callback function that is constantly updated with the
 * incoming callback.
 *
 * @example
 * import { useEffect } from "react";
 * import { useEventCallback } from "reakit-utils";
 *
 * function Component(props) {
 *   const onClick = useEventCallback(props.onClick);
 *   useEffect(() => {}, [onClick]);
 * }
 */

function useEventCallback(callback) {
  // @ts-ignore
  var ref = react.useRef(function () {
    throw new Error("Cannot call an event handler while rendering.");
  });
  useSafeLayoutEffect(function () {
    ref.current = callback;
  });
  return react.useCallback(function () {
    var _ref$current;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.call.apply(_ref$current, [ref].concat(args));
  }, []);
}
/**
 * Merges React Refs into a single memoized function ref so you can pass it to
 * an element.
 *
 * @example
 * import { forwardRef, useRef } from "react";
 * import { useForkRef } from "reakit-utils";
 *
 * const Component = forwardRef((props, ref) => {
 *   const internalRef = useRef();
 *   return <div {...props} ref={useForkRef(internalRef, ref)} />;
 * });
 */

function useForkRef() {
  for (var _len2 = arguments.length, refs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    refs[_key2] = arguments[_key2];
  }

  return react.useMemo(function () {
    if (!refs.some(Boolean)) return null;
    return function (value) {
      refs.forEach(setRef(value));
    };
  }, refs);
}

function setRef(value) {
  if (value === void 0) {
    value = null;
  }

  return function (ref) {
    if (!ref) return;

    if (typeof ref === "function") {
      ref(value);
    } else {
      ref.current = value;
    }
  };
}
/**
 * Returns the native tag name of an element by parsing its ref object. If the
 * second argument `defaultType` is provided, it's going to be used by default
 * on the first render, before React runs the effects.
 *
 * @example
 * import * as React from "react";
 * import { useNativeElementType } from "reakit-utils";
 *
 * function Component(props) {
 *   const ref = React.useRef();
 *   // button on the first render, div on the second render
 *   const type = useNativeElementType(ref, "button");
 *   return <div ref={ref} {...props} />;
 * }
 */


function useNativeElementType(ref, defaultType) {
  var _useState2 = react.useState(function () {
    return dom.getNativeElementType(null, defaultType);
  }),
      type = _useState2[0],
      setType = _useState2[1];

  useSafeLayoutEffect(function () {
    setType(dom.getNativeElementType(ref.current, defaultType));
  }, [ref, defaultType]);
  return type;
}
/**
 * A `React.useEffect` that will not run on the first render.
 */

function useUpdateEffect(effect, deps) {
  var mounted = react.useRef(false);
  react.useEffect(function () {
    if (mounted.current) {
      return effect();
    }

    mounted.current = true;
    return undefined;
  }, deps);
}

exports.useEventCallback = useEventCallback;
exports.useForkRef = useForkRef;
exports.useInitialValue = useInitialValue;
exports.useLazyRef = useLazyRef;
exports.useLiveRef = useLiveRef;
exports.useNativeElementType = useNativeElementType;
exports.useSafeLayoutEffect = useSafeLayoutEffect;
exports.useUpdateEffect = useUpdateEffect;
