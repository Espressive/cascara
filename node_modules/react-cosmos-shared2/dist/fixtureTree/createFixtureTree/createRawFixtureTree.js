"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createRawFixtureTree = createRawFixtureTree;

var _lodash = require("lodash");

var _util = require("../../util");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function createRawFixtureTree(fixtures) {
  var rootNode = {
    data: {
      type: 'fileDir'
    }
  };
  Object.keys(fixtures).forEach(function (fixturePath) {
    return addFixturePathToTree(rootNode, fixturePath, fixtures[fixturePath]);
  });
  return rootNode;
}

function addFixturePathToTree(rootNode, fixturePath, fixtureNames) {
  var _parseFixturePath = parseFixturePath(fixturePath),
      parents = _parseFixturePath.parents,
      fileName = _parseFixturePath.fileName;

  if (!fixtureNames) return injectNode(rootNode, parents, fileName, {
    data: {
      type: 'fixture',
      fixtureId: {
        path: fixturePath,
        name: null
      }
    }
  });
  injectNode(rootNode, parents, fileName, {
    data: {
      type: 'multiFixture',
      fixtureIds: createFixtureIds(fixturePath, fixtureNames)
    }
  });
}

function parseFixturePath(fixturePath) {
  var parents = fixturePath.split('/');
  var rawFixtureName = parents.pop();
  if (!rawFixtureName) throw new Error('Fixture name is empty');
  return {
    parents: parents,
    fileName: removeFixtureNameExtension(rawFixtureName)
  };
}

function removeFixtureNameExtension(fixtureName) {
  return fixtureName.replace(/\.(j|t)sx?$/, '');
}

function createFixtureIds(fixturePath, fixtureNames) {
  return fixtureNames.reduce(function (fixtureIds, fixtureName) {
    return _objectSpread(_objectSpread({}, fixtureIds), {}, _defineProperty({}, fixtureName, {
      path: fixturePath,
      name: fixtureName
    }));
  }, {});
}

function injectNode(rootNode, parents, childName, childNode) {
  if (parents.length === 0) return (0, _util.addTreeNodeChild)(rootNode, childName, childNode);
  var curParentDepth = 1;
  var curParent;

  do {
    var curParents = parents.slice(0, curParentDepth);
    var curPath = curParents.map(function (p) {
      return "children[\"".concat(p, "\"]");
    }).join('.');
    curParent = (0, _lodash.get)(rootNode, curPath);

    if (!curParent) {
      curParent = {
        data: {
          type: 'fileDir'
        }
      };
      (0, _lodash.set)(rootNode, curPath, curParent);
    }

    curParentDepth += 1;
  } while (curParentDepth <= parents.length);

  (0, _util.addTreeNodeChild)(curParent, childName, childNode);
}