"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FixtureLoader = void 0;

var _lodash = require("lodash");

var _react = _interopRequireDefault(require("react"));

var _react2 = require("../react");

var _fixtureHelpers = require("./fixtureHelpers");

var _FixtureProvider = require("./FixtureProvider");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var FixtureLoader = /*#__PURE__*/function (_React$Component) {
  _inherits(FixtureLoader, _React$Component);

  var _super = _createSuper(FixtureLoader);

  function FixtureLoader() {
    var _this;

    _classCallCheck(this, FixtureLoader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "state", {
      selectedFixture: _this.props.selectedFixtureId ? {
        fixtureId: _this.props.selectedFixtureId,
        fixtureState: {},
        syncedFixtureState: {}
      } : null,
      renderKey: 0
    });

    _defineProperty(_assertThisInitialized(_this), "unsubscribe", null);

    _defineProperty(_assertThisInitialized(_this), "handleRequest", function (msg) {
      if (msg.type === 'pingRenderers') {
        return _this.postReadyState();
      }

      if (!msg.payload || msg.payload.rendererId !== _this.props.rendererId) {
        return;
      }

      if (doesRequestChangeFixture(msg)) {
        _this.fireChangeCallback();
      }

      switch (msg.type) {
        case 'selectFixture':
          return _this.handleSelectFixtureRequest(msg);

        case 'unselectFixture':
          return _this.handleUnselectFixtureRequest();

        case 'setFixtureState':
          return _this.handleSetFixtureStateRequest(msg);

        default: // This Is Fineâ„¢
        // Actually, we can't be angry about getting unrelated messages here
        // because we don't do any preliminary message filtering to ignore stuff
        // like browser devtools communication, nor do we have any message
        // metadata conventions in place to perform such filtering at the moment

      }
    });

    _defineProperty(_assertThisInitialized(_this), "postFixtureStateChange", function (fixtureId, fixtureState) {
      var rendererId = _this.props.rendererId;

      _this.postMessage({
        type: 'fixtureStateChange',
        payload: {
          rendererId: rendererId,
          fixtureId: fixtureId,
          fixtureState: fixtureState
        }
      });
    });

    _defineProperty(_assertThisInitialized(_this), "setFixtureState", function (stateUpdate) {
      if (!_this.state.selectedFixture) {
        console.warn('[FixtureLoader] Trying to set fixture state with no fixture selected');
        return;
      } // Multiple state changes can be dispatched by fixture plugins at almost
      // the same time. Since state changes are batched in React, current state
      // (this.state.fixtureState) can be stale at dispatch time, and extending
      // it can result in cancelling previous state changes that are queued.
      // Using an updater function like ({ prevState }) => nextState ensures
      // every state change is honored, regardless of timing.


      _this.setState(function (_ref) {
        var selectedFixture = _ref.selectedFixture;

        if (!selectedFixture) {
          return null;
        }

        return {
          selectedFixture: _objectSpread(_objectSpread({}, selectedFixture), {}, {
            fixtureState: stateUpdate(selectedFixture.fixtureState)
          })
        };
      });
    });

    return _this;
  }

  _createClass(FixtureLoader, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (!this.props.selectedFixtureId) {
        var rendererConnect = this.props.rendererConnect;
        this.unsubscribe = rendererConnect.onMessage(this.handleRequest);
        this.postReadyState();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.unsubscribe) this.unsubscribe();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var fixtures = this.props.fixtures;

      if (!(0, _lodash.isEqual)(fixtures, prevProps.fixtures)) {
        this.postFixtureListUpdate();
      }

      var selectedFixture = this.state.selectedFixture;

      if (selectedFixture) {
        var fixtureId = selectedFixture.fixtureId,
            fixtureState = selectedFixture.fixtureState,
            syncedFixtureState = selectedFixture.syncedFixtureState;

        if (fixtureId && !(0, _lodash.isEqual)(fixtureState, syncedFixtureState)) {
          this.postFixtureStateChange(fixtureId, fixtureState);
          this.updateSyncedFixtureState(fixtureState);
        }
      }
    }
  }, {
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(prevProps, prevState) {
      // This check exists mainly to prevent updating the fixture tree when
      // fixture state setters resulted in no fixture state change
      return !(0, _lodash.isEqual)(this.props, prevProps) || !(0, _lodash.isEqual)(this.state, prevState);
    }
  }, {
    key: "render",
    value: function render() {
      var selectedFixture = this.state.selectedFixture;

      if (!selectedFixture) {
        return this.renderMessage('No fixture selected.');
      }

      var fixtures = this.props.fixtures;
      var fixtureId = selectedFixture.fixtureId,
          fixtureState = selectedFixture.fixtureState; // Falsy check doesn't do because fixtures can be any Node, including
      // null or undefined.

      if (!fixtures.hasOwnProperty(fixtureId.path)) {
        return this.renderMessage("Fixture path not found: ".concat(fixtureId.path));
      }

      var fixtureExport = fixtures[fixtureId.path];
      var fixture = (0, _fixtureHelpers.getFixture)(fixtureExport, fixtureId.name);

      if (typeof fixture === 'undefined') {
        return this.renderMessage("Invalid fixture ID: ".concat(JSON.stringify(fixtureId)));
      }

      var _this$props = this.props,
          systemDecorators = _this$props.systemDecorators,
          userDecorators = _this$props.userDecorators,
          onErrorReset = _this$props.onErrorReset;
      var renderKey = this.state.renderKey;
      return /*#__PURE__*/_react.default.createElement(_FixtureProvider.FixtureProvider // renderKey controls whether to reuse previous instances (and
      // transition props) or rebuild render tree from scratch
      , {
        key: renderKey,
        fixtureId: fixtureId,
        fixture: fixture,
        systemDecorators: systemDecorators,
        userDecorators: userDecorators,
        fixtureState: fixtureState,
        setFixtureState: this.setFixtureState,
        onErrorReset: onErrorReset || noop
      });
    }
  }, {
    key: "handleSelectFixtureRequest",
    value: function handleSelectFixtureRequest(_ref2) {
      var payload = _ref2.payload;
      var fixtureId = payload.fixtureId,
          fixtureState = payload.fixtureState;
      this.setState({
        selectedFixture: {
          fixtureId: fixtureId,
          fixtureState: fixtureState,
          syncedFixtureState: fixtureState
        },
        renderKey: this.state.renderKey + 1
      });
    }
  }, {
    key: "handleUnselectFixtureRequest",
    value: function handleUnselectFixtureRequest() {
      this.setState({
        selectedFixture: null,
        renderKey: 0
      });
    }
  }, {
    key: "handleSetFixtureStateRequest",
    value: function handleSetFixtureStateRequest(_ref3) {
      var payload = _ref3.payload;
      var fixtureId = payload.fixtureId,
          fixtureState = payload.fixtureState;
      var selectedFixture = this.state.selectedFixture; // Ensure fixture state applies to currently selected fixture

      if (selectedFixture && (0, _lodash.isEqual)(fixtureId, selectedFixture.fixtureId)) {
        this.setState({
          selectedFixture: {
            fixtureId: fixtureId,
            fixtureState: fixtureState,
            syncedFixtureState: fixtureState
          }
        });
      }
    }
  }, {
    key: "postReadyState",
    value: function postReadyState() {
      var rendererId = this.props.rendererId;
      this.postMessage({
        type: 'rendererReady',
        payload: {
          rendererId: rendererId,
          fixtures: this.getFixtureNamesByPath()
        }
      });
    }
  }, {
    key: "postFixtureListUpdate",
    value: function postFixtureListUpdate() {
      var rendererId = this.props.rendererId;
      this.postMessage({
        type: 'fixtureListUpdate',
        payload: {
          rendererId: rendererId,
          fixtures: this.getFixtureNamesByPath()
        }
      });
    }
  }, {
    key: "getFixtureNamesByPath",
    value: function getFixtureNamesByPath() {
      return (0, _react2.getFixtureNamesByPath)(this.props.fixtures);
    }
  }, {
    key: "fireChangeCallback",
    value: function fireChangeCallback() {
      var onErrorReset = this.props.onErrorReset;

      if (typeof onErrorReset === 'function') {
        onErrorReset();
      }
    }
  }, {
    key: "updateSyncedFixtureState",
    value: function updateSyncedFixtureState(syncedFixtureState) {
      this.setState(function (_ref4) {
        var selectedFixture = _ref4.selectedFixture;

        if (!selectedFixture) {
          return null;
        } // Other updates that alter state.selectedFixture can be pending when this
        // update is submitted. Those updates will be applied first. With this in
        // mind, we use a state setter callback to only override syncedFixtureState
        // and keep the latest values of other state parts.


        return {
          selectedFixture: _objectSpread(_objectSpread({}, selectedFixture), {}, {
            syncedFixtureState: syncedFixtureState
          })
        };
      });
    }
  }, {
    key: "postMessage",
    value: function postMessage(msg) {
      this.props.rendererConnect.postMessage(msg);
    }
  }, {
    key: "renderMessage",
    value: function renderMessage(msg) {
      return typeof this.props.renderMessage !== 'undefined' ? this.props.renderMessage({
        msg: msg
      }) : msg;
    }
  }]);

  return FixtureLoader;
}(_react.default.Component);

exports.FixtureLoader = FixtureLoader;

function doesRequestChangeFixture(r) {
  return r.type === 'selectFixture' || r.type === 'unselectFixture';
}

function noop() {}