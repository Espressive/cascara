"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useFixtureProps = useFixtureProps;

var _lodash = require("lodash");

var _react = _interopRequireDefault(require("react"));

var _fixtureState = require("../../../fixtureState");

var _react2 = require("../../../react");

var _findRelevantElementPaths = require("../shared/findRelevantElementPaths");

var _nodeTree = require("../shared/nodeTree");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function useFixtureProps(fixture, fixtureState, decoratorId) {
  // React.useMemo is used as a cache invalidated by decoratorId
  // eslint-disable-next-line react-hooks/exhaustive-deps
  var propCache = _react.default.useMemo(function () {
    return {};
  }, [decoratorId]);

  var elPaths = (0, _findRelevantElementPaths.findRelevantElementPaths)(fixture);
  return elPaths.reduce(function (extendedFixture, elPath) {
    var elementId = {
      decoratorId: decoratorId,
      elPath: elPath
    };
    var fsProps = (0, _fixtureState.findFixtureStateProps)(fixtureState, elementId);
    return (0, _nodeTree.setElementAtPath)(extendedFixture, elPath, function (element) {
      if (!fsProps || componentTypeChanged(fsProps.componentName)) {
        return _objectSpread(_objectSpread({}, element), {}, {
          key: getElRenderKey(elPath, _fixtureState.DEFAULT_RENDER_KEY)
        });
      } // Prevent overriding child elements with outdated "children" prop values
      // stored in fixture state
      // See https://github.com/react-cosmos/react-cosmos/pull/920 for context


      var originalProps = element.props;
      var extendedProps = (0, _fixtureState.extendWithValues)(originalProps, fsProps.values); // Preserve identity between renders for indentical non-primitive props

      var cachedProps = (0, _lodash.mapValues)(extendedProps, function (value, propName) {
        var key = getPropCacheKey(elPath, propName);
        if (!propCache.hasOwnProperty(key)) propCache[key] = originalProps[propName];
        if ((0, _lodash.isEqual)(propCache[key], value)) return propCache[key];
        propCache[key] = value;
        return value;
      }); // HACK alert: Editing React Element by hand
      // This is blasphemy, but there are two reasons why React.cloneElement
      // isn't ideal:
      //   1. Props need to overridden (not merged)
      //   2. element.key has to be set to control whether the prev instance
      //      should be reused or not
      // To be revised in case this approach causes trouble in the future.
      // Useful links:
      //   - https://reactjs.org/docs/react-api.html#cloneelement
      //   - https://github.com/facebook/react/blob/15a8f031838a553e41c0b66eb1bcf1da8448104d/packages/react/src/ReactElement.js#L293-L362

      return _objectSpread(_objectSpread({}, element), {}, {
        props: hasChildElPaths(elPaths, elPath) ? _objectSpread(_objectSpread({}, cachedProps), {}, {
          children: originalProps.children
        }) : cachedProps,
        key: getElRenderKey(elPath, fsProps.renderKey)
      });

      function componentTypeChanged(componentName) {
        return componentName !== (0, _react2.getComponentName)(element.type);
      }
    });
  }, fixture);
}

function getPropCacheKey(elPath, propName) {
  return elPath ? "".concat(elPath, "-").concat(propName) : propName;
}

function getElRenderKey(elPath, renderKey) {
  return "".concat(elPath, "-").concat(renderKey);
}

function hasChildElPaths(elPaths, elPath) {
  return elPaths.some(function (p) {
    return p.indexOf((0, _nodeTree.getChildrenPath)(elPath)) === 0;
  });
}