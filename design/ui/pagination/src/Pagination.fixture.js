import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import { List, Table } from 'semantic-ui-react';

import { Pagination } from './Pagination';
import fixtureData from './fixtureData';

const sharedPropTypes = {
  data: PropTypes.arrayOf(
    PropTypes.shape({
      id: PropTypes.number,
      first_name: PropTypes.string,
      last_name: PropTypes.string,
      email: PropTypes.string,
      job_title: PropTypes.string,
      avatar: PropTypes.string,
    })
  ).isRequired,
};

/**
 * An example on how to separate the content
 * from the pagination.
 */
const CustomTable = ({ data }) => (
  <Table celled padded style={{ paddingTop: '0' }}>
    <Table.Header>
      <Table.Row>
        {Object.keys(data[0]).map((field) => (
          <Table.HeaderCell key={field}>{field}</Table.HeaderCell>
        ))}
      </Table.Row>
    </Table.Header>
    <Table.Body>
      {data.map((row) => (
        <Table.Row key={row.id}>
          {Object.keys(row).map((field) => (
            <Table.Cell key={field}>
              {field === 'avatar' ? (
                <img src={row[field]} alt='employee' />
              ) : (
                row[field]
              )}
            </Table.Cell>
          ))}
        </Table.Row>
      ))}
    </Table.Body>
  </Table>
);
CustomTable.propTypes = sharedPropTypes;

export const CustomList = ({ data }) => (
  <List relaxed>
    {data.map((item) => (
      <List.Item key={item.id}>
        <List.Content>
          <List.Header as='a'>{`${item.first_name} ${item.last_name}`}</List.Header>
          <List.Description>{item.job_title}</List.Description>
        </List.Content>
      </List.Item>
    ))}
  </List>
);
CustomList.propTypes = sharedPropTypes;

/**
 * Since the behaviour of our commponent depends on its input, we must create an
 * environment capable of interacting with it.
 *
 * The data and its presentation are handled by this component (the external world).
 * Our test subject (Pagination) is only responsible for receiving the current values
 * for page and itemsPerPageLimit and notify (the external world) about any changes generated by
 * the means of children components under its domain.
 *
 * The state of this component tracks page and itemsPerPageLimit as well, this is because we are
 * pretending to be connected to an external data source and we are passing the response. */
export class Wrapper extends PureComponent {
  static propTypes = {
    entityNamePlural: PropTypes.string,
    entityNameSingular: PropTypes.string,
    recordCount: PropTypes.number,
    variant: PropTypes.string,
  };

  static defaultProps = {
    entityNamePlural: 'Total',
    entityNameSingular: 'Total',
    recordCount: fixtureData.length,
    variant: 'table',
  };

  state = {
    data: [].concat(fixtureData).slice(0, 10),
    itemsPerPageLimit: 10,
    currentPage: 1,
    rawData: [].concat(fixtureData),
  };

  handlePaginationChange = (newPagination) => {
    const { rawData } = this.state;
    const recordCount = rawData.length;
    const { limit: itemsPerPageLimit, page: currentPage } = newPagination;
    const totalPages = Math.ceil(recordCount / itemsPerPageLimit);
    const sliceFrom = itemsPerPageLimit * currentPage - itemsPerPageLimit;
    const displayTo =
      currentPage === totalPages ? recordCount : sliceFrom + itemsPerPageLimit;
    const data = [].concat(rawData).slice(sliceFrom, displayTo);

    this.setState({
      data,
      itemsPerPageLimit,
      currentPage,
    });
  };

  render() {
    const { data, itemsPerPageLimit, currentPage } = this.state;
    const {
      entityNamePlural,
      entityNameSingular,
      recordCount,
      variant,
    } = this.props;

    return (
      <Pagination
        entityNamePlural={entityNamePlural}
        entityNameSingular={entityNameSingular}
        isLoading={false}
        itemsPerPageLimit={itemsPerPageLimit}
        onPaginationChange={this.handlePaginationChange}
        currentPage={currentPage}
        recordCount={recordCount}
      >
        {variant === 'table' && <CustomTable data={data} />}
        {variant === 'list' && <CustomList data={data} />}
      </Pagination>
    );
  }
}

export default {
  table: (
    <Wrapper
      entityNamePlural={'Employees'}
      entityNameSingular={'Employee'}
      recordCount={100}
      variant={'table'}
    />
  ),
  list: (
    <Wrapper
      entityNamePlural={'Employees'}
      entityNameSingular={'Employee'}
      recordCount={100}
      variant={'list'}
    />
  ),
};
