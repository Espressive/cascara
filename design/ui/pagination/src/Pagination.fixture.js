import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import { List, Table } from 'semantic-ui-react';

import { Pagination } from './Pagination';
import fixtureData from './fixtureData';

const sharedPropTypes = {
  data: PropTypes.arrayOf(
    PropTypes.shape({
      id: PropTypes.number,
      first_name: PropTypes.string,
      last_name: PropTypes.string,
      email: PropTypes.string,
      job_title: PropTypes.string,
      avatar: PropTypes.string,
    })
  ).isRequired,
};

/**
 * An example on how to separate the content
 * from the pagination.
 */
const CustomTable = ({ data }) => {
  const renderBodyRow = function (row) {
    return (
      <Table.Row key={row.id}>
        {Object.keys(row).map((field) => (
          <Table.Cell key={field}>
            {field === 'avatar' ? (
              <img src={row[field]} alt='employee' />
            ) : (
              row[field]
            )}
          </Table.Cell>
        ))}
      </Table.Row>
    );
  };

  return (
    <Table
      celled
      padded
      // eslint-disable-next-line react/jsx-no-bind
      renderBodyRow={renderBodyRow} // ^^ bending the law!
      style={{ paddingTop: '0' }}
      tableData={data}
    >
      <Table.Header>
        <Table.Row>
          {Object.keys(data[0]).map((field) => (
            <Table.HeaderCell key={field}>{field}</Table.HeaderCell>
          ))}
        </Table.Row>
      </Table.Header>
      <Table.Body>
        {data.map((row) => (
          <Table.Row key={row.id}>
            {Object.keys(row).map((field) => (
              <Table.Cell key={field}>
                {field === 'avatar' ? (
                  <img src={row[field]} alt='employee' />
                ) : (
                  row[field]
                )}
              </Table.Cell>
            ))}
          </Table.Row>
        ))}
      </Table.Body>
    </Table>
  );
};
CustomTable.propTypes = sharedPropTypes;

export const CustomList = ({ data }) => (
  <List relaxed>
    {data.map((item) => (
      <List.Item key={item.id}>
        <List.Content>
          <List.Header as='a'>{`${item.first_name} ${item.last_name}`}</List.Header>
          <List.Description>{item.job_title}</List.Description>
        </List.Content>
      </List.Item>
    ))}
  </List>
);
CustomList.propTypes = sharedPropTypes;

/**
 * Since the behaviour of our commponent depends on its input, we must create an
 * environment capable of interacting with it.
 *
 * The data and its presentation are handled by this component (the external world).
 * Our test subject (Pagination) is only responsible for receiving the current values
 * for page and limit and notify (the external world) about any changes generated by
 * the means of children components under its domain.
 *
 * The state of this component tracks page and limit as well, this is because we are
 * pretending to be connected to an external data source and we are passing the response. */
export class Wrapper extends PureComponent {
  static propTypes = {
    entityNamePlural: PropTypes.string,
    entityNameSingular: PropTypes.string,
    totalItems: PropTypes.number,
    variant: PropTypes.string,
  };

  static defaultProps = {
    entityNamePlural: 'Total',
    entityNameSingular: 'Total',
    totalItems: fixtureData.length,
    variant: 'table',
  };

  state = {
    data: [].concat(fixtureData).slice(0, 10),
    limit: 10,
    page: 1,
    rawData: [].concat(fixtureData),
  };

  handlePaginationChange = (newPagination) => {
    const { rawData } = this.state;
    const totalItems = rawData.length;
    const { limit, page } = newPagination;
    const totalPages = Math.ceil(totalItems / limit);
    const sliceFrom = limit * page - limit;
    const displayTo = page === totalPages ? totalItems : sliceFrom + limit;
    const data = [].concat(rawData).slice(sliceFrom, displayTo);

    this.setState({
      data,
      limit,
      page,
    });
  };

  render() {
    const { data, limit, page } = this.state;
    const {
      entityNamePlural,
      entityNameSingular,
      totalItems,
      variant,
    } = this.props;

    return (
      <Pagination
        entityNamePlural={entityNamePlural}
        entityNameSingular={entityNameSingular}
        isLoading={false}
        limit={limit}
        onPaginationChange={this.handlePaginationChange}
        page={page}
        count={totalItems}
      >
        {variant === 'table' && <CustomTable data={data} />}
        {variant === 'list' && <CustomList data={data} />}
      </Pagination>
    );
  }
}

export default {
  table: (
    <Wrapper
      entityNamePlural={'Employees'}
      entityNameSingular={'Employee'}
      totalItems={100}
      variant={'table'}
    />
  ),
  list: (
    <Wrapper
      entityNamePlural={'Employees'}
      entityNameSingular={'Employee'}
      totalItems={100}
      variant={'list'}
    />
  ),
};
