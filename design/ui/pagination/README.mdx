---
name: Pagination
---

import semanticUiCssOffline from 'semantic-ui-css-offline';
import { Playground, Props } from 'docz';
import { Pagination } from './es';

# Espressive UI Pagination
This component abstracts the pagination logic into a reusable block that can be implemented anywhere pagination is required.

## Separation of concerns
The only concern of this component is to display a UI that allows the User to paginate through some content, the presentation of such content as well as its source are outside of the scope of this component.


## Props
| Name    | Default    | Type | Description |
| --------|------------|------| ------------|
|entityNamePlural|`Null`|String|Entitiy's name in plural form|
|entityNameSingular|`Total`|String|Entitiy's name in singular form|
|isLoading|`false`|Boolean|Specifies if the data is loading|
|onPaginationChange|`noop`|Function|Upstream logic to be called on change|
|limit|`10`|Number|Number of items to display per page|
|page|`1`|Number|Current page number|
|totalItems|`0`|Number|Total count of items to be paginated|

## Using this module
A good example on how to use this module is the Cosmos fixture:
````
import React, {PureComponent} from 'react';
import PropTypes  from 'prop-types';
import {Table}                from 'semantic-ui-react';

import Pagination             from './Pagination';
import dataFixture            from './fixtureData';

/**
 * An example on how to separate the content
 * from the pagination.
 */
const ExternalTable = ({data}) => {
  const renderBodyRow = function (row) {
    return (
      <Table.Row key={row.id}>
        {
          Object
            .keys(row)
            .map((field) => (
              <Table.Cell key={field}>
                {row[field]}
              </Table.Cell>
            ))
        }
      </Table.Row>
    );
  };

  return (
    <Table
      celled
      padded
      // eslint-disable-next-line react/jsx-no-bind
      renderBodyRow={renderBodyRow} // ^^ bending the law!
      tableData={data}
    />
  );
};
ExternalTable.propTypes = {
  data: PropTypes.arrayOf(PropTypes.shape({
    id    : PropTypes.number,
    email : PropTypes.string,
  })).isRequired,
};

/**
 * Since the behaviour of our commponent depends on its input, we must create an
 * environment capable of interacting with it.
 *
 * The data and its presentation are handled by this component (the external world).
 * Our test subject (Pagination) is only responsible for receiving the current values
 * for page and limit and notify (the external world) about any changes generated by
 * the means of children components under its domain.
 *
 * The state of this component tracks page and limit as well, this is because we are
 * pretending to be connected to an external data source and we are passing the response. */
export class Wrapper extends PureComponent {

  static propTypes = {
    entityNamePlural   : PropTypes.string,
    entityNameSingular : PropTypes.string,
    totalItems         : PropTypes.number,
  };

  static defaultProps = {
    entityNamePlural   : 'Total',
    entityNameSingular : 'Total',
    totalItems         : dataFixture.length,
  };

  state = {
    data    : [].concat(dataFixture).slice(0, 10),
    limit   : 10,
    page    : 1,
    rawData : [].concat(dataFixture),
  };

  handlePaginationChange = (newPagination) => {
    const {rawData} = this.state;
    const totalItems = rawData.length;
    const {limit, page} = newPagination;
    const totalPages = Math.ceil(totalItems / limit);
    const sliceFrom = limit * page - limit;
    const displayTo = page === totalPages ? totalItems : sliceFrom + limit;
    const data = [].concat(rawData).slice(sliceFrom, displayTo);

    this.setState({
      data,
      limit,
      page,
    });
  };

  render() {
    const {data, limit, page} = this.state;
    const {
      entityNamePlural,
      entityNameSingular,
      totalItems,
    } = this.props;

    return (
      <Pagination
        entityNamePlural={entityNamePlural}
        entityNameSingular={entityNameSingular}
        isLoading={false}
        limit={limit}
        onPaginationChange={this.handlePaginationChange}
        page={page}
        totalItems={totalItems}
      >
        <ExternalTable data={data} />
      </Pagination>
    );
  }

}

export default <Wrapper />;
````

## Running tests
Run `yarn test` at the root of the monorepo


## Running Cosmos
Run `yarn cosmos` at the root of the monorepo
Cosmos fixture is ready, but Cosmos setup is not. Expect an update once we configure Cosmos.

<Props of={Pagination} />

<Playground>
  <Pagination
    entityNamePlural={'Employees'}
    entityNameSingular={'Employee'}
    isLoading={false}
    limit={10}
    page={1}
    count={100}
  />
</Playground>
